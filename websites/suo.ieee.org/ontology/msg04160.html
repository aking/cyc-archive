<!-- MHonArc v2.4.8 -->
<!--X-Subject: RE: ONT RE: Ontology case study -->
<!--X-From-R13: "Quevf Bnegevqtr" <puevf_cnegevqtrNpfv.pbz> -->
<!--X-Date: Thu, 30 May 2002 06:28:26 &#45;0400 (EDT) -->
<!--X-Message-Id: EBEMKBFIHNNPELLHDEKLMEMKCCAA.chris_partridge@csi.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: B91B4D4B.465D%andersen@ontologyworks.com -->
<!--X-Head-End-->

<!-- /groups/802/3/efm/public/email/msg04160.html -->
<!-- /groups/???? ?SUO?                              -->

<HTML>

<HEAD>
<TITLE>RE: ONT RE: Ontology case study</TITLE>
<LINK REV="made" HREF="mailto:chris_partridge@csi.com">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->

<CENTER>

<TABLE CELLPADDING=3 CELLSPACING=0 BORDER=1 WIDTH="100%">
<TBODY>
<TR ALIGN="CENTER">
<TH COLSPAN=3><STRONG>Thread Links</STRONG></TH>
<TH COLSPAN=3><STRONG>Date Links</STRONG></TH>
</TR>
<TR ALIGN="CENTER">
<TD><A HREF="msg04155.html">Thread Prev</A>
</TD>
<TD><A HREF="msg04175.html">Thread Next</A>
</TD>
<TD><A HREF="thrd7.html#04160">Thread Index</A></Td>
<TD><A HREF="msg04161.html">Date Prev</A></TD>
<TD><A HREF="msg04159.html">Date Next</A>
</TD>
<TD><A HREF="mail7.html#04160">Date Index</A></TD>
</TR>
</TBODY>
</TABLE>
</CENTER>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>RE: ONT RE: Ontology case study</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;SUO Ontology&quot; &lt;<A HREF="mailto:ontology@ieee.org">ontology@ieee.org</A>&gt;</li>
<li><em>Subject</em>: RE: ONT RE: Ontology case study</li>
<li><em>From</em>: &quot;Chris Partridge&quot; &lt;<A HREF="mailto:chris_partridge@csi.com">chris_partridge@csi.com</A>&gt;</li>
<li><em>Date</em>: Thu, 30 May 2002 11:28:37 +0200</li>
<li><em>Importance</em>: Normal</li>
<li><em>In-Reply-To</em>: &lt;<a href="msg04155.html">B91B4D4B.465D%andersen@ontologyworks.com</a>&gt;</li>
<li><em>Reply-To</em>: &lt;<A HREF="mailto:mail@ChrisPartridge.net">mail@ChrisPartridge.net</A>&gt;</li>
<li><em>Sender</em>: <A HREF="mailto:owner-ontology@majordomo.ieee.org">owner-ontology@majordomo.ieee.org</A></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>

Bill,

I think we may be talking at cross-purposes here. My comments below marked
CP2&gt;

Chris

-----Original Message-----
From: andersen@ontologyworks.com [<A  HREF="mailto:andersen@ontologyworks.com">mailto:andersen@ontologyworks.com</A>]
Sent: 30 May 2002 10:30
To: mail@ChrisPartridge.net; Chris Partridge; SUO Ontology
Subject: Re: ONT RE: Ontology case study


On 5/30/02 1:34, &quot;Chris Partridge&quot; &lt;chris_partridge@csi.com&gt; wrote:

&gt; CP&gt; Bill, I think I agree with all that you say, but I am not sure of its
&gt; relevance. I have seen an argument on this list many time that using FOL
one
&gt; can deduce results that one cannot from a standard database. It has been
&gt; suggested that this is an unalloyed good. I am suggesting that things are
&gt; not so easy.

Well, first I don't know what a &quot;standard database&quot; is - probably you're
thinking of a relational database.  And I would agree that all that FOL
gives you is not necessarily good and desirable.

First, I have always been dubious of the utility of classical negation for
any practical purpose.  If I say:

  &quot;If X likes sports and doesn't like baseball, then X likes football&quot;

I generally don't have in mind the following inference:

  &quot;If X likes sports and doesn't like football, then X likes baseball&quot;

Or worse,

  &quot;If X likes neither baseball nor football, then X doesn't like sports&quot;

These may make sense for one-deep inferences, like &quot;I want to go to
Cleveland or Chicago and I can't go to Cleveland, so I'll go to Chicago&quot;,
but it starts to get weird when the classical negation is buried 10 or 12
ply deep in an inference.  This is one of the reasons that Cyc is so
terribly slow - if you ask for someone's age, it ends up trying to prove
that China isn't a soft drink or something silly like that in the process.

Second, some things you just can't define in FOL, like transitive closure or
inductive definitions in general.   One example of this is being unable to
prove that Mickey Mouse is not an integer from the Peano axioms, or being
able to prove that a given pair P(a,b) is not in the transitive closure of a
relation P.  You can do this with a fixpoint semantics, but you're not in
the classical FOL world anymore.

CP2&gt; Agreed - And if I can expand this a bit. Firstly, the examples you give
assume the data is correct. I (and Dummett) are suggesting that it is
normally only reasonably correct (i.e. not exact) - and so one needs to
include tolerances in one's system. Secondly, an underlying point is that
database systems seem to control the link between inference and action - or
prompt for action. So the 'inferences' that are used to send telex
instructions (or print out the telex instructions for someone to send) are
spelt out and fixed in the programs that use the database. Obviously it is
commercially important not to send incorrect telex instructions - so the
tolerances on these must be good enough.

&gt; CP&gt;Operational systems do things. A banking system will issue instructions
&gt; to make payments and when it receives such a message it makes the payment.
&gt; It seems to me absolutely clear that this is true and that FOL by itself -
&gt; as ChrisM's example shows - cannot. I am just pointing out the difference.
&gt; CP&gt;How would an FOL theorem prover issue payment instructions - and would
it
&gt; be doing more than just FOL?

I don't get it.  An FOL theorem prover could be hooked up to a banking
system in just the same way a database is.  The parties using the system
wouldn't even notice, except that their transactions would take a whole lot
longer! ;-D
CP2&gt;Agreed - I am talking about the whole system - database plus programs
(note in the extract I say 'Operational systems' not 'database'). In your
example (I assume), the theorem prover is linked up to a system that then
initiates the payment etc. So it is the prover + programs that acts.

&gt; This is just false, Chris.  Databases are simply machines that implement
the
&gt; relational algebra, which, when recursion/iteration is added, is
equivalent
&gt; in expressive power to FOL.  What you can do in one you can do in the
other.

&gt;&gt; What is false? That in databases there is a distinction between entity
&gt;&gt; and attribute and this is based (however unconsciously) on the
Aristotelian
&gt;&gt; distinction between substance and attribute.

That's not true.  A relational database is, at its core, an implementation
of relational algebra, perhaps with some extra goodies added like iteration.
If you take any commercial DBMS, and ask a SQL query, you can examine its
execution plan and see these operations that the DBMS executes.

Relational algebra doesn't know anything about substance or attribute - all
it &quot;knows&quot; about are relations and a set of operations (cartesian product,
selection, and projection) that can be performed on them.

Now it may be the case that a particular data modeling *language* may have
such a bias or intention built in.  I know that, while he didn't have
philosophy in mind, Chen had notions like object and attribute in mind when
he developed the entity-relationship model, the most common &quot;formalism&quot; for
building data models that are implemented by the data-definition facilities
of SQL.  At the same time, the original relational model of Codd that all
relational DBMS are based on (roughly - the original is more powerful than
any current implementation) had no such distinctions in mind.

CP2&gt; I suspect we are talking at cross purposes. You are talking about the
product of the implementation stage - I am talking about the product of the
analysis stage. In building commercial computer systems, according to the
textbooks (and sometimes in practice) there is a stage of logical analysis
where a model is produced - independent of its implementation details. This
typically has entity and attribute types (or object and attribute types). In
the literature these are sometimes taken to reflect distinctions in the
world. It may be these structures are formalised using a relational
algebra - but the people using it do not normally consider the
formalisation. It seems to me a mistake to assume that the formalisation
given after the event necessarily reflect the ontological intentions of the
people using it.
CP2&gt;One can see the outline of the ontological commitment in the constraint
that an individual entity cannot change its entity type - but can change
some of its (accidental) attributes.

  .bill


</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="04155" href="msg04155.html">Re: ONT RE: Ontology case study</a></strong>
<ul><li><em>From:</em> Bill Andersen &lt;andersen@ontologyworks.com&gt;</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg04161.html">Re: ONT RE: Ontology case study</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg04159.html">RE: ONT RE: Ontology case study</A></STRONG>
</LI>
<li>Prev by thread:
<strong><a href="msg04155.html">Re: ONT RE: Ontology case study</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg04175.html">RE: ONT RE: Ontology case study</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="mail7.html#04160"><strong>Date</strong></a></li>
<li><a href="thrd7.html#04160"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
