<!-- MHonArc v2.4.8 -->
<!--X-Subject: Re: ONT RE: Ontology case study -->
<!--X-From-R13: Pvyy Oaqrefra <naqrefraNbagbybtljbexf.pbz> -->
<!--X-Date: Thu, 30 May 2002 04:30:42 &#45;0400 (EDT) -->
<!--X-Message-Id: B91B4D4B.465D%andersen@ontologyworks.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: EBEMKBFIHNNPELLHDEKLKEMHCCAA.chris_partridge@csi.com -->
<!--X-Head-End-->

<!-- /groups/802/3/efm/public/email/msg04155.html -->
<!-- /groups/???? ?SUO?                              -->

<HTML>

<HEAD>
<TITLE>Re: ONT RE: Ontology case study</TITLE>
<LINK REV="made" HREF="mailto:andersen@ontologyworks.com">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->

<CENTER>

<TABLE CELLPADDING=3 CELLSPACING=0 BORDER=1 WIDTH="100%">
<TBODY>
<TR ALIGN="CENTER">
<TH COLSPAN=3><STRONG>Thread Links</STRONG></TH>
<TH COLSPAN=3><STRONG>Date Links</STRONG></TH>
</TR>
<TR ALIGN="CENTER">
<TD><A HREF="msg04153.html">Thread Prev</A>
</TD>
<TD><A HREF="msg04160.html">Thread Next</A>
</TD>
<TD><A HREF="thrd7.html#04155">Thread Index</A></Td>
<TD><A HREF="msg04156.html">Date Prev</A></TD>
<TD><A HREF="msg04154.html">Date Next</A>
</TD>
<TD><A HREF="mail8.html#04155">Date Index</A></TD>
</TR>
</TBODY>
</TABLE>
</CENTER>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: ONT RE: Ontology case study</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &lt;<A HREF="mailto:mail@ChrisPartridge.net">mail@ChrisPartridge.net</A>&gt;, Chris Partridge &lt;<A HREF="mailto:chris_partridge@csi.com">chris_partridge@csi.com</A>&gt;,       SUO Ontology &lt;<A HREF="mailto:ontology@ieee.org">ontology@ieee.org</A>&gt;</li>
<li><em>Subject</em>: Re: ONT RE: Ontology case study</li>
<li><em>From</em>: Bill Andersen &lt;<A HREF="mailto:andersen@ontologyworks.com">andersen@ontologyworks.com</A>&gt;</li>
<li><em>Date</em>: Thu, 30 May 2002 03:30:21 -0500</li>
<li><em>In-Reply-To</em>: &lt;<a href="msg04153.html">EBEMKBFIHNNPELLHDEKLKEMHCCAA.chris_partridge@csi.com</a>&gt;</li>
<li><em>Sender</em>: <A HREF="mailto:owner-ontology@majordomo.ieee.org">owner-ontology@majordomo.ieee.org</A></li>
<li><em>User-Agent</em>: Microsoft-Entourage/9.0.1.3108</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>

On 5/30/02 1:34, &quot;Chris Partridge&quot; &lt;chris_partridge@csi.com&gt; wrote:

&gt; CP&gt; Bill, I think I agree with all that you say, but I am not sure of its
&gt; relevance. I have seen an argument on this list many time that using FOL one
&gt; can deduce results that one cannot from a standard database. It has been
&gt; suggested that this is an unalloyed good. I am suggesting that things are
&gt; not so easy.

Well, first I don't know what a &quot;standard database&quot; is - probably you're
thinking of a relational database.  And I would agree that all that FOL
gives you is not necessarily good and desirable.

First, I have always been dubious of the utility of classical negation for
any practical purpose.  If I say:

  &quot;If X likes sports and doesn't like baseball, then X likes football&quot;

I generally don't have in mind the following inference:

  &quot;If X likes sports and doesn't like football, then X likes baseball&quot;

Or worse,

  &quot;If X likes neither baseball nor football, then X doesn't like sports&quot;

These may make sense for one-deep inferences, like &quot;I want to go to
Cleveland or Chicago and I can't go to Cleveland, so I'll go to Chicago&quot;,
but it starts to get weird when the classical negation is buried 10 or 12
ply deep in an inference.  This is one of the reasons that Cyc is so
terribly slow - if you ask for someone's age, it ends up trying to prove
that China isn't a soft drink or something silly like that in the process.

Second, some things you just can't define in FOL, like transitive closure or
inductive definitions in general.   One example of this is being unable to
prove that Mickey Mouse is not an integer from the Peano axioms, or being
able to prove that a given pair P(a,b) is not in the transitive closure of a
relation P.  You can do this with a fixpoint semantics, but you're not in
the classical FOL world anymore.
 
&gt; CP&gt;Operational systems do things. A banking system will issue instructions
&gt; to make payments and when it receives such a message it makes the payment.
&gt; It seems to me absolutely clear that this is true and that FOL by itself -
&gt; as ChrisM's example shows - cannot. I am just pointing out the difference.
&gt; CP&gt;How would an FOL theorem prover issue payment instructions - and would it
&gt; be doing more than just FOL?

I don't get it.  An FOL theorem prover could be hooked up to a banking
system in just the same way a database is.  The parties using the system
wouldn't even notice, except that their transactions would take a whole lot
longer! ;-D

&gt; This is just false, Chris.  Databases are simply machines that implement the
&gt; relational algebra, which, when recursion/iteration is added, is equivalent
&gt; in expressive power to FOL.  What you can do in one you can do in the other.

&gt;&gt; What is false? That in databases there is a distinction between entity
&gt;&gt; and attribute and this is based (however unconsciously) on the Aristotelian
&gt;&gt; distinction between substance and attribute.

That's not true.  A relational database is, at its core, an implementation
of relational algebra, perhaps with some extra goodies added like iteration.
If you take any commercial DBMS, and ask a SQL query, you can examine its
execution plan and see these operations that the DBMS executes.

Relational algebra doesn't know anything about substance or attribute - all
it &quot;knows&quot; about are relations and a set of operations (cartesian product,
selection, and projection) that can be performed on them.

Now it may be the case that a particular data modeling *language* may have
such a bias or intention built in.  I know that, while he didn't have
philosophy in mind, Chen had notions like object and attribute in mind when
he developed the entity-relationship model, the most common &quot;formalism&quot; for
building data models that are implemented by the data-definition facilities
of SQL.  At the same time, the original relational model of Codd that all
relational DBMS are based on (roughly - the original is more powerful than
any current implementation) had no such distinctions in mind.

  .bill

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="04160" href="msg04160.html">RE: ONT RE: Ontology case study</a></strong>
<ul><li><em>From:</em> &quot;Chris Partridge&quot; &lt;chris_partridge@csi.com&gt;</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="04153" href="msg04153.html">RE: ONT RE: Ontology case study</a></strong>
<ul><li><em>From:</em> &quot;Chris Partridge&quot; &lt;chris_partridge@csi.com&gt;</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg04156.html">RE: ONT RE: Ontology case study</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg04154.html">RE: ONT RE: Ontology case study</A></STRONG>
</LI>
<li>Prev by thread:
<strong><a href="msg04153.html">RE: ONT RE: Ontology case study</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg04160.html">RE: ONT RE: Ontology case study</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="mail8.html#04155"><strong>Date</strong></a></li>
<li><a href="thrd7.html#04155"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
