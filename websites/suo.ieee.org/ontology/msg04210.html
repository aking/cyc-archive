<!-- MHonArc v2.4.8 -->
<!--X-Subject: RE: ONT RE: Ontology case study -->
<!--X-From-R13: "Irfg, [nggurj D EWFW&#45;WFBEWS" <[nggurj.D.IrfgNWE.furyy.pbz> -->
<!--X-Date: Wed, 5 Jun 2002 05:14:13 &#45;0400 (EDT) -->
<!--X-Message-Id: DE057CA9F46ED2118C4900805F85E4270BCE0B2C@lonsc0s0038.sipc.shell.co.uk -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->

<!-- /groups/802/3/efm/public/email/msg04210.html -->
<!-- /groups/???? ?SUO?                              -->

<HTML>

<HEAD>
<TITLE>RE: ONT RE: Ontology case study</TITLE>
<LINK REV="made" HREF="mailto:Matthew.R.West@IS.shell.com">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->

<CENTER>

<TABLE CELLPADDING=3 CELLSPACING=0 BORDER=1 WIDTH="100%">
<TBODY>
<TR ALIGN="CENTER">
<TH COLSPAN=3><STRONG>Thread Links</STRONG></TH>
<TH COLSPAN=3><STRONG>Date Links</STRONG></TH>
</TR>
<TR ALIGN="CENTER">
<TD><A HREF="msg04192.html">Thread Prev</A>
</TD>
<TD><A HREF="msg04212.html">Thread Next</A>
</TD>
<TD><A HREF="thrd7.html#04210">Thread Index</A></Td>
<TD><A HREF="msg04211.html">Date Prev</A></TD>
<TD><A HREF="msg04209.html">Date Next</A>
</TD>
<TD><A HREF="mail6.html#04210">Date Index</A></TD>
</TR>
</TBODY>
</TABLE>
</CENTER>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>RE: ONT RE: Ontology case study</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Adam Pease &lt;<A HREF="mailto:apease@ks.teknowledge.com">apease@ks.teknowledge.com</A>&gt;, <A HREF="mailto:ontology@ieee.org">ontology@ieee.org</A></li>
<li><em>Subject</em>: RE: ONT RE: Ontology case study</li>
<li><em>From</em>: &quot;West, Matthew R SITI-ITPSIE&quot; &lt;<A HREF="mailto:Matthew.R.West@IS.shell.com">Matthew.R.West@IS.shell.com</A>&gt;</li>
<li><em>Date</em>: Wed, 5 Jun 2002 11:11:00 +0200 </li>
<li><em>Sender</em>: <A HREF="mailto:owner-ontology@majordomo.ieee.org">owner-ontology@majordomo.ieee.org</A></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>

Dear Adam,

Yes I agree we are getting close.

See some comments below.


Matthew West
Principal Consultant
Shell Information Technology International Limited
Shell Centre, London SE1 7NA, United Kingdom

Tel: +44 20 7934 4490 Other Tel: +44 7796 336538
Email: matthew.r.west@is.shell.com
Internet: <A  HREF="http://www.shell.com">http://www.shell.com</A>


&gt; -----Original Message-----
&gt; From: Adam Pease [<A  HREF="mailto:apease@ks.teknowledge.com">mailto:apease@ks.teknowledge.com</A>]
&gt; Sent: 31 May 2002 21:25
&gt; To: West, Matthew R SITI-ITPSIE; ontology@ieee.org
&gt; Subject: RE: ONT RE: Ontology case study
&gt; 
&gt; 
&gt; Matthew,
&gt;    Many thanks for working this through.  I feel like we're getting 
&gt; somewhere.  Although I'd be happy to continue point by point, 
&gt; I think maybe 
&gt; we can get to the heart of the matter in summary.
&gt;    I take your points below to be, broadly, that you have a 
&gt; sense that 
&gt; database normalization and cardinality constraints cover the 
&gt; most common 
&gt; cases of database error, and that in the rare cases that more 
&gt; checking is 
&gt; needed that stored procedures are sufficient.  It's always a 
&gt; challenge to 
&gt; restate someone else's views fairly, so let me know if that's right.

MW: Close but not quite. Entity relationship models deal with ontology
in as much as it can be implemented within a static database design, 
as opposed to processing data in a database.

&gt;    If that is a fair restatement, my rejoinder would be that 
&gt; if one is 
&gt; making an efficiency argument, that it has to be made 
&gt; relative to the size 
&gt; of the database, and the time constraints of the situation.  
&gt; If one is 
&gt; running a theorem prover on the client machine of say a 
&gt; medical records 
&gt; technician, and the tests involved are run only over a single 
&gt; record at 
&gt; time of entry, the efficiency argument is far less 
&gt; compelling, it seems to 
&gt; me.  One could argue that the dramatic hardware speed increases that 
&gt; continue mean that even if theorem proving is too slow now, 
&gt; that in a few 
&gt; years, it will be enough, and that it makes sense to begin 
&gt; define precise 
&gt; semantics and expressive constraints now.  One could argue, 
&gt; as I think Bill 
&gt; Andersen has recently, that techniques are being developed (at 
&gt; OntologyWorks at least) to implement expressive constraints 
&gt; in databases 
&gt; that do function very efficiently today.

MW: I broadly agree, but there are quite good tools to support
constraint checking on the data in the database, it is just
a different part of the problem, with different tools. I don't
think improving data quality is a killer app for ontologies.

&gt;    I'll address the specific request for &quot;how would I do 
&gt; this&quot; below, since 
&gt; after pleading with others to be concrete and specific, I'd 
&gt; better practice 
&gt; what I preach.
&gt; 
&gt; 
&gt; At 10:48 AM 5/31/2002 +0200, West, Matthew R SITI-ITPSIE wrote:
&gt; 
&gt; [snip]
&gt; 
&gt; 
&gt; &gt; &gt; &gt;MW: I don't think there is anything that can merge two databases
&gt; &gt; &gt; &gt;automatically without humans looking at it as part of 
&gt; the process.
&gt; &gt; &gt;
&gt; &gt; &gt; Nor do I.  What an ontology can do is provide a set of integrity
&gt; &gt; &gt; constraints that can be automatically processed to determine
&gt; &gt; &gt; in part if
&gt; &gt; &gt; that merger was specified correctly.
&gt; &gt;
&gt; &gt;MW: Please explain how you think that might work.
&gt; 
&gt; Imagine that a database technician reverses the fields that should be 
&gt; mapped from a client database into a common DB.  He flips 
&gt; birth date and 
&gt; hire date (for an employee database for a multinational 
&gt; corporation for 
&gt; example).  As each record is pulled into the common DB it's 
&gt; checked against 
&gt; the constraint
&gt; 
&gt; (=&gt;
&gt;    (and
&gt;      (instance ?X Employee)
&gt;      (birthTime ?X ?BTIME)
&gt;      (deathTime ?X ?DTIME))
&gt;    (greaterThan ?DTIME ?BTIME))

MW: Well that is fine of course (not wrong). However, in this case
either all are going to be right, or wrong. So my strategy would be
to eyeball the resultant data and do the same test, rather than code
and check the constraint. Just more efficient in this sort of case.
You still need to know that a birth date is before an employment date
(but I do don't I?).

MW: Don't get me wrong. I still think there is a killer app somewhere
in database meets ontology, but I know I don't want to get shot down
in flames suggesting something that can be done as well some existing
way.
&gt; 
&gt; 
&gt; 
&gt; 
&gt; [snip]
&gt; 
&gt; 
&gt; Adam Pease
&gt; Teknowledge
&gt; (650) 424-0500 x571
&gt; 

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="04212" href="msg04212.html">RE: ONT RE: Ontology case study</a></strong>
<ul><li><em>From:</em> Adam Pease &lt;apease@ks.teknowledge.com&gt;</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg04211.html">RE: ONT RE: Ontology case study</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg04209.html">ONT Virus Alert</A></STRONG>
</LI>
<li>Prev by thread:
<strong><a href="msg04192.html">RE: ONT RE: Ontology case study</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg04212.html">RE: ONT RE: Ontology case study</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="mail6.html#04210"><strong>Date</strong></a></li>
<li><a href="thrd7.html#04210"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
