<!-- MHonArc v2.4.8 -->
<!--X-Subject: RE: ONT RE: Ontology case study -->
<!--X-From-R13: Oqnz Brnfr <ncrnfrNxf.grxabjyrqtr.pbz> -->
<!--X-Date: Thu, 30 May 2002 16:09:41 &#45;0400 (EDT) -->
<!--X-Message-Id: 5.1.0.14.2.20020530115229.02c7a090@ks.teknowledge.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: DE057CA9F46ED2118C4900805F85E4270BCE07E6@lonsc0s0038.sipc.shell.co.uk -->
<!--X-Head-End-->

<!-- /groups/802/3/efm/public/email/msg04177.html -->
<!-- /groups/???? ?SUO?                              -->

<HTML>

<HEAD>
<TITLE>RE: ONT RE: Ontology case study</TITLE>
<LINK REV="made" HREF="mailto:apease@ks.teknowledge.com">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->

<CENTER>

<TABLE CELLPADDING=3 CELLSPACING=0 BORDER=1 WIDTH="100%">
<TBODY>
<TR ALIGN="CENTER">
<TH COLSPAN=3><STRONG>Thread Links</STRONG></TH>
<TH COLSPAN=3><STRONG>Date Links</STRONG></TH>
</TR>
<TR ALIGN="CENTER">
<TD><A HREF="msg04156.html">Thread Prev</A>
</TD>
<TD><A HREF="msg04158.html">Thread Next</A>
</TD>
<TD><A HREF="thrd7.html#04177">Thread Index</A></Td>
<TD><A HREF="msg04178.html">Date Prev</A></TD>
<TD><A HREF="msg04176.html">Date Next</A>
</TD>
<TD><A HREF="mail7.html#04177">Date Index</A></TD>
</TR>
</TBODY>
</TABLE>
</CENTER>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>RE: ONT RE: Ontology case study</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: &quot;West, Matthew R SITI-ITPSIE&quot; &lt;<A HREF="mailto:Matthew.R.West@IS.shell.com">Matthew.R.West@IS.shell.com</A>&gt;,       <A HREF="mailto:ontology@ieee.org">ontology@ieee.org</A></li>
<li><em>Subject</em>: RE: ONT RE: Ontology case study</li>
<li><em>From</em>: Adam Pease &lt;<A HREF="mailto:apease@ks.teknowledge.com">apease@ks.teknowledge.com</A>&gt;</li>
<li><em>Date</em>: Thu, 30 May 2002 13:10:09 -0700</li>
<li><em>In-Reply-To</em>: &lt;<a href="msg04156.html">DE057CA9F46ED2118C4900805F85E4270BCE07E6@lonsc0s0038.sipc.shell.co.uk</a>&gt;</li>
<li><em>Sender</em>: <A HREF="mailto:owner-ontology@majordomo.ieee.org">owner-ontology@majordomo.ieee.org</A></li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>

Matthew,

At 11:14 AM 5/30/2002 +0200, West, Matthew R SITI-ITPSIE wrote:
&gt;Dear Adam,
&gt;
&gt;See comments below.
&gt;
&gt;
&gt;Matthew West
&gt;Principal Consultant
&gt;Shell Information Technology International Limited
&gt;Shell Centre, London SE1 7NA, United Kingdom
&gt;
&gt;Tel: +44 20 7934 4490 Other Tel: +44 7796 336538
&gt;Email: matthew.r.west@is.shell.com
&gt;Internet: <A  HREF="http://www.shell.com">http://www.shell.com</A>
&gt;
&gt;
&gt; &gt; -----Original Message-----
&gt; &gt; From: Adam Pease [<A  HREF="mailto:apease@ks.teknowledge.com">mailto:apease@ks.teknowledge.com</A>]
&gt; &gt; Sent: 29 May 2002 15:38
&gt; &gt; To: West, Matthew R SITI-ITPSIE; ontology@ieee.org
&gt; &gt; Subject: RE: ONT RE: Ontology case study
&gt; &gt;
&gt; &gt;
&gt; &gt; Matthew,
&gt; &gt;
&gt; &gt; At 11:21 AM 5/29/2002 +0200, West, Matthew R SITI-ITPSIE wrote:
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; [snip]
&gt; &gt;
&gt; &gt; &gt; &gt; So why is using an ontology overkill again?
&gt; &gt; &gt;
&gt; &gt; &gt;MW: A data model is an ontology, just one with far fewer axioms, but
&gt; &gt; &gt;inclulding those that are useful in database design. So it
&gt; &gt; is a matter
&gt; &gt; &gt;of degree. A fully axiomatized ontology just includes a lot of stuff
&gt; &gt; &gt;that has no value for database design.
&gt; &gt;
&gt; &gt; If a data model is an ontology with fewer axioms then the
&gt; &gt; terms in the data
&gt; &gt; model are lacking explicit mention of some sufficient
&gt; &gt; conditions.  I could
&gt; &gt; see how on a particular ontology one might claim that
&gt; &gt; particular axioms are
&gt; &gt; unnecessary, but don't understand how you can make this general
&gt; &gt; claim.  Could you explain further?
&gt;
&gt;MW: In the case of database design it is about what axioms (constraints
&gt;in datbase speak) that can be implemented in the database. These are
&gt;relatively
&gt;limited, mostly cardinality related. So for example you can note that
&gt;the number of dates of birth a person has is exactly one, and stop people
&gt;trying to enter more than one.

Yes, but surely not all legitimate and useful constraints involve 
cardinality or other limited conditions that can be handled by database 
constraint languages.

&gt;Others can be implemented in code of some sort, but in pracice
&gt;they are not.

Is that a good thing?  It sounds to me like simply a limitation of the 
tools available, so even though a constraint is known and valid, it doesn't 
get implemented.  Are you claiming that this limitation is somehow an 
advantage?

&gt;On the other hand there are some data quality applications
&gt;that look at the data in the database, and can check against quite
&gt;sophisticated rules, and discover patterns in the data.
&gt; &gt;
&gt; &gt; [snip]
&gt; &gt;
&gt; &gt;
&gt; &gt; &gt; &gt; How about a database in which both John and Jon (should be
&gt; &gt; &gt; &gt; John) have the
&gt; &gt; &gt; &gt; same SSN, or hospital records where Mary who was born on
&gt; &gt; &gt; &gt; 5/2/65 is recorded
&gt; &gt; &gt; &gt; as giving birth to John on 8/7/68 (should be 8/7/86)?  This
&gt; &gt; &gt; &gt; sort of thing
&gt; &gt; &gt; &gt; is not at all rare in real world databases.
&gt; &gt; &gt;
&gt; &gt; &gt;MW: This sort of thing is sorted out by referential integrity, and
&gt; &gt; &gt;is the sort of constraint that is set up in data models. In this case
&gt; &gt; &gt;you would probably not get the opportunity to enter the
&gt; &gt; name, unless you
&gt; &gt; &gt;were the first person to enter the SSN and related details,
&gt; &gt; after that
&gt; &gt; &gt;these would be provided by reference only.
&gt; &gt;
&gt; &gt; There are two typos in the example.  How would referential
&gt; &gt; integrity catch
&gt; &gt; the date problem?
&gt;
&gt;MW: You would not enter the data twice. The data of birth is already
&gt;there. Of course you can have bad database designs that allow multiple
&gt;entry of the same data, but hten I am sure there are bad ontologies too.

The birth date is not entered twice in the example.  It's entered once for 
two different people.

&gt;MW: In this situation you would have a primary key, probably the SSN
&gt;number, and when you enter that, the other details would be returned
&gt;as a check that you had typed in the correct SSN. What you don't do
&gt;is allow people to just type data into foreign key fields. That is
&gt;asking for trouble. You always do a lookup, and insist that the object
&gt;referenced exists. That is referential integrity.

While it's true that the example had that issue, I'm currently addressing 
the second issue in the example which is that the birth date of the child 
has a typo which shows it as being earlier than the birth date of the 
mother.  That is a situation that an ontology can catch.  Could you address 
how you would see that being handled?

&gt; &gt;
&gt; &gt; [snip]
&gt; &gt;
&gt; &gt; &gt; &gt; It's just as easy to come up with an issue relevant to database
&gt; &gt; &gt; &gt; design.  Let's say that you're integrating databases that are
&gt; &gt; &gt; &gt; hospital
&gt; &gt; &gt; &gt; records from different countries.  The schema from one
&gt; &gt; Muslim country
&gt; &gt; &gt; &gt; allows multiple wives for a given husband and the schema for
&gt; &gt; &gt; &gt; the US DB
&gt; &gt; &gt; &gt; prohibits this.  With English comments, there's no way for an
&gt; &gt; &gt; &gt; automated
&gt; &gt; &gt; &gt; process to find the problem.
&gt; &gt; &gt;
&gt; &gt; &gt;MW: The database structure is likely to be quite different (assuming
&gt; &gt; &gt;only the current wife is recorded in the US database) and so
&gt; &gt; the constraint
&gt; &gt; &gt;quite obvious.
&gt; &gt;
&gt; &gt; Obvious to a human being, but not to a software program, that's the
&gt; &gt; point.  With a formal axiom, a theorem prover can catch the
&gt; &gt; problem.  With
&gt; &gt; an English comment, a human has to catch the problem.
&gt;
&gt;MW: I don't think there is anything that can merge two databases
&gt;automatically without humans looking at it as part of the process.

Nor do I.  What an ontology can do is provide a set of integrity 
constraints that can be automatically processed to determine in part if 
that merger was specified correctly.

&gt; &gt;
&gt; &gt; &gt;  I don't see what advantage the ontolgies would have. You
&gt; &gt; &gt;would ahve to manually map the concepts in the two
&gt; &gt; ontologies anyway, and
&gt; &gt; &gt;that is much harder than finding the differences in data
&gt; &gt; structure and
&gt; &gt; &gt;how/whether the constraints are enforced in the database.
&gt; &gt; &gt;
&gt; &gt; &gt;MW: In fact, if the US database is able to hold information
&gt; &gt; about previous
&gt; &gt; &gt;wives, it will probably be able to hold the data about the multiple
&gt; &gt; &gt;concurrent muslim wives, since it is unlikely that a
&gt; &gt; constraint restricting
&gt; &gt; &gt;a US citzen to one wife at a time would have been implemented.
&gt; &gt;
&gt; &gt; That's assuming a number of things that change the example,
&gt; &gt; including that
&gt; &gt; database designers do the right thing.  Mistakes happen, and
&gt; &gt; if all you
&gt; &gt; have are English (or some other human language) definitions,
&gt; &gt; no automated
&gt; &gt; process can check it.
&gt;
&gt;MW: Again I know of no way to  compare databases without human
&gt;intervention.

nor do I

&gt;If they each have an ontology, they will be just
&gt;as different as the two databases, so I don't see how that gets
&gt;you further.

If the database integrator makes an error and reverses the mapping of 
birthdate and deathdate from a client database to a central database, a 
human being has to catch the error.  If there's an ontology that has an 
axiom that you die after you're born, a theorem prover can catch the error.

&gt; &gt;
&gt; &gt; [snip]
&gt; &gt;
&gt; &gt;
&gt; &gt; &gt; &gt; &gt;MW: EXPRESS is a language that is computer processable, and
&gt; &gt; &gt; &gt; is processed
&gt; &gt; &gt; &gt; &gt;to provide a database. You do not automatically process
&gt; &gt; the KIF in
&gt; &gt; &gt; &gt; &gt;your ontology, to produce a database design, it is read by
&gt; &gt; &gt; &gt; humans, so you
&gt; &gt; &gt; &gt; &gt;should use something that they understand. It is the
&gt; &gt; information you
&gt; &gt; &gt; &gt; &gt;convey, rather than the information you contain that matters.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Let's distinguish between what is currently done with today's
&gt; &gt; &gt; &gt; tools, and
&gt; &gt; &gt; &gt; what this standardization effort is supposed to enable.  A
&gt; &gt; &gt; &gt; logic based
&gt; &gt; &gt; &gt; ontology enables computer processing, so the SUO ontology is
&gt; &gt; &gt; &gt; not intended
&gt; &gt; &gt; &gt; just for human eyes.  Also keep in mind that for human
&gt; &gt; eyes, we have
&gt; &gt; &gt; &gt; Michal's pseudo-English presentation and a graphical browser,
&gt; &gt; &gt; &gt; as well as
&gt; &gt; &gt; &gt; English comments.
&gt; &gt; &gt;
&gt; &gt; &gt;MW: Fine. But what is it for ...
&gt; &gt;
&gt; &gt; You made a comment above that the when the ontology is used
&gt; &gt; by humans, it
&gt; &gt; should be presented in a language they understand.  That's
&gt; &gt; the point I
&gt; &gt; answered.  We do present it in a human-readable form, as well
&gt; &gt; as in formal
&gt; &gt; logic.
&gt;
&gt;MW: Accepted.
&gt; &gt;
&gt; &gt; [snip]
&gt; &gt;
&gt; &gt;
&gt; &gt; &gt; &gt; &gt;MW: Well if I had an ontology, I certainly wouldn't ignore
&gt; &gt; &gt; &gt; it (as long
&gt; &gt; &gt; &gt; &gt;as I could make sense of it) but I would translate it into a
&gt; &gt; &gt; &gt; data model
&gt; &gt; &gt; &gt; &gt;as my first step if what I was doing was database design.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; ...and you're free to do that.  Knowing that many people are
&gt; &gt; &gt; &gt; put off by
&gt; &gt; &gt; &gt; logic, we've translated SUMO into Protege and DAML.  We'd
&gt; &gt; be happy to
&gt; &gt; &gt; &gt; implement other translators as our time allows.
&gt; &gt; &gt;
&gt; &gt; &gt;MW: That would be potentiallly useful, although one thing I
&gt; &gt; have seen is
&gt; &gt; &gt;that the best way to say something in one language, does nto
&gt; &gt; necessarily
&gt; &gt; &gt;translate automatically to another language in the best way
&gt; &gt; to say it there.
&gt; &gt; &gt; &gt;
&gt; &gt;
&gt; &gt; I agree.
&gt; &gt;
&gt; &gt; Adam
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; Adam Pease
&gt; &gt; Teknowledge
&gt; &gt; (650) 424-0500 x571
&gt; &gt;

Adam Pease
Teknowledge
(650) 424-0500 x571

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="04156" href="msg04156.html">RE: ONT RE: Ontology case study</a></strong>
<ul><li><em>From:</em> &quot;West, Matthew R SITI-ITPSIE&quot; &lt;Matthew.R.West@IS.shell.com&gt;</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg04178.html">Re: ONT RE: Ontology case study</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg04176.html">ONT Re: Data Models, Ontologies, Logic</A></STRONG>
</LI>
<li>Prev by thread:
<strong><a href="msg04156.html">RE: ONT RE: Ontology case study</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg04158.html">RE: ONT RE: Ontology case study</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="mail7.html#04177"><strong>Date</strong></a></li>
<li><a href="thrd7.html#04177"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
