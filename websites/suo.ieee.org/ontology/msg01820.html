<!-- MHonArc v2.4.8 -->
<!--X-Subject: RE: SUO: RE: Re: Peirce's MS 514 -->
<!--X-From-R13: Xbua.HryznaNVEQ.pbz -->
<!--X-Date: Fri, 23 Mar 2001 16:15:47 &#45;0500 (EST) -->
<!--X-Message-Id: OF364C6B59.166A6F3D&#45;ON88256A18.0071DA3D@hughes.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->

<!-- /groups/802/3/efm/public/email/msg01820.html -->
<!-- /groups/???? ?SUO?                              -->

<HTML>

<HEAD>
<TITLE>RE: SUO: RE: Re: Peirce's MS 514</TITLE>
<LINK REV="made" HREF="mailto:John.Velman@HSC.com">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->

<CENTER>

<TABLE CELLPADDING=3 CELLSPACING=0 BORDER=1 WIDTH="100%">
<TBODY>
<TR ALIGN="CENTER">
<TH COLSPAN=3><STRONG>Thread Links</STRONG></TH>
<TH COLSPAN=3><STRONG>Date Links</STRONG></TH>
</TR>
<TR ALIGN="CENTER">
<TD><A HREF="msg01813.html">Thread Prev</A>
</TD>
<TD><A HREF="msg01761.html">Thread Next</A>
</TD>
<TD><A HREF="thrd54.html#01820">Thread Index</A></Td>
<TD><A HREF="msg01821.html">Date Prev</A></TD>
<TD><A HREF="msg01819.html">Date Next</A>
</TD>
<TD><A HREF="mail54.html#01820">Date Index</A></TD>
</TR>
</TBODY>
</TABLE>
</CENTER>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>RE: SUO: RE: Re: Peirce's MS 514</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: pat hayes &lt;<A HREF="mailto:phayes@ai.uwf.edu">phayes@ai.uwf.edu</A>&gt;</LI>
<LI><em>Subject</em>: RE: SUO: RE: Re: Peirce's MS 514</LI>
<LI><em>From</em>: <A HREF="mailto:John.Velman@HSC.com">John.Velman@HSC.com</A></LI>
<LI><em>Date</em>: Fri, 23 Mar 2001 12:48:32 -0800</LI>
<LI><em>Cc</em>: <A HREF="mailto:standard-upper-ontology@ieee.org">standard-upper-ontology@ieee.org</A></LI>
<LI><em>Reply-To</em>: <A HREF="mailto:John.Velman@HSC.com">John.Velman@HSC.com</A></LI>
<LI><em>Sender</em>: <A HREF="mailto:owner-standard-upper-ontology@ieee.org">owner-standard-upper-ontology@ieee.org</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>


Pat,

Thanks for the reference and comments on general logic and functional
programming.

With regard to the Lifschitz reference:  This was based on recollection of
some things I was looking into about a year and a half ago, and it appears
that Jon was right about old memories being like old strawberries-- getting
fuzzy.

Anyhow, here is an accurate version, as far as it goes:

The only paper I was able to find in my "files" that refers to program
rules as rules of inference is

  M. Gelfond and V. Lifschitz, "Classical negation in logic programs and
  disjunctive databases," New Generation Computing, 1991, pp. 365-385.

which is available in postscript format at

   <A  HREF="http://www.cs.utexas.edu/users/vl/papers-old.html">http://www.cs.utexas.edu/users/vl/papers-old.html</A>

This concerns extended logic programs which introduce "classical
negation"  (I think these are scare quotes) in addition to negation as
failure.

The tie to my comment about inference rules is in a statement:

"Thus our semantics is not 'contrapositive' with respect to &lt;-- and ~;  it
assigns different meanings to the rules P &lt;-- ~Q and Q &lt;-- ~P.  The reason
is that it interprets expressions like these as _inference_rules_, rather
than as conditionals.  ... The language of extended programs includes
classical negation, but not classical implication."  (Here ~ is the
"classical negation" operator.)

I believe there was more discussion of this somewhere in papers of either
Lifschitz or Gelfond, but I can't find it!  It also appears that, contrary
to what I said in my previous message, I was the one interested in
paraconsistent logic, not Gelfond and Lifschitz.  They were explicitly
_not_ interested in paraconsistent logic, since they fix things up so that
contradiction results in all literals being true, and note:

  "This shows that our approach to negation is different from the
  'paraconsistent' approach of [Blair and Subrahmanian 1989]."

With this much to jog my memory, I'll add a couple of things.

As I recall I didn't like this particular semantics very much, but did like
the concept of extended logic programs.  (I was interested in a situation
where I could see a use for both negation as failure and statements
declared to be untrue (in some sense).)   I don't have a good trace of the
path I followed, but this led me to logic with values in a bilattice
instead of in {true,false}.  A major reference for this is "Multivalued
Logics" by Matthew L. Ginsberg, available at
<A  HREF="ftp://ftp.cirl.uoregon.edu/pub/users/ginsberg/papers/">ftp://ftp.cirl.uoregon.edu/pub/users/ginsberg/papers/</A> as mvl.ps.gz.

This allows an approach to paraconsistent logic that has a nice structure
to it, and provides a basis for better understanding of the issues of
implication and several different versions of negation.

The bilattice approach was tied back into extended logic programming and
paraconsistency by, among others, Avron and Arieli.  For example,

"A Model-Theoretic Approach to Recover Consistent Data from Inconsistent
Knowledge-Bases," available at  <A  HREF="http://www.math.tau.ac.il/~aa/papers.html">http://www.math.tau.ac.il/~aa/papers.html</A>

This has become off topic, although some of it may be relevant to
rationalizing different ontologies. :-)

Just one more thing, since I've come this far:

A somewhat different approach to extended logic programming is (NB:
IIRC)  in the work of Alferes, Pereira, Damasio.  Apparently based in part
on this work, recent versions of XSB (a research oriented extension of
Prolog, <A  HREF="http://www.cs.sunysb.edu/~sbprolog/xsb-page.html">http://www.cs.sunysb.edu/~sbprolog/xsb-page.html</A>) come with an
interpreter for which it is said "We note in passing that WFSX programs can
be paraconsistent." (Users manual, vol2, 1.1.12, Extended Logic Programs)

John V.

&gt;
&gt;
&gt;&gt;The contributions of John S, Pat Hayes, Chris Menzel and
&gt;&gt;others to this thread have helped clarify a lot of
&gt;&gt;things that I thought I already understood.  A short
&gt;&gt;footnote to Pat's note--
&gt;&gt;
&gt;&gt;It is also amazing that there is such a large variety
&gt;&gt;of useful (not necessarily complete) inference systems,
&gt;&gt;involving various combinations of axioms,
&gt;&gt;axiom schemata, and rules of inference. If
&gt;&gt;one has only axioms, and no rules of inference, the theory
&gt;&gt;is only the axioms (using theory to mean the body of
&gt;&gt;statements that can be inferred, not the totality of
&gt;&gt;what is entailed.)   In logic programming, the rules in a
&gt;&gt;program are usually regarded as axioms (insofar as we're
&gt;&gt;speaking of rules with only logical intent).  In extending
&gt;&gt;prolog to a certain version of paraconsistent logic
&gt;&gt;Vladimir Lifschitz proposes instead to regard the
&gt;&gt;rules as rules of inference.  This provides a completely
&gt;&gt;new perspective on the 'meaning' of the logic programs
&gt;&gt;in question.
&gt;
&gt;Thanks for that note. Do you have a pointer to this work by Lifschitz?
&gt;
&gt;There is a tradition called 'general logic' of rendering rules (of
&gt;inference) as assertions in another logic with a simpler or more
&gt;uniform system of rules. This has a lot in common with implementing
&gt;one virtual machine in another one, and many ties with computability
&gt;theory. In particular, there is a kind of uniform technique for
&gt;mapping many systems of rules into a 'universal logic' of functional
&gt;type theory - essentially, the lambda calculus with a sorted
&gt;functional syntax. The expressions of the orginal language map into
&gt;types, and the inference rules map into functions. Applying a rule
&gt;maps into a function call, where the type-matching of a function to
&gt;its arguments encodes the particular syntactic structures of the
&gt;original language. One can then think of this functional language as
&gt;a general-purpose meta-calculus for building *proofs* in the original
&gt;language; in other words, derivations map into terms. This makes
&gt;sense if you think of an inference rule as an operation on
&gt;derivations which 'outputs' a larger derivation when given smaller
&gt;ones as 'input', and you think of an expression as simply being a
&gt;kind of runty derivation (of itself from itself). See
&gt;<A  HREF="http://www.dcs.ed.ac.uk/home/cdw/archive.html">http://www.dcs.ed.ac.uk/home/cdw/archive.html</A>
&gt;and follow the links there for more information than one human brain can
&gt;hold.
&gt;
&gt;Pat Hayes

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg01821.html">SUO: Re: Reductions Among Relations</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg01819.html">SUO: Re: 'q'</A></STRONG>
</LI>
<li>Prev by thread:
<strong><a href="msg01813.html">RE: SUO: RE: Re: Peirce's MS 514</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg01761.html">SUO: RE: Re: Detached Ideas On Virally Important Topics</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="mail54.html#01820"><strong>Date</strong></a></li>
<li><a href="thrd54.html#01820"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
