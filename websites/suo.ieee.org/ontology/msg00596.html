<!-- MHonArc v2.4.8 -->
<!--X-Subject: SUO: Differential Analytic Turing Automata (DATA) -->
<!--X-From-R13: Xba Ojoerl <wnjoerlNbnxynaq.rqh> -->
<!--X-Date: Wed, 31 Jan 2001 02:41:17 &#45;0500 (EST) -->
<!--X-Message-Id: 3A779889.474ABA92@oakland.edu -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 3A6A1259.85DAB4CF@oakland.edu -->
<!--X-Head-End-->

<!-- /groups/802/3/efm/public/email/msg00596.html -->
<!-- /groups/???? ?SUO?                              -->

<HTML>

<HEAD>
<TITLE>SUO: Differential Analytic Turing Automata (DATA)</TITLE>
<LINK REV="made" HREF="mailto:jawbrey@oakland.edu">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->

<CENTER>

<TABLE CELLPADDING=3 CELLSPACING=0 BORDER=1 WIDTH="100%">
<TBODY>
<TR ALIGN="CENTER">
<TH COLSPAN=3><STRONG>Thread Links</STRONG></TH>
<TH COLSPAN=3><STRONG>Date Links</STRONG></TH>
</TR>
<TR ALIGN="CENTER">
<TD><A HREF="msg00621.html">Thread Prev</A>
</TD>
<TD><A HREF="msg00618.html">Thread Next</A>
</TD>
<TD><A HREF="thrd74.html#00596">Thread Index</A></Td>
<TD><A HREF="msg00597.html">Date Prev</A></TD>
<TD><A HREF="msg00595.html">Date Next</A>
</TD>
<TD><A HREF="mail79.html#00596">Date Index</A></TD>
</TR>
</TBODY>
</TABLE>
</CENTER>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>SUO: Differential Analytic Turing Automata (DATA)</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: Stand Up Ontology &lt;<A HREF="mailto:standard-upper-ontology@ieee.org">standard-upper-ontology@ieee.org</A>&gt;</LI>
<LI><em>Subject</em>: SUO: Differential Analytic Turing Automata (DATA)</LI>
<LI><em>From</em>: Jon Awbrey &lt;<A HREF="mailto:jawbrey@oakland.edu">jawbrey@oakland.edu</A>&gt;</LI>
<LI><em>Date</em>: Tue, 30 Jan 2001 23:46:01 -0500</LI>
<LI><em>References</em>: &lt;3A6A1259.85DAB4CF@oakland.edu&gt;</LI>
<LI><em>Reply-To</em>: Jon Awbrey &lt;<A HREF="mailto:jawbrey@oakland.edu">jawbrey@oakland.edu</A>&gt;</LI>
<LI><em>Sender</em>: <A HREF="mailto:owner-standard-upper-ontology@ieee.org">owner-standard-upper-ontology@ieee.org</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>

¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤

SUO SIG:

ResCued From The "Semantic Web -- RDF Logic" Forum:

¤~~~~~~~~~¤~~~~~~~~~¤~FORWARD~¤~~~~~~~~~¤~~~~~~~~~¤

Differential Analytic Turing Automata (DATA)

From:  Jon Awbrey (jawbrey@oakland.edu)
Date:  Sat, Jan 20 2001

Message-ID:  &lt;3A6A1259.85DAB4CF@oakland.edu&gt;
      Date:  Sat, 20 Jan 2001 17:34:01 -0500
      From:  Jon Awbrey &lt;jawbrey@oakland.edu&gt;
        To:  Arisbe &lt;arisbe@stderr.org&gt;,
             Conceptual Graphs &lt;cg@cs.uah.edu&gt;,
             RDF Logic &lt;www-rdf-logic@w3.org&gt;,
             SemioCom &lt;semiocom@listbot.com&gt;
        CC:  Dietrich Fischer &lt;fischer@DARMSTADT.GMD.DE&gt;,
             Mary Keeler &lt;mkeeler@u.washington.edu&gt;,
             Jack Park &lt;jackpark@VERTICALNET.COM&gt;,
             John F Sowa &lt;sowa@bestweb.net&gt;
   Subject:  Differential Analytic Turing Automata (DATA)

¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤

The Shroud Of Turing

¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤

This swatch is really just a work in progress,
and I invite you to share in shaping it with me,
as I really do not know what the upshot or even
what the medium will be, or what will be needed
to rend of it an eventual and a genuine reality.

In lieu of a proper beginning, then, let me just gather
together my partial arrays and my random samples of data,
if you wish, with me, to call it that, that I have spent
my off-times collecting for lo! so many even-odder years.

I must apologize in advance for the many bits of redundancy --
though redundancy is the essence of information, is it not? --
that I am about to inflict on you in one moment, two, three --
but it will further the aim of future reference to have all
of this skein in a close-knit neighborhood of our surrogate
backcloth for the excessive surplices of originfinite sites.

¤~~~~~~~~~¤~~~~~~~~~¤~ILLUSTRATION~¤~~~~~~~~~¤~~~~~~~~~¤

So let me make my further ado with this deferential but deturing excuse,
that I merely want to demonstrate that my RefLog rendering of a stilted,
stunted turing machine can compute a bit more than the parity of single,
trivial, unprecedented, null-valued evanishment of the lone number zero.

So here, for ease of reference in future,
is a preamble to the formal constitution
of a particular variety of logical style
for transposing a TM into a proposition:

¤~~~~~~~~~¤~~~~~~~~~¤~EXEGESIS~¤~~~~~~~~~¤~~~~~~~~~¤

By way of providing a simple illustration of Cook's Theorem,
that "Propositional Satisfiability is NP-Complete", here is
an exposition of one way to translate Turing Machine set-ups
into propositional expressions, employing the RefLog Syntax
for Prop Calc that I described in a couple of earlier notes:

Notation:

Stilt&lt;k&gt; = Space and Time Limited Turing Machine,
           with k units of space and k units of time.

Stunt&lt;k&gt; = Space and Time Limited Turing Machine,
           for computing the parity of a bit string,
           with Number of Tape cells of input equal to k.

I will follow the pattern of the discussion in the book of
Herbert Wilf, 'Algorithms &amp; Complexity' (1986), pages 188-201,
but translate into RefLog, which is more efficient with respect
to the number of propositional clauses that are required.

Parity Machine:

-------------------------------------------------------
| State | Symbol | Next Symbol | Ratchet | Next State |
|   Q   |   S    |     S'      |   dR    |     Q'     |
-------------------------------------------------------
|   0   |   0    |     0       |   +1    |     0      |
|   0   |   1    |     1       |   +1    |     1      |
|   0   |   #    |     #       |   -1    |     #      |
|   1   |   0    |     0       |   +1    |     1      |
|   1   |   1    |     1       |   +1    |     0      |
|   1   |   #    |     #       |   -1    |     *      |
-------------------------------------------------------

                 1/1/+1
                -------&gt;
            /\ /        \ /\
   0/0/+1  ^  0          1  ^  0/0/+1
            \/|\        /|\/
              | &lt;------- |
      #/#/-1  |  1/1/+1  |  #/#/-1
              |          |
              v          v
              #          *

The TM has a "finite automaton" (FA) as its component.
Let us refer to this particular FA by the name of "M".

The "tape-head" (that is, the "read-unit") will be called "H".
The "registers" are also called "tape-cells" or "tape-squares".

In order to consider how the finitely "stilted" rendition of this TM
can be translated into the form of a purely propositional description,
one now fixes k and limits the discussion to talking about a Stilt&lt;k&gt;,
which is really not a true TM anymore but a finite automaton in disguise.

In this example, for the sake of a minimal illustration, we choose k = 2,
and discuss Stunt&lt;2&gt;.  Since the zeroth tape cell and the last tape cell
are occupied with bof and eof marks "#", this amounts to only one digit
of significant computation.

To translate Stunt&lt;2&gt; into propositional form we use
the following collection of propositional variables:

For the "Present State Function" QF : P -&gt; Q,

{ p0_q#, p0_q*, p0_q0, p0_q1,
| p1_q#, p1_q*, p1_q0, p1_q1,
| p2_q#, p2_q*, p2_q0, p2_q1,
| p3_q#, p3_q*, p3_q0, p3_q1
}

The propositional expression of the form "pi_qj" says:

| At the point-in-time p&lt;i&gt;,
| the finite machine M is in the state q&lt;j&gt;.

For the "Present Register Function" RF : P -&gt; R,

{ p0_r0, p0_r1, p0_r2, p0_r3,
| p1_r0, p1_r1, p1_r2, p1_r3,
| p2_r0, p2_r1, p2_r2, p2_r3,
| p3_r0, p3_r1, p3_r2, p3_r3
}

The propositional expression of the form "pi_rj" says:

| At the point-in-time p&lt;i&gt;,
| the tape-head H is on the tape-cell r&lt;j&gt;.

For the "Present Symbol Function" SF : P -&gt; (R -&gt; S),

{ p0_r0_s#, p0_r0_s*, p0_r0_s0, p0_r0_s1,
| p0_r1_s#, p0_r1_s*, p0_r1_s0, p0_r1_s1,
| p0_r2_s#, p0_r2_s*, p0_r2_s0, p0_r2_s1,
| p0_r3_s#, p0_r3_s*, p0_r3_s0, p0_r3_s1,
| p1_r0_s#, p1_r0_s*, p1_r0_s0, p1_r0_s1,
| p1_r1_s#, p1_r1_s*, p1_r1_s0, p1_r1_s1,
| p1_r2_s#, p1_r2_s*, p1_r2_s0, p1_r2_s1,
| p1_r3_s#, p1_r3_s*, p1_r3_s0, p1_r3_s1,
| p2_r0_s#, p2_r0_s*, p2_r0_s0, p2_r0_s1,
| p2_r1_s#, p2_r1_s*, p2_r1_s0, p2_r1_s1,
| p2_r2_s#, p2_r2_s*, p2_r2_s0, p2_r2_s1,
| p2_r3_s#, p2_r3_s*, p2_r3_s0, p2_r3_s1,
| p3_r0_s#, p3_r0_s*, p3_r0_s0, p3_r0_s1,
| p3_r1_s#, p3_r1_s*, p3_r1_s0, p3_r1_s1,
| p3_r2_s#, p3_r2_s*, p3_r2_s0, p3_r2_s1,
| p3_r3_s#, p3_r3_s*, p3_r3_s0, p3_r3_s1
}

The propositional expression of the form "pi_rj_sk" says:

| At the point-in-time p&lt;i&gt;,
| the tape-cell r&lt;j&gt; bears the mark s&lt;k&gt;.

¤~~~~~~~~~¤~~~~~~~~~¤~SISEGEXE~¤~~~~~~~~~¤~~~~~~~~~¤

So with all due further ado,
here are the Initial Conditions
for the two possible inputs to the
RefLog redaction of this Parity TM:

¤~~~~~~~~~¤~~~~~~~~~¤~INPUT~0~¤~~~~~~~~~¤~~~~~~~~~¤

Initial Conditions:

p0_q0

p0_r1

p0_r0_s#
p0_r1_s0
p0_r2_s#

The Initial Conditions are given by a logical conjunction
that is composed of 5 basic expressions, altogether stating:

| At the point-in-time p&lt;0&gt;, M is in the state q&lt;0&gt;, and
| At the point-in-time p&lt;0&gt;, H is on the cell  r&lt;1&gt;, and
| At the point-in-time p&lt;0&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;0&gt;, cell r&lt;1&gt; bears the mark "0", and
| At the point-in-time p&lt;0&gt;, cell r&lt;2&gt; bears the mark "#".

¤~~~~~~~~~¤~~~~~~~~~¤~0~TUPNI~¤~~~~~~~~~¤~~~~~~~~~¤

¤~~~~~~~~~¤~~~~~~~~~¤~INPUT~1~¤~~~~~~~~~¤~~~~~~~~~¤

Initial Conditions:

p0_q0

p0_r1

p0_r0_s#
p0_r1_s1
p0_r2_s#

The Initial Conditions are given by a logical conjunction
that is composed of 5 basic expressions, altogether stating:

| At the point-in-time p&lt;0&gt;, M is in the state q&lt;0&gt;, and
| At the point-in-time p&lt;0&gt;, H is on the cell  r&lt;1&gt;, and
| At the point-in-time p&lt;0&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;0&gt;, cell r&lt;1&gt; bears the mark "1", and
| At the point-in-time p&lt;0&gt;, cell r&lt;2&gt; bears the mark "#".

¤~~~~~~~~~¤~~~~~~~~~¤~1~TUPNI~¤~~~~~~~~~¤~~~~~~~~~¤

And here, yet again, just to store it nearby,
is the logical rendition of the TM's program:

¤~~~~~~~~~¤~~~~~~~~~¤~PROGRAM~¤~~~~~~~~~¤~~~~~~~~~¤

Mediate Conditions:

( p0_q#  ( p1_q# ))
( p0_q*  ( p1_q* ))

( p1_q#  ( p2_q# ))
( p1_q*  ( p2_q* ))

Terminal Conditions:

(( p2_q# )( p2_q* ))

State Partition:

(( p0_q0 ),( p0_q1 ),( p0_q# ),( p0_q* ))
(( p1_q0 ),( p1_q1 ),( p1_q# ),( p1_q* ))
(( p2_q0 ),( p2_q1 ),( p2_q# ),( p2_q* ))

Register Partition:

(( p0_r0 ),( p0_r1 ),( p0_r2 ))
(( p1_r0 ),( p1_r1 ),( p1_r2 ))
(( p2_r0 ),( p2_r1 ),( p2_r2 ))

Symbol Partition:

(( p0_r0_s0 ),( p0_r0_s1 ),( p0_r0_s# ))
(( p0_r1_s0 ),( p0_r1_s1 ),( p0_r1_s# ))
(( p0_r2_s0 ),( p0_r2_s1 ),( p0_r2_s# ))

(( p1_r0_s0 ),( p1_r0_s1 ),( p1_r0_s# ))
(( p1_r1_s0 ),( p1_r1_s1 ),( p1_r1_s# ))
(( p1_r2_s0 ),( p1_r2_s1 ),( p1_r2_s# ))

(( p2_r0_s0 ),( p2_r0_s1 ),( p2_r0_s# ))
(( p2_r1_s0 ),( p2_r1_s1 ),( p2_r1_s# ))
(( p2_r2_s0 ),( p2_r2_s1 ),( p2_r2_s# ))

Interaction Conditions:

(( p0_r0 ) p0_r0_s0 ( p1_r0_s0 ))
(( p0_r0 ) p0_r0_s1 ( p1_r0_s1 ))
(( p0_r0 ) p0_r0_s# ( p1_r0_s# ))

(( p0_r1 ) p0_r1_s0 ( p1_r1_s0 ))
(( p0_r1 ) p0_r1_s1 ( p1_r1_s1 ))
(( p0_r1 ) p0_r1_s# ( p1_r1_s# ))

(( p0_r2 ) p0_r2_s0 ( p1_r2_s0 ))
(( p0_r2 ) p0_r2_s1 ( p1_r2_s1 ))
(( p0_r2 ) p0_r2_s# ( p1_r2_s# ))

(( p1_r0 ) p1_r0_s0 ( p2_r0_s0 ))
(( p1_r0 ) p1_r0_s1 ( p2_r0_s1 ))
(( p1_r0 ) p1_r0_s# ( p2_r0_s# ))

(( p1_r1 ) p1_r1_s0 ( p2_r1_s0 ))
(( p1_r1 ) p1_r1_s1 ( p2_r1_s1 ))
(( p1_r1 ) p1_r1_s# ( p2_r1_s# ))

(( p1_r2 ) p1_r2_s0 ( p2_r2_s0 ))
(( p1_r2 ) p1_r2_s1 ( p2_r2_s1 ))
(( p1_r2 ) p1_r2_s# ( p2_r2_s# ))

Transition Relations:

( p0_q0  p0_r1  p0_r1_s0  ( p1_q0  p1_r2  p1_r1_s0 ))
( p0_q0  p0_r1  p0_r1_s1  ( p1_q1  p1_r2  p1_r1_s1 ))
( p0_q0  p0_r1  p0_r1_s#  ( p1_q#  p1_r0  p1_r1_s# ))
( p0_q0  p0_r2  p0_r2_s#  ( p1_q#  p1_r1  p1_r2_s# ))

( p0_q1  p0_r1  p0_r1_s0  ( p1_q1  p1_r2  p1_r1_s0 ))
( p0_q1  p0_r1  p0_r1_s1  ( p1_q0  p1_r2  p1_r1_s1 ))
( p0_q1  p0_r1  p0_r1_s#  ( p1_q*  p1_r0  p1_r1_s# ))
( p0_q1  p0_r2  p0_r2_s#  ( p1_q*  p1_r1  p1_r2_s# ))

( p1_q0  p1_r1  p1_r1_s0  ( p2_q0  p2_r2  p2_r1_s0 ))
( p1_q0  p1_r1  p1_r1_s1  ( p2_q1  p2_r2  p2_r1_s1 ))
( p1_q0  p1_r1  p1_r1_s#  ( p2_q#  p2_r0  p2_r1_s# ))
( p1_q0  p1_r2  p1_r2_s#  ( p2_q#  p2_r1  p2_r2_s# ))

( p1_q1  p1_r1  p1_r1_s0  ( p2_q1  p2_r2  p2_r1_s0 ))
( p1_q1  p1_r1  p1_r1_s1  ( p2_q0  p2_r2  p2_r1_s1 ))
( p1_q1  p1_r1  p1_r1_s#  ( p2_q*  p2_r0  p2_r1_s# ))
( p1_q1  p1_r2  p1_r2_s#  ( p2_q*  p2_r1  p2_r2_s# ))

¤~~~~~~~~~¤~~~~~~~~~¤~MARGORP~¤~~~~~~~~~¤~~~~~~~~~¤

¤~~~~~~~~~¤~~~~~~~~~¤~INTERPRETATION~¤~~~~~~~~~¤~~~~~~~~~¤

Interpretation of the Propositional Program:

Mediate Conditions:

( p0_q#  ( p1_q# ))
( p0_q*  ( p1_q* ))

( p1_q#  ( p2_q# ))
( p1_q*  ( p2_q* ))

In RefLog, an expression of the form "( X ( Y ))"
expresses an implication or an if-then proposition:
"Not X without Y",  "If X then Y",  "X =&gt; Y",  etc.

A text string expression of the form "( X ( Y ))"
parses to a graphical data-structure of the form:

    X   Y
    o---o
    |
    @

All together, these Mediate Conditions state:

| If at p&lt;0&gt; M is in state q&lt;#&gt;, then at p&lt;1&gt; M is in state q&lt;#&gt;, and
| If at p&lt;0&gt; M is in state q&lt;*&gt;, then at p&lt;1&gt; M is in state q&lt;*&gt;, and
| If at p&lt;1&gt; M is in state q&lt;#&gt;, then at p&lt;2&gt; M is in state q&lt;#&gt;, and
| If at p&lt;1&gt; M is in state q&lt;*&gt;, then at p&lt;2&gt; M is in state q&lt;*&gt;.

Terminal Conditions:

(( p2_q# )( p2_q* ))

In RefLog, an expression of the form "(( X )( Y ))"
expresses a disjunction "X or Y", and it parses to:

    X   Y
    o   o
     \ /
      o
      |
      @

In effect, the Terminal Conditions state:

| At p&lt;2&gt; M is in state q&lt;#&gt;, or
| At p&lt;2&gt; M is in state q&lt;*&gt;.

State Partition:

(( p0_q0 ),( p0_q1 ),( p0_q# ),( p0_q* ))
(( p1_q0 ),( p1_q1 ),( p1_q# ),( p1_q* ))
(( p2_q0 ),( p2_q1 ),( p2_q# ),( p2_q* ))

In RefLog, an expression of the form "(( X&lt;1&gt; ),( X&lt;2&gt; ),( ... ),( X&lt;k&gt; ))"
states it as a fact that "exactly one of the X&lt;j&gt; are true, for j = 1 to k".
Expressions of this form are called "universal partition" expressions, and
they parse into a type of graph called a "painted and rooted cactus" (PARC):

    X&lt;1&gt;  X&lt;2&gt;  ...   X&lt;k&gt;
     o     o           o
     |     |           |
     o-----o--- ... ---o
      \               /
       \             /
        \           /
         \         /
          \       /
           \     /
            \   /
             \ /
              @

The State Partition expresses the conditions that:

| At each of the points-in-time p&lt;i&gt;, for i = 0 to 2,
| M can be in exactly one state q&lt;j&gt;, for j in the set {0, 1, #, *}.

Register Partition:

(( p0_r0 ),( p0_r1 ),( p0_r2 ))
(( p1_r0 ),( p1_r1 ),( p1_r2 ))
(( p2_r0 ),( p2_r1 ),( p2_r2 ))

The Register Partition expresses the conditions that:

| At each of the points-in-time p&lt;i&gt;, for i = 0 to 2,
| H can be on exactly one cell  r&lt;j&gt;, for j = 0 to 2.

Symbol Partition:

(( p0_r0_s0 ),( p0_r0_s1 ),( p0_r0_s# ))
(( p0_r1_s0 ),( p0_r1_s1 ),( p0_r1_s# ))
(( p0_r2_s0 ),( p0_r2_s1 ),( p0_r2_s# ))

(( p1_r0_s0 ),( p1_r0_s1 ),( p1_r0_s# ))
(( p1_r1_s0 ),( p1_r1_s1 ),( p1_r1_s# ))
(( p1_r2_s0 ),( p1_r2_s1 ),( p1_r2_s# ))

(( p2_r0_s0 ),( p2_r0_s1 ),( p2_r0_s# ))
(( p2_r1_s0 ),( p2_r1_s1 ),( p2_r1_s# ))
(( p2_r2_s0 ),( p2_r2_s1 ),( p2_r2_s# ))

The Symbol Partition expresses the conditions that:

| At each of the points-in-time p&lt;i&gt;, for i in {0, 1, 2},
| In each of the tape-registers r&lt;j&gt;, for j in {0, 1, 2}, 
| There can be exactly one sign s&lt;k&gt;, for k in {0, 1, #}.

Interaction Conditions:

(( p0_r0 ) p0_r0_s0 ( p1_r0_s0 ))
(( p0_r0 ) p0_r0_s1 ( p1_r0_s1 ))
(( p0_r0 ) p0_r0_s# ( p1_r0_s# ))

(( p0_r1 ) p0_r1_s0 ( p1_r1_s0 ))
(( p0_r1 ) p0_r1_s1 ( p1_r1_s1 ))
(( p0_r1 ) p0_r1_s# ( p1_r1_s# ))

(( p0_r2 ) p0_r2_s0 ( p1_r2_s0 ))
(( p0_r2 ) p0_r2_s1 ( p1_r2_s1 ))
(( p0_r2 ) p0_r2_s# ( p1_r2_s# ))

(( p1_r0 ) p1_r0_s0 ( p2_r0_s0 ))
(( p1_r0 ) p1_r0_s1 ( p2_r0_s1 ))
(( p1_r0 ) p1_r0_s# ( p2_r0_s# ))

(( p1_r1 ) p1_r1_s0 ( p2_r1_s0 ))
(( p1_r1 ) p1_r1_s1 ( p2_r1_s1 ))
(( p1_r1 ) p1_r1_s# ( p2_r1_s# ))

(( p1_r2 ) p1_r2_s0 ( p2_r2_s0 ))
(( p1_r2 ) p1_r2_s1 ( p2_r2_s1 ))
(( p1_r2 ) p1_r2_s# ( p2_r2_s# ))

In briefest terms, the Interaction Conditions merely express
the circumstance that the sign in a tape-cell cannot change
between two points-in-time unless the tape-head is over the
cell in question at the initial one of those points-in-time.
All that we have to do is to see how they manage to say this.

In RefLog, an expression of the following form:

"(( p&lt;i&gt;_r&lt;j&gt; ) p&lt;i&gt;_r&lt;j&gt;_s&lt;k&gt; ( p&lt;i+1&gt;_r&lt;j&gt;_s&lt;k&gt; ))",

and which parses as the graph:

       p&lt;i&gt;_r&lt;j&gt; o   o  p&lt;i+1&gt;_r&lt;j&gt;_s&lt;k&gt;
                  \ /
    p&lt;i&gt;_r&lt;j&gt;_s&lt;k&gt; o
                   |
                   @

can be read in the form of the following implication:

| If
| At the point-in-time p&lt;i&gt;, the tape-cell r&lt;j&gt; bears the mark s&lt;k&gt;,
| But it is not the case that
| At the point-in-time p&lt;i&gt;, the tape-head is on the tape-cell r&lt;j&gt;.
| Then
| At the point-in-time p&lt;i+1&gt;, the tape-cell r&lt;j&gt; bears the mark s&lt;k&gt;.

Folks among us of a certain age and a peculiar manner of acculturation will
recognize these as the "Frame Conditions" for the change of state of the TM.

Transition Relations:

( p0_q0  p0_r1  p0_r1_s0  ( p1_q0  p1_r2  p1_r1_s0 ))
( p0_q0  p0_r1  p0_r1_s1  ( p1_q1  p1_r2  p1_r1_s1 ))
( p0_q0  p0_r1  p0_r1_s#  ( p1_q#  p1_r0  p1_r1_s# ))
( p0_q0  p0_r2  p0_r2_s#  ( p1_q#  p1_r1  p1_r2_s# ))

( p0_q1  p0_r1  p0_r1_s0  ( p1_q1  p1_r2  p1_r1_s0 ))
( p0_q1  p0_r1  p0_r1_s1  ( p1_q0  p1_r2  p1_r1_s1 ))
( p0_q1  p0_r1  p0_r1_s#  ( p1_q*  p1_r0  p1_r1_s# ))
( p0_q1  p0_r2  p0_r2_s#  ( p1_q*  p1_r1  p1_r2_s# ))

( p1_q0  p1_r1  p1_r1_s0  ( p2_q0  p2_r2  p2_r1_s0 ))
( p1_q0  p1_r1  p1_r1_s1  ( p2_q1  p2_r2  p2_r1_s1 ))
( p1_q0  p1_r1  p1_r1_s#  ( p2_q#  p2_r0  p2_r1_s# ))
( p1_q0  p1_r2  p1_r2_s#  ( p2_q#  p2_r1  p2_r2_s# ))

( p1_q1  p1_r1  p1_r1_s0  ( p2_q1  p2_r2  p2_r1_s0 ))
( p1_q1  p1_r1  p1_r1_s1  ( p2_q0  p2_r2  p2_r1_s1 ))
( p1_q1  p1_r1  p1_r1_s#  ( p2_q*  p2_r0  p2_r1_s# ))
( p1_q1  p1_r2  p1_r2_s#  ( p2_q*  p2_r1  p2_r2_s# ))

The Transition Conditions merely serve to express,
by means of 16 complex implication expressions,
the data of the TM table that was given above.

¤~~~~~~~~~¤~~~~~~~~~¤~NOITATERPRETNI~¤~~~~~~~~~¤~~~~~~~~~¤

And here are the outputs of the computation,
as emulated by its propositional rendition,
and as actually generated within that form
of transmogrification by the program that
I wrote for finding all of the satisfying
interpretations (truth-value assignments)
of propositional expressions in RefLog:

¤~~~~~~~~~¤~~~~~~~~~¤~OUTPUT~0~¤~~~~~~~~~¤~~~~~~~~~¤

Output Conditions:

 p0_q0
  p0_r1
   p0_r0_s#
    p0_r1_s0
     p0_r2_s#
      p1_q0
       p1_r2
        p1_r2_s#
         p1_r0_s#
          p1_r1_s0
           p2_q#
            p2_r1
             p2_r0_s#
              p2_r1_s0
               p2_r2_s#

The Output Conditions amount to the sole satisfying interpretation,
that is, a "sequence of truth-value assignments" (SOTVA) that make
the entire proposition come out true, and they state the following:

| At the point-in-time p&lt;0&gt;, M is in the state q&lt;0&gt;,       and
| At the point-in-time p&lt;0&gt;, H is on the cell  r&lt;1&gt;,       and
| At the point-in-time p&lt;0&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;0&gt;, cell r&lt;1&gt; bears the mark "0", and
| At the point-in-time p&lt;0&gt;, cell r&lt;2&gt; bears the mark "#", and
|
| At the point-in-time p&lt;1&gt;, M is in the state q&lt;0&gt;,       and 
| At the point-in-time p&lt;1&gt;, H is on the cell  r&lt;2&gt;,       and
| At the point-in-time p&lt;1&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;1&gt;, cell r&lt;1&gt; bears the mark "0", and
| At the point-in-time p&lt;1&gt;, cell r&lt;2&gt; bears the mark "#", and
|
| At the point-in-time p&lt;2&gt;, M is in the state q&lt;#&gt;,       and 
| At the point-in-time p&lt;2&gt;, H is on the cell  r&lt;1&gt;,       and
| At the point-in-time p&lt;2&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;2&gt;, cell r&lt;1&gt; bears the mark "0", and
| At the point-in-time p&lt;2&gt;, cell r&lt;2&gt; bears the mark "#".

In brief, the output for our sake being the symbol that rests
under the tape-head H when the machine M gets to a rest state,
we are now amazed by the remarkable result that Parity(0) = 0.

¤~~~~~~~~~¤~~~~~~~~~¤~0~TUPTUO~¤~~~~~~~~~¤~~~~~~~~~¤

¤~~~~~~~~~¤~~~~~~~~~¤~OUTPUT~1~¤~~~~~~~~~¤~~~~~~~~~¤

Output Conditions:

 p0_q0
  p0_r1
   p0_r0_s#
    p0_r1_s1
     p0_r2_s#
      p1_q1
       p1_r2
        p1_r2_s#
         p1_r0_s#
          p1_r1_s1
           p2_q*
            p2_r1
             p2_r0_s#
              p2_r1_s1
               p2_r2_s#

The Output Conditions amount to the sole satisfying interpretation,
that is, a "sequence of truth-value assignments" (SOTVA) that make
the entire proposition come out true, and they state the following:

| At the point-in-time p&lt;0&gt;, M is in the state q&lt;0&gt;,       and
| At the point-in-time p&lt;0&gt;, H is on the cell  r&lt;1&gt;,       and
| At the point-in-time p&lt;0&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;0&gt;, cell r&lt;1&gt; bears the mark "1", and
| At the point-in-time p&lt;0&gt;, cell r&lt;2&gt; bears the mark "#", and
|
| At the point-in-time p&lt;1&gt;, M is in the state q&lt;1&gt;,       and 
| At the point-in-time p&lt;1&gt;, H is on the cell  r&lt;2&gt;,       and
| At the point-in-time p&lt;1&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;1&gt;, cell r&lt;1&gt; bears the mark "1", and
| At the point-in-time p&lt;1&gt;, cell r&lt;2&gt; bears the mark "#", and
|
| At the point-in-time p&lt;2&gt;, M is in the state q&lt;*&gt;,       and 
| At the point-in-time p&lt;2&gt;, H is on the cell  r&lt;1&gt;,       and
| At the point-in-time p&lt;2&gt;, cell r&lt;0&gt; bears the mark "#", and
| At the point-in-time p&lt;2&gt;, cell r&lt;1&gt; bears the mark "1", and
| At the point-in-time p&lt;2&gt;, cell r&lt;2&gt; bears the mark "#".

In brief, the output for our sake being the symbol that rests
under the tape-head H when the machine M gets to a rest state,
we are now amazed by the remarkable result that Parity(1) = 1.

¤~~~~~~~~~¤~~~~~~~~~¤~1~TUPTUO~¤~~~~~~~~~¤~~~~~~~~~¤

I am still in the process of de-tangling these
bits and pieces and odds and ends and notions
of threads, but till I do, here is a sampler
of linkages that may serve to explain a few
of the ideas that were not covered in any
suitably self-contained fashion above:

¤~~~~~~~~~¤~~~~~~~~~¤~REFERENCES~¤~~~~~~~~~¤~~~~~~~~~¤

[Refs have to be redone due to change in SUO Archive.]

¤~~~~~~~~~¤~~~~~~~~~¤~SECNEREFER~¤~~~~~~~~~¤~~~~~~~~~¤

¤~~~~~~~~~¤~~~~~~~~~¤~NOITARTSULLI~¤~~~~~~~~~¤~~~~~~~~~¤

¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤

Psahmes the Scribe,
Locally, Nominally,

Jon Awbrey

Auguration Day
Year 2001 A.D.

¤~~~~~~~~~¤~~~~~~~~~¤~DRAWROF~¤~~~~~~~~~¤~~~~~~~~~¤

To Be Continued ...

Jon Awbrey

¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤~~~~~~~~~¤

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<ul><li><strong>Follow-Ups</strong>:
<ul>
<li><strong><a name="00618" href="msg00618.html">SUO: Re: Differential Analytic Turing Automata (DATA)</a></strong>
<ul><li><em>From:</em> Jon Awbrey &lt;jawbrey@oakland.edu&gt;</li></ul></li>
</ul></li></ul>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg00597.html">SUO: Re: SubSetting The Record Straight</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00595.html">SUO: RE: SubSetting The Record Straight - maybe I spoke too soon.</A></STRONG>
</LI>
<li>Prev by thread:
<strong><a href="msg00621.html">SUO: RE: RE: #3 &quot;Flawed Approach</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00618.html">SUO: Re: Differential Analytic Turing Automata (DATA)</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="mail79.html#00596"><strong>Date</strong></a></li>
<li><a href="thrd74.html#00596"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
