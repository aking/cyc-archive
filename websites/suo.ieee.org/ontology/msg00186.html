<!-- MHonArc v2.4.8 -->
<!--X-Subject: Re: SUO: RE: Reducing n&#45;ary relations to binary -->
<!--X-From-R13: Rvrgevpu Tvfpure <svfpureNROD[EFORF.U[R.RS> -->
<!--X-Date: Wed, 13 Dec 2000 14:48:04 &#45;0500 (EST) -->
<!--X-Message-Id: 3A37CA3F.37268ECA@darmstadt.gmd.de -->
<!--X-Content-Type: multipart/alternative -->
<!--X-Reference: NEBBIHJJGLFPCMGGGKIAAEAECAAA.chris_partridge@csi.com -->
<!--X-Head-End-->

<!-- /groups/802/3/efm/public/email/msg00186.html -->
<!-- /groups/???? ?SUO?                              -->

<HTML>

<HEAD>
<TITLE>Re: SUO: RE: Reducing n-ary relations to binary</TITLE>
<LINK REV="made" HREF="mailto:fischer@DARMSTADT.GMD.DE">
</HEAD>

<BODY BGCOLOR="#FFFFFF">

<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->

<CENTER>

<TABLE CELLPADDING=3 CELLSPACING=0 BORDER=1 WIDTH="100%">
<TBODY>
<TR ALIGN="CENTER">
<TH COLSPAN=3><STRONG>Thread Links</STRONG></TH>
<TH COLSPAN=3><STRONG>Date Links</STRONG></TH>
</TR>
<TR ALIGN="CENTER">
<TD><A HREF="msg00177.html">Thread Prev</A>
</TD>
<TD><A HREF="msg00209.html">Thread Next</A>
</TD>
<TD><A HREF="thrd84.html#00186">Thread Index</A></Td>
<TD><A HREF="msg00187.html">Date Prev</A></TD>
<TD><A HREF="msg00185.html">Date Next</A>
</TD>
<TD><A HREF="mail87.html#00186">Date Index</A></TD>
</TR>
</TBODY>
</TABLE>
</CENTER>


<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: SUO: RE: Reducing n-ary relations to binary</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:mail@chrispartridge.net">mail@chrispartridge.net</A></LI>
<LI><em>Subject</em>: Re: SUO: RE: Reducing n-ary relations to binary</LI>
<LI><em>From</em>: Dietrich Fischer &lt;<A HREF="mailto:fischer@DARMSTADT.GMD.DE">fischer@DARMSTADT.GMD.DE</A>&gt;</LI>
<LI><em>Date</em>: Wed, 13 Dec 2000 20:13:03 +0100</LI>
<LI><em>CC</em>: &quot;Standard-Upper-Ontology (E-mail)&quot; &lt;<A HREF="mailto:standard-upper-ontology@ieee.org">standard-upper-ontology@ieee.org</A>&gt;</LI>
<LI><em>Organization</em>: GMD-IPSI, Dolivostr.15, D-64293 Darmstadt, Germany</LI>
<LI><em>References</em>: &lt;<A HREF="msg00177.html">NEBBIHJJGLFPCMGGGKIAAEAECAAA.chris_partridge@csi.com</A>&gt;</LI>
<LI><em>Reply-To</em>: Dietrich Fischer &lt;<A HREF="mailto:fischer@DARMSTADT.GMD.DE">fischer@DARMSTADT.GMD.DE</A>&gt;</LI>
<LI><em>Sender</em>: <A HREF="mailto:owner-standard-upper-ontology@ieee.org">owner-standard-upper-ontology@ieee.org</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->


Chris, you wrote:
<BLOCKQUOTE TYPE=CITE>Deiter,
<P>I am interested in some of your comments re: relation. They bring up
a point
<BR>that has been bothering me for some time. And maybe one on which the
SUO
<BR>needs to make an informed choice? Anyway I'd be interested in your
position.</BLOCKQUOTE>
I can only give hints or guesses to your tentative questions, because I
feel, that
<BR>in the field around is too much which bothers me by not having it understood.
<BR>SUO should not be lead astray by questions of implemention but stick
<BR>to a logic language and of course much more its content. I think, that
<BR>it was me, who by a sidelook, given in parenthesis,&nbsp; also has
entered some kind of
<BR>implementation aspect. My first answer to your first question therefore
is: No.
<BLOCKQUOTE TYPE=CITE>&nbsp;
<BR>It seems to me that there are (at least) two views regarding particular
<BR>relations in use in computing (Fritz Lehmann of Cyc has made a similar
<BR>point). One based in set theory may be called the 'bare relation' theory.
In
<BR>this view there are tuples (bare relations) with effectively no real
<BR>content. One based more on database theory (within computing) assumes
that
<BR>particular relations have content - that there is, for example, a particular
<BR>'between relation' between a number of particular things (I believe
(some?)
<BR>DLs also take this view - could you confirm this? Maybe OIL also takes
this
<BR>view?).</BLOCKQUOTE>
I admit, I do not understand your question here, perhaps you can restate
it.
<BR>"Bare relations", if I understand that word, are used to define the
"semantics"
<BR>to the syntax of the logic language. "Bare relations" may also be constructs
used
<BR>in the world of implementation.
<BLOCKQUOTE TYPE=CITE>&nbsp;
<BR>This seems to be what you are talking about when you wrote:
<BR>"Any particular relation is not itself a set of relations.&nbsp; 'between'
does
<BR>not specify a set of between-ness relations, it's just a particular
<BR>relation."</BLOCKQUOTE>
This wasn't my voice, but that of Adam Pease, I think.
<BR>However, it could be mine without any restraint.
<BR>To step on towards Mathew's view,
<BR>I see, that one may see a particular relation just as a particular
concept,
<BR>the extension of a concept being a&nbsp; set of objects, the extension
of a relation
<BR>being a set of pertinent true predications, as I would prefer to call
them.
<BR>Tuples linked to the relation object is my implementational view of
it,
<BR>notwithstanding that tuples are also used to formalize the set theoretical
semantics.
<BR>I do not (yet) see an advantage to amalgamate both kinds
<BR>instanceOf-relationships (the link types/slots, see above "linked"!)
<BR>on the syntax level or user level,
<BR>we may even skip both if we take concepts as unary predicates.
<BR>An obviously forgotten point in the previous discussion:
<BR>The "binarization" of relations stems perhaps to a great extent from
the
<BR>frame-slot paradigm (which was that in the beginning of Cyc) which
has
<BR>cognitive and pragmatic/ergonomical benefits
<BR>(object orientation versus assertion orientation),
<BR>but from the logicians point of view should be deemed
<BR>(or may I say doomed, greetings to John Awbrey!) to belong
<BR>already to the underground world of implementation.
<BR>OIL is an attempt to present a DL with a frame-slot flavour.
<BR>Though an old addict to that, I feel this hides the logic.
<BLOCKQUOTE TYPE=CITE>&nbsp;
<BR>Under a bare relation view there is, of course, no such thing as a
<BR>particular (in its strong sense) between relation.</BLOCKQUOTE>
?
<BLOCKQUOTE TYPE=CITE>&nbsp;
<BR>The advantage of the 'bare relation' view is that is uses a single
mechanism
<BR>for 'inheritance' over&nbsp; 'concepts' and 'relations' (as you have
classified
<BR>them). The disadvantage of the 'content' view is that is substitutes
<BR>inference for inheritance - x-father-y-son implies x-parent-y-child
- rather
<BR>than (x, y) is a member of (father-son) and (parent-child) and (father-son)
<BR>is a sub-class of (parent-child).</BLOCKQUOTE>

<BLOCKQUOTE TYPE=CITE>This is of course only the begining of the story
- there is much more to
<BR>consider when making the judgement. However the choice has implications
for
<BR>the axioms you use to manage relation 'inheritance'.
<P>Regards
<BR>Chris</BLOCKQUOTE>
Shouldn't we let all kinds of 'inheritance' belong to the arsenal of implementation
<BR>mechanisms for inference? But also for me:
<BLOCKQUOTE TYPE=CITE>This is of course only the beginning of the story...</BLOCKQUOTE>
Regards
<BR>&nbsp;&nbsp;&nbsp; Dietrich
<BR>or Dieter
<BR>&nbsp;
<BLOCKQUOTE TYPE=CITE>&nbsp;
<P>-----Original Message-----
<BR>From: Dietrich Fischer [<A HREF="mailto:fischer@darmstadt.gmd.de">mailto:fischer@darmstadt.gmd.de</A>]
<BR>Sent: 12 December 2000 17:07
<BR>To: West, Matthew MR SSI-GREA-UK
<BR>Cc: Standard-Upper-Ontology (E-mail)
<BR>Subject: Re: SUO: RE: Reducing n-ary relations to binary
<P>Dear Mathew,
<BR>the following was a point, where our previous private message exchange
<BR>stopped,
<BR>and where the public dialogue tree branch, as far as I see, also ended
as a
<BR>leaf,
<BR>to which I now respond a bit late, perhaps running into an open door,
<BR>as we say in German.
<P>> R048: (INSTANCE-OF NTH-SUBCLASS RELATION)
<P>MW: This seems to suggest that nth-subclass is a member of relation.
I think
<P>this is a mistake, nth-subclass should be a subtype of relation. (each
<BR>member of nth-subclass is a member of relation).
<P>I believe David is correct in this.&nbsp; Any particular relation is
not itself a
<P>set of relations.&nbsp; 'between' does not specify a set of between-ness
<BR>relations, it's just a particular relation.&nbsp; I'd suggest (as I
think David
<BR>does), that if we are to treat relations as first class objects (and
I know
<BR>Chris has cautioned us about this so we have to examine the implications
of
<BR>this carefully), that we have a relation similar to Cyc's 'genlPreds'
which
<BR>allows us to state that a relation is a more specific case of another
<BR>relation.&nbsp; Avoiding overloading the 'subclass-of' relation for
this use is
<BR>important.
<P>MW1: Perhaps we need to talk about what a relation is. My understanding
is
<BR>that a relation is the classification of a tuple, so in EXIST at least
this
<BR>is modelled explicitly and would look like:
<P>[ nth-subclass: &lt;between, 1, TangibleThing>]
<P>Here nth-subclass is a class, the colon is the "has as member" symbol,
and
<BR>the rest is a tuple that is a member of the class. So I would say that
any
<BR>structure of this form is a relation, and some of them are nth-subclass
<BR>relations. It may be that you are using relation where I would use
the term
<BR>class of relation.
<P>I would like to abstain from taking resort to
<BR>the "plurality of meanings" (John Awbrey's famous POMs)
<BR>and think that there is a somewhat more down to earth language trap
which
<BR>has caught us or, naturally from my point of view, you,
<BR>because I assume that your frame of reference here is also
<BR>some kind of "FOL- data modeling".
<P>The bewitchment may also have to do with the informal definition
<BR>of a class as a collection to which we attach some meaning,
<BR>and perhaps the difficulty stems from the example of a relation
<BR>which is a meta-relation in the sense that (with the exception of
<BR>the position argument) has as its arguments a relation and a concept.
<BR>However, our previous dissent was of the same nature.
<P>Let me first play your language game:
<BR>The mere n-tuples (n > 2) do not have so much meaning,
<BR>therefore we attach some meaning to them, by classifying them
<BR>such as we do with collections of objects (n-tuples with n=1)
<BR>by classifying them e.g. as "red objects".
<BR>So the "classification" of n-tuples (n>=1), according to your view,
<BR>always results in a "class".
<BR>However, I think that you will admit, that it may make sense
<BR>to distinguish, i.e. classify these "classes", e.g. in dichotomic
<BR>disjunctive way
<BR>with respect to n=1 and n>1. Then we get two classes, let me call them
<BR>for now "concept" and "relation" or may I also say
<BR>"unary predicate" and "n-ary predicate" with the respective
<BR>subclasses for each n?
<BR>Tautologically, the members of the "classes"
<BR>with n=1 are objects, the instances of the "classes" with n>1
<BR>are objects, which are "genuine" tuples, or -
<BR>departing from the former language game -
<BR>predications / basic assertions, which can be true or false?
<BR>(I do not quarrel about the name of a common superclass
<BR>for both types of classes, and anybody who tried to program
<BR>an automatic classifaction algorithm with respect
<BR>to subclassOf and subrelationOf may have seen,
<BR>that there is much in common to both relations.)
<BR>By that way, the "classes" "concept" and "relation" are such that
<BR>"relation" is instance of "concept", but "relation" is not a subconcept
of
<BR>"concept". And now, perhaps you have been already persuaded,
<BR>David's "NTH-SUBCLASS" relation (which is a generalisation
<BR>of what in Cyc is arg1Gnls, arg2Genls, etc., as far as I remember)
<BR>is an instance of "relation".
<BR>If "relation" is your "class of relation", then I would simply say,
<BR>I do not see a motivation for this twisted indirection of naming,
<BR>which unnecessarily may deter your target audience,
<BR>but I see many classes of relations, i.e. "concepts" whose instances
<BR>are relations.
<P>Maybe, you do not yet aggree, then think about this
<BR>(I try to resume your language game):
<BR>What is the relation between the a classified tuple (a,b) and its "class"
R.
<P>Perhaps you call it "isMemberOf". Then, according to your view,
<BR>we have
<BR>R isSubclassOf "class of relation"
<BR>or is it
<BR>R "isMemberOf" "class of relation"?
<BR>And what about the rule, which holds for "concepts":
<BR>((a,b) isMemberOf R) AND (R isSubclassOf "class of relation") ==>
<BR>(a,b) isMemberOf "class of relation"
<BR>or was it (R isMemberOf "class of relation") in the premiss, and
<BR>therefore the conclusion cannot be drawn,
<BR>and you are willing to admit,&nbsp; that David did it well, or do we
have
<BR>to postulate here another kind of "isMemberOf" relationship,
<BR>although/because&nbsp; it resulted from a "classification" of tuples?
<P>Regards,
<BR>Dietrich
<P>--
<P>Dietrich H. Fischer
<P>GMD-IPSI, TEL: 06151-869-901
<P>Dolivostrasse 15
<P>D-64293 Darmstadt</BLOCKQUOTE>

<PRE>--&nbsp;
Dietrich H. Fischer
GMD-IPSI, TEL: 06151-869-901
Dolivostrasse 15
D-64293 Darmstadt</PRE>
&nbsp;

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00177" href="msg00177.html">RE: SUO: RE: Reducing n-ary relations to binary</a></strong>
<ul><li><em>From:</em> Chris Partridge &lt;chris_partridge@csi.com&gt;</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<LI>Prev by Date:
<STRONG><A HREF="msg00187.html">SUO: Re: Some Questions About Semantics</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00185.html">SUO: some questions about semantics</A></STRONG>
</LI>
<li>Prev by thread:
<strong><a href="msg00177.html">RE: SUO: RE: Reducing n-ary relations to binary</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00209.html">SUO: Relating Relations to Simpler Relations</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="mail87.html#00186"><strong>Date</strong></a></li>
<li><a href="thrd84.html#00186"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
