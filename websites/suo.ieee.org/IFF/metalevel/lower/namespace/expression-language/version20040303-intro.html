<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>The IFF Namespace for Expression Languages (IFF-EXPR)</title>
  <meta name="author" content="Robert E. Kent">
  <meta name="description"
 content="This is an overview of the expression language namespace IFF-EXPR, which limits FOL languages to variables and relation symbols, but no function symbols.">
  <link rel="stylesheet"
 href="http://www.w3.org/StyleSheets/Core/Oldstyle.css" type="text/css">
</head>
<body>
<h2>The IFF Namespace for Expression Languages</h2>
<a href="#Architecture">Architecture</a><br>
<div style="margin-left: 40px;"><a href="#Expressions"><small>Expressions</small></a><br>
</div>
<a href="#Abstract_Syntax_">Abstract Syntax</a><br>
<div style="margin-left: 40px;"><a href="#Initial_Fixpoints"><small>Initial
Fixpoints</small></a><br>
</div>
<div style="margin-left: 40px;"><a href="#Example"><small>Example</small></a><br>
</div>
<div style="margin-left: 40px;"><a href="#Expressions_"><small>Expressions</small></a></div>
<p style="text-align: justify;">This document gives an introductory
discussion of the IFF Namespace
for
Expression Languages (IFF-EXPR). The <a
 href="http://suo.ieee.org/IFF/metalevel/lower/namespace/expression-language/version20040303.pdf">axiomatization</a>
is given separately.</p>
<h3><a name="Architecture" id="Architecture"></a>Architecture</h3>
<h4><a name="Expressions" id="Expressions"></a>Expressions</h4>
<p style="text-align: justify;">
In the IFF approach, First Order Logic (FOL) is factored into two main
components, a "term component" and an "expression component", plus a
third minor extensional component called the "equational component".
The term component is determined by function symbols, whereas the
expression component is mainly determined by relation symbols. The
expression namespace (for the most part) ignores the term component by
eliminating function symbols. The central concept in the expression
namespace is the expression construction (we use the term "expression"
where others use "formula"). In contrast to the term namespace, in the
expression namespace the <span style="font-style: italic;">Lawvere</span>
construction (see the red sub-diagram in Figure 1) plays a secondary
role, since it only consists of representing <span
 style="font-style: italic;">variations</span> that are the residual
aspect of term tuples when function symbols have been eliminated.
Variations are maps of <span style="font-style: italic;">indicia</span>,
subsets of variables which allow a change of variables through
substitution. In the full FOL namespace, expressions will be united
with terms by replacing variations with term tuples.
</p>
<p style="text-align: justify;">
In more detail, the basic notion of the IFF-EXPR namespace is that of
an expression <span style="font-style: italic;">language</span> (also
called, signature and lexicon). Languages are related through language
morphisms. Expressions and expression language morphisms form the
category <span style="font-family: Arial;">Expr-Lang</span>. The
concepts of <span style="font-style: italic;">variable</span> and <span
 style="font-style: italic;">relation</span> (Figure 1) are the
defining attributes of expression languages. The central data structure
in the IFF-EXPR is the concept of <span style="font-style: italic;">expression</span>.
This recursive construction over languages is the solution to a
fixpoint equation (see the blue sub-diagram of Figure 1). In full, the
expression construction gives an extended language, with an <span
 style="font-style: italic;">embedding</span> map connecting a language
to its expression extension. The concept of <span
 style="font-style: italic;">arity</span> is an attribute defined on
relations and expressions, in order of increasing generality. The
arity of an expression is loosely a set-theoretic upper bound for the
variables occurring freely in the expression. Arity is an indicia.
Expressions can be either <span style="font-style: italic;">atomic</span>
or <span style="font-style: italic;">composite</span>. Atoms are
relation-variation pairs that match the relation arity to the variation
index. The <span style="font-style: italic;">atom</span>
construction, and its <span style="font-style: italic;">relation</span>
and <span style="font-style: italic;">variation</span> component
attributes, is based upon the pullback along relation arity and
variation index. Composites are defined by logical connectives and
quantifiers. In the core, following existential graphs, we use only
negations, conjunctions and existential quantifications. Other
connectives and quantifiers can be defined in terms of these. The <span
 style="font-style: italic;">holds</span> construction represents atoms
as atomic expressions. The <span style="font-style: italic;">negation</span>
construction represents expressions as negative expressions. The <span
 style="font-style: italic;">conjunction</span> construction represents
expression subsets as conjunctive expressions. In the basic IFF
representation of FOL, the expression subset construction is the power
of expressions; in an extended IFF representation of FOL that follows
categorical logic, the expression subset construction requires a common
arity. The <span style="font-style: italic;">quantification</span>
construction represents expression cases as (existentially) quantified
expressions. The case construction is a sum construction used by the
quantification operator. The <span style="font-style: italic;">case</span>
construction, and its <span style="font-style: italic;">indication</span>
and <span style="font-style: italic;">projection</span> component
attributes, is
the coproduct of expression arity. The concepts of <span
 style="font-style: italic;">composition</span> and <span
 style="font-style: italic;">identity</span> (Figure 1) are composite
constructors for variations.
</p>
<div style="margin-left: 40px;"><img
 src="expression-basic-architecture.gif"
 title="Basic Expression Architecture"
 alt="Basic Expression Architecture"
 style="width: 654px; height: 321px;" vspace="20" hspace="10">
</div>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; background-color: rgb(204, 204, 204); width: 700px; margin-left: 40px;">
  <tbody>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; font-style: italic; font-weight: bold; color: rgb(0, 0, 255); text-align: center; width: 100px;">var<br>
      </td>
      <td style="vertical-align: top; width: 250px;">variables<br>
      </td>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; font-style: italic; text-align: center; color: rgb(0, 0, 255); font-weight: bold; width: 80px;">
      <font size="-1">elem<br>
      </font></td>
      <td style="vertical-align: top; width: 250px;">element &#8211;
variable as term<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; font-style: italic; font-weight: bold; color: rgb(0, 0, 255); text-align: center; width: 100px;">rel<br>
      </td>
      <td style="vertical-align: top; width: 220px;">relation
symbols<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; color: rgb(0, 0, 255); font-weight: bold;">
      <font size="-1">@</font></td>
      <td style="vertical-align: top; width: 220px;">embedding &#8211;
relation as atom</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; font-weight: bold; color: rgb(0, 0, 255); text-align: center; width: 100px;">&#8472;</td>
      <td style="vertical-align: top; width: 220px;">power set
operator<br>
      </td>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; width: 50px; color: rgb(0, 0, 255); font-weight: bold;">
      <big><font size="-1"><big><span style="color: rgb(0, 0, 255);">#</span></big></font></big></td>
      <td style="vertical-align: top; width: 220px;">relation/expression
arity<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; text-align: center; font-style: italic; font-family: arial; font-weight: bold; color: rgb(51, 51, 255); width: 100px;">atm</td>
      <td style="vertical-align: top;">atoms</td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; text-align: center; font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">
      <big>&#9674;</big></td>
      <td style="vertical-align: top;">holds operator (injection)</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; font-style: italic; font-weight: bold; color: rgb(0, 0, 255); text-align: center; width: 100px;">expr<br>
      </td>
      <td style="vertical-align: top;">expressions<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; color: rgb(0, 0, 255);">
      <big>&not;</big></td>
      <td style="vertical-align: top;">negation operator
(injection)<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; text-align: center; color: rgb(51, 51, 255);">
      <span
 style="font-style: italic; font-family: arial; font-weight: bold;">expr</span>
      <small style="font-weight: normal;">&#959;</small> <big
 style="font-weight: bold;">&#8472;</big></td>
      <td style="vertical-align: top;">expression-subsets<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; text-align: center; font-weight: bold; color: rgb(51, 51, 255);">
      <big><big>&#710;</big></big></td>
      <td style="vertical-align: top;">conjunction operator
(injection)</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; font-style: italic; font-weight: bold; color: rgb(0, 0, 255); text-align: center; width: 100px;">case<br>
      </td>
      <td style="vertical-align: top;">expression-variable
pairs<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; font-weight: bold; text-align: center; color: rgb(51, 51, 255);">&#8707;</td>
      <td style="vertical-align: top;">quantification operator
(injection)<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; text-align: center; font-style: italic; font-weight: bold; font-family: arial; color: rgb(51, 51, 255);">
      <big><font size="-1"><big>i<small>ndic,
proj</small></big></font></big></td>
      <td style="vertical-align: top;">case indication and
projection</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; font-weight: bold; color: rgb(255, 0, 0); font-style: italic; text-align: center; width: 100px;">vrtn</td>
      <td style="vertical-align: top;">variations</td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; color: rgb(0, 0, 255); font-weight: bold;">
      <big style="color: rgb(51, 51, 255);"><font size="-1"><big><span
 style="color: rgb(255, 0, 0);">#</span><span
 style="color: rgb(0, 0, 0);">,</span></big></font></big> <big
 style="color: rgb(255, 0, 0);"><font size="-1"><big>&sect;</big></font></big></td>
      <td style="vertical-align: top;">variation arity and
index<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-weight: bold; font-family: arial; color: rgb(255, 0, 0); text-align: center; width: 100px;">
      <span style="font-style: italic;">vrtn</span> <span
 style="font-weight: normal;">&#8855;</span> <span
 style="font-style: italic;">vrtn</span></td>
      <td style="vertical-align: top;">variation-variation composable
pairs</td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; text-align: center; color: rgb(255, 0, 0); font-weight: bold;">
      <small>&#927;</small></td>
      <td style="vertical-align: top;">lawvere composition</td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; color: rgb(255, 0, 0); font-weight: bold; text-align: center; width: 100px;">
      <span style="font-style: italic;">var</span> <small
 style="font-weight: normal;">&#959;</small> <big>&#8472;</big></td>
      <td style="vertical-align: top;">indicia (subsets of
variables)<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; color: rgb(255, 0, 0); font-weight: bold;">
      <big><font size="-1"><big><small>1</small><br>
      </big></font></big></td>
      <td style="vertical-align: top;">lawvere identity (indicia as
tuple)<br>
      </td>
    </tr>
  </tbody>
</table>
<p style="margin-left: 40px;"><big><span style="font-weight: bold;">Figure
1: Basic Expression Functors and Natural Transformations</span></big></p>
<p style="text-align: justify;">
The basic architecture of expression languages is illustrated in Figure
1. This consists of three sub-diagrams &#8211; the expression sub-diagram
(upper left), the arity sub-diagram (lower left) and the lawvere
sub-diagram (right). The expression sub-diagram and the arity
sub-diagram illustrate the fixpoint solution for expressions and the
co-recursive definition of expression arity. The lawvere sub-diagram
illustrates the Lawvere construction for variations. The fixpoint
solution for expressions embeds atoms as atomic expressions via the
holds operator, embeds expressions as negative expressions via the
negation operator, embeds expression-subsets as conjunctive expressions
via the conjunction operator, and embeds expression cases as
(existentially) quantified expressions via the quantification operator.
Atoms are projected into their relation and variation components, and
relation symbols are embedded as atoms.
</p>
<p style="text-align: justify;">
The nodes in Figure 1 represent basic functors from <span
 style="font-family: Arial;">Expr-Lang</span> the category of
expression languages and expression language morphisms to <span
 style="font-family: Arial;">Set</span> the category of (small) sets
and set functions. The edges in Figure 1 represent natural
transformations between these basic functors. There are five simple
functors <i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">var</span></i>, <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">rel</span></i>, <i
 style="font-weight: bold; color: rgb(255, 0, 0);"><span
 style="font-family: Arial;">vrtn</span></i>, <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">case</span></i> and <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>, for variables, relation
symbols, variations, expression cases and expressions, respectively.
The first three are basic, the fourth is composite and the last is
inductively defined. Based on these, there are three composite
functors: <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">var</span><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&nbsp;&#959;&nbsp;</span><span
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">&#8472;</span>,
<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">expr</span><span
 style="font-weight: bold; color: rgb(0, 0, 255);">&nbsp;&#959;&nbsp;</span><span
 style="font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">&#8472;</span>
and <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">vrtn</span>&nbsp;<span
 style="color: rgb(255, 0, 0);">&#8855;</span>&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">vrtn</span>,
for indicia (variable subsets), expression-subsets and composable
variation-variation pairs, respectively. The &#8216;<span
 style="color: rgb(255, 0, 0);">&#8855;</span>&#8217; symbol refers to a matched
Cartesian product &#8211; the arity of the first variation matches the index
of the second variation. Any of the natural transformations in Figure 1
must satisfy naturality conditions. Take for example the expression
arity natural transformation
</p>
<div style="margin-left: 40px;">
<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">#</span>&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">expr</span>&nbsp;<big><big>&#8658;</big></big>&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">var</span><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&nbsp;&#959;&nbsp;</span><span
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">&#8472;</span>&nbsp;:&nbsp;<span
 style="font-family: arial;">Expr-Lang</span>&nbsp;&#8594;&nbsp;<span
 style="font-family: arial;">Set</span>
</div>
<p style="text-align: justify;">
whose source category is the category
of expression languages <span style="font-family: arial;">Expr-Lang</span>,
whose target category is the category of sets <span
 style="font-family: arial;">Set</span>, whose source functor is the
expression functor <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">expr</span>
: <span style="font-family: arial;">Expr-Lang</span>&nbsp;&#8594;&nbsp;<span
 style="font-family: arial;">Set</span>, whose target functor is the
indicia functor <span style="font-style: italic; font-family: arial;">var</span>&nbsp;&#959;&nbsp;<span
 style="font-family: arial;">&#8472;</span>&nbsp;: <span
 style="font-family: arial;">Expr-Lang</span>&nbsp;&#8594;&nbsp;<span
 style="font-family: arial;">Set</span>, and whose <span
 style="font-style: italic; font-weight: bold;">L</span><small><sup>th</sup></small>
component for any expression language <span
 style="font-style: italic; font-weight: bold;">L</span> is the
expression arity function <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">#</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">expr</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;&#8594;&nbsp;<span
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">&#8472;</span><span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">var</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>). Then, for
any expression language morphism <span
 style="font-style: italic; font-weight: bold;">f</span>&nbsp;:&nbsp;<span
 style="font-style: italic; font-weight: bold;">L</span><sub>1</sub>&nbsp;&#8594;&nbsp;<span
 style="font-style: italic; font-weight: bold;">L</span><sub>2</sub>,
expression arity must satisfy the commuting diagram <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">expr</span>(<span
 style="font-style: italic; font-weight: bold;">f</span>)&nbsp;&middot;&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">#</span>(<span
 style="font-style: italic; font-weight: bold;">L</span><sub>2</sub>)&nbsp;=&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">#</span>(<span
 style="font-style: italic; font-weight: bold;">L</span><sub>1</sub>)&nbsp;&middot;&nbsp;<span
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">&#8472;</span><span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">var</span>(<span
 style="font-style: italic; font-weight: bold;">f</span>), which
represents two conditions: (1) the naturality condition of the
expression arity natural transformation for the expression language
morphism <span style="font-style: italic; font-weight: bold;">f</span>,
and (2) the fact that the expression language morphism <span
 style="font-style: italic; font-weight: bold;">f</span> preserves
expression arity. A similar assertion can be made for any of the
natural transformations in Figure 1; and this is axiomatized in this
namespace. In addition, a third condition holds for any of the
Lawvere-related natural transformation axiomatized in this namespace.
Take for example, the variation arity natural transformation
</p>
<div style="margin-left: 40px;">
<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">#</span>&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">vrtn</span>&nbsp;<big><big>&#8658;</big></big>&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">var</span><span
 style="font-weight: bold; color: rgb(255, 0, 0);">&nbsp;&#959;&nbsp;</span><span
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">&#8472;</span>&nbsp;:&nbsp;<span
 style="font-family: arial;">Expr-Lang</span>&nbsp;&#8594;&nbsp;<span
 style="font-family: arial;">Set</span>
</div>
<p style="text-align: justify;">
whose <span style="font-style: italic; font-weight: bold;">L</span><sup>th</sup>
component for any expression language <span
 style="font-style: italic; font-weight: bold;">L</span> is the
variation arity function <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">#</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">vrtn</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;&#8594;&nbsp;<span
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">&#8472;</span><span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">var</span><span
 style="font-family: arial;">(</span><span
 style="font-style: italic; font-weight: bold;">L</span>). Then, for
any expression language morphism <span
 style="font-style: italic; font-weight: bold;">f</span>&nbsp;:&nbsp;<span
 style="font-style: italic; font-weight: bold;">L</span><sub>1</sub>&nbsp;&#8594;&nbsp;<span
 style="font-style: italic; font-weight: bold;">L</span><sub>2</sub>,
variation arity must satisfy the commuting diagram <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">vrtn</span>(<span
 style="font-style: italic; font-weight: bold;">f</span>)&nbsp;&middot;&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">#</span>(<span
 style="font-style: italic; font-weight: bold;">L</span><sub>2</sub>)&nbsp;=&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">#</span>(<span
 style="font-style: italic; font-weight: bold;">L</span><sub>1</sub>)&nbsp;&middot;&nbsp;<span
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">&#8472;</span><span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">var</span>(<span
 style="font-style: italic; font-weight: bold;">f</span>), which
represents three conditions: (1) the naturality condition of the
variation arity natural transformation for the expression language
morphism <span style="font-style: italic; font-weight: bold;">f</span>,
(2) the fact that the expression language morphism <span
 style="font-style: italic; font-weight: bold;">f</span> preserves
variation arity; and (3) the fact that the Lawvere functor preserves
the target (arity) of variations.
</p>
<div style="margin-left: 40px;"><img
 src="expression-monadic-architecture.gif"
 title="Expression Monadic Architecture"
 alt="Expression Monadic Architecture"
 style="width: 540px; height: 150px; font-family: abadi mt condensed extra bold;"
 hspace="20" vspace="20">
</div>
<table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; background-color: rgb(204, 204, 204); width: 600px; margin-left: 40px;">
  <tbody>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; font-weight: bold; color: rgb(102, 0, 0); width: 30px;">
      <span style="font-style: italic; font-family: arial;">endo</span></td>
      <td style="vertical-align: top; width: 200px;">expression monad
endofunctor<br>
      </td>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; font-weight: bold; color: rgb(102, 0, 0); width: 30px;">
      <span style="font-style: italic; font-family: arial;">&#951;</span></td>
      <td style="vertical-align: top; width: 220px;">expression monad
unit<br>
      </td>
    </tr>
    <tr>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; font-weight: bold; color: rgb(0, 153, 0); width: 40px;">
      <br>
      </td>
      <td style="vertical-align: top; width: 170px;"><br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
      <td
 style="vertical-align: top; font-family: arial; text-align: center; font-weight: bold; color: rgb(102, 0, 0); width: 40px;">
      <span style="font-style: italic; font-family: arial;">&#956;</span></td>
      <td style="vertical-align: top; width: 200px;">expression monad
multiplication<br>
      </td>
    </tr>
  </tbody>
</table>
<p style="font-weight: bold; margin-left: 40px;"><big>Figure 2:
Expression Monad Functors and Natural Transformations</big></p>
<div style="text-align: justify;">
In universal algebra, the notion of a free algebra is associated with
an endofunctor that assigns to any set (of variable-like objects) the
set of elements of the corresponding free algebra. This endofunctor
comes equipped with two natural transformations that give it a
"monoid"-like structure called a monad &#8211; one natural transformation
called the unit embeds a set (thought of as variables) as terms and the
other natural transformation is the free interpretation or action on
the free algebra over the given set. This association between free
algebra constructions and monads can be abstracted and generalized &#8211;
any adjunction gives a monad, which itself has an alternate but related
adjunction. In fact, in this sense adjunctions, monads and their
interconnections abstractly algebracize Galois connections, closure
operators and their interconnections. A monad construction exists for
expressions in FOL. The monadic architecture of expression languages is
illustrated in Figure 2. The abstract algebraic structure of the
expression construction is concentrated in the expression <span
 style="font-style: italic;">monad</span></div>
<div style="margin-left: 40px;">
&#9001;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>,&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">&#951;</span>,&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">&#956;</span>&#9002;,
</div>
which is a triple consisting of the following components:
<ul>
  <li style="text-align: justify;">the expression monad <span
 style="font-style: italic;">endofunctor</span> <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>&nbsp;:
    <span style="font-family: arial;">Expr-Lang</span>&nbsp;&#8594;&nbsp;<span
 style="font-family: arial;">Expr-Lang</span>, which maps an expression
language <span style="font-style: italic; font-weight: bold;">L</span>
to the extension expression language <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>),
whose variables are the same, but whose relations are <span
 style="font-style: italic; font-weight: bold;">L</span>-expressions,</li>
  <li style="text-align: justify;">the <span
 style="font-style: italic;">unit</span>
natural transformation <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">&#951;</span>&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial;">id</span>&nbsp;<big><big>&#8658;</big></big><span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>&nbsp;:
    <span style="font-family: arial;">Expr-Lang</span>&nbsp;&#8594;&nbsp;<span
 style="font-family: arial;">Expr-Lang</span>, whose source functor is
the identity functor on <span style="font-family: arial;">Expr-Lang</span>,
whose target functor is the expression monad endofunctor <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>,
and whose <span style="font-style: italic; font-weight: bold;">L</span><small><sup>th</sup></small>
component is the embedding expression language morphism <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">&#951;</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;:&nbsp;<span
 style="font-style: italic; font-weight: bold;">L</span>&nbsp;&#8594;&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>), which is
identity on variables and the expression embedding map on relations, and</li>
  <li style="text-align: justify;">the <span
 style="font-style: italic;">multiplication</span>
natural transformation <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">&#956;</span>&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>&nbsp;&#959;&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>&nbsp;<big><big>&#8658;</big></big><span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>&nbsp;:
    <span style="font-family: arial;">Expr-Lang</span>&nbsp;&#8594;&nbsp;<span
 style="font-family: arial;">Expr-Lang</span>, whose source functor is
the expression monad endofunctor composed with itself, whose target
functor is the expression monad endofunctor <span
 style="font-style: italic; font-family: arial;">endo</span>, and whose
    <span style="font-style: italic; font-weight: bold;">L</span><small><sup>th</sup></small>
component is the collapsing expression language morphism <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">&#956;</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;: <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>(<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>))&nbsp;&#8594;&nbsp;<span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>), which is
identity on variables and the expression collapsing map on relations
(expressions-on-expressions).</li>
</ul>
<p style="text-align: justify;">
In contract to the universal algebra situation discussed above, this
monad is not associated with free algebras, but with "free expression
languages" &#8211; for any expression language <span
 style="font-style: italic; font-weight: bold;">L</span>, the extension
expression language <span
 style="font-style: italic; font-family: arial; font-weight: bold; color: rgb(102, 0, 0);">endo</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) is free over <span
 style="font-style: italic; font-weight: bold;">L</span>. We use this
to extend the notion of a expression language morphism to the freer
notion of a expression language <span style="font-style: italic;">interpretation</span>
where the image of source relation symbols is not restricted to target
relation symbols, but can be mapped to target expressions. The
algebraic semantics can likewise be extended.
</p>
<h3><a name="Abstract_Syntax_" id="Abstract_Syntax_"></a>Abstract Syntax</h3>
<p style="text-align: justify;">
The notion of <i>abstract syntax</i> is a technical term <a
 href="http://www-formal.stanford.edu/jmc/towards/node12.html">introduced</a>
by John McCarthy: &#8220;The predicates and functions whose existence and
relations define the syntax, are precisely those needed to translate
from the language, or to define the semantics&#8221;. The abstract syntax of
FOL expression languages is the highest meta-level needed in order to
define the syntax and model theory of FOL expression languages. The
orientation in the McCarthy statement is towards the notion of an <i>abstract
data type</i>, which defines the abstract syntax and formal semantics
of data types. In general, abstract syntax consists of a collection of <span
 style="font-style: italic;">synthetic/constructor</span> operators, a
collection of <span style="font-style: italic;">analytic/selector</span>
operators, and a collection of <span style="font-style: italic;">axioms</span>
that related the syntax. For recursive data types, the
synthetic/constructor operators are unpacked from the initial (or
final) fixpoint solution (bijection) of a set equation(s). The
analytic/selector operators are inverse to the synthetic/constructor
operators, and this is the content of the axiomatization for the
abstract data type. In fact, the axioms form subcollections, which are
in one-one correspondence with the synthetic/constructor operators (and
their analytic/selector inverses). The analytic/selector functions are
partial functions, each has an associated Boolean test for its domain,
and the correct analytic programming style is to test for &#8220;in domain&#8221;
before applying any of the analytic/selector functions. Finally, to
quote McCarthy, &#8220;if both the analytic and synthetic functions are
given, we do not have the difficult and sometimes unsolvable analysis
problems that arise when languages are described synthetically only".
</p>
<h4><a name="Initial_Fixpoints" id="Initial_Fixpoints"></a>Initial
Fixpoints</h4>
<p style="text-align: justify;">
For any &#969;-continuous <span
 style="font-family: arial; font-weight: bold;">Set</span> endofunctor <span
 style="font-family: arial;"><span
 style="font-style: italic; font-weight: bold;">F</span>&nbsp;:&nbsp;<span
 style="font-weight: bold;">Set</span>&nbsp;<big>&#8594;</big>&nbsp;<span
 style="font-weight: bold;">Set</span></span>, there is an initial
fixpoint solution <span style="font-family: arial; font-style: italic;">X</span><sup><small
 style="font-family: arial;">@</small></sup> to the equation <span
 style="font-family: arial; font-weight: bold; font-style: italic;">F</span>(<span
 style="font-family: arial;"><span style="font-style: italic;">X</span></span>)&nbsp;&#8773;&nbsp;<span
 style="font-family: arial;"><span style="font-style: italic;">X</span></span>.
Any such fixpoint solution has an increasing approximation sequence <span
 style="font-family: arial; font-style: italic;">X</span><sub>0</sub> =
&Oslash;, <span style="font-family: arial; font-style: italic;">X</span><sub>1</sub>
= <span style="font-family: arial; font-weight: bold;"><span
 style="font-style: italic;">F</span></span>(&Oslash;), &#8230;,<span
 style="font-family: arial; font-style: italic;">X</span><sub><span
 style="font-style: italic;">n</span>+1</sub> = <span
 style="font-family: arial; font-weight: bold;"><span
 style="font-style: italic;">F</span></span>(<span
 style="font-family: arial; font-style: italic;">X</span><sub><span
 style="font-style: italic;">n</span></sub>), &#8230; <span
 style="font-family: arial; font-style: italic;">X</span><small
 style="font-family: arial;"><sup>@</sup></small> = <span
 style="font-family: script mt bold;">lim</span><sub><span
 style="font-style: italic;">n</span></sub>(<span
 style="font-family: arial; font-style: italic;">X</span><sub><span
 style="font-style: italic;">n</span></sub>) starting from the empty
set, constructing each successive step by endofunctor application, and
"ending" at the fixpoint solution. The expression data type is a
recursive data type compactly axiomatized as the fixpoint solution
</p>
<p style="margin-left: 40px;">
&#945;&nbsp;:&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">fixpt</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)
</p>
<p>
(bijection) of the fixpoint set equation
</p>
<div style="margin-left: 40px;">
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">fixpt</span></i>(<b><i>L</i></b>)(<i><span
 style="font-family: Arial;">X</span></i>)&nbsp;&#8773;&nbsp;<i><span
 style="font-family: Arial;">X</span></i></div>
<p style="text-align: justify;">
with the fixpoint set operator <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">fixpt</span></i>(<b><i>L</i></b>)(<i><span
 style="font-family: Arial;">X</span></i>), which is the sum of (1) the
constant set of atoms <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">atm</span></i>(<b><i>L</i></b>), (2) the
variable set <i><span style="font-family: Arial;">X</span></i>, (3)
the power set <span style="color: rgb(0, 0, 255);">&#8472;</span><i><span
 style="font-family: Arial;">X</span></i> and (4) the coproduct of the
arity function #<sub><span
 style="font-style: italic; font-weight: bold;">L</span></sub>&nbsp;:&nbsp;<i><span
 style="font-family: Arial;">X</span></i>&nbsp;&#8594;&nbsp;<span
 style="color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>). The
synthetic/constructor operators are unpacked from the fixpoint solution
bijection &#945;. For any expression language <span
 style="font-style: italic; font-weight: bold;">L</span>, the set of
expressions <span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">expr</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) and the
expression arity function #<sub><span
 style="font-style: italic; font-weight: bold;">L</span></sub>&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">expr</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;&#8594;&nbsp;<span
 style="color: rgb(0, 0, 255);">&#8472;</span><span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">var</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) are
corecursively defined. The case component of the expression set is the
coproduct of the arity function <span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">case</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) = &#8721;(#<sub><span
 style="font-style: italic; font-weight: bold;">L</span></sub>), and
the source of the arity function is the expression set. The
approximation sequence for the fixpoint solution of expressions starts
as: <span style="font-family: arial; font-style: italic;">X</span><sub>0</sub>
= <span style="font-weight: bold; color: rgb(0, 0, 255);">&Oslash;</span>,
<span style="font-family: arial; font-style: italic;">X</span><sub>1</sub>
= <span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">atm</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) + <small
 style="color: rgb(0, 0, 255);"><span
 style="font-weight: bold; font-family: courier new;">true</span></small>,
&#8230; , and ends as <span style="">the complete expression set</span> <span
 style="font-family: arial; font-style: italic;">X</span><small
 style="font-family: arial;"><sup>@</sup></small> = <span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">expr</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)<span style="">in
the limit (fixpoint)</span>, where <span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">atm</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) is a set
constant and <small style="color: rgb(0, 0, 255);"><span
 style="font-weight: bold; font-family: courier new;">true</span></small>
is the conjunction of the empty subset of the empty set. In
co-recursive parallel, the arity function approximation sequence starts
as the empty arity function #<sub><span
 style="font-style: italic; font-weight: bold;">L</span></sub>&nbsp;:&nbsp;<span
 style="font-weight: bold; color: rgb(0, 0, 255);">&Oslash;</span>&nbsp;&#8594;&nbsp;<span
 style="color: rgb(0, 0, 255);">&#8472;</span><span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">var</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) at step 0,
the atomic arity function #<sub><span
 style="font-style: italic; font-weight: bold;">L</span></sub>&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">atm</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;+&nbsp;<small
 style="color: rgb(0, 0, 255);"><span
 style="font-weight: bold; font-family: courier new;">true</span></small>&nbsp;&#8594;&nbsp;<span
 style="color: rgb(0, 0, 255);">&#8472;</span><span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">var</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) at step 1
where the arity of <span style=""><small style="color: rgb(0, 0, 255);"><span
 style="font-weight: bold; font-family: courier new;">true</span></small></span>
is empty, &#8230; , and ends as the complete expression arity function #<sub><span
 style="font-style: italic; font-weight: bold;">L</span></sub>&nbsp;:&nbsp;<span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">expr</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>)&nbsp;&#8594;&nbsp;<span
 style="color: rgb(0, 0, 255);">&#8472;</span><span
 style="font-style: italic; font-family: arial; color: rgb(0, 0, 255); font-weight: bold;">var</span>(<span
 style="font-style: italic; font-weight: bold;">L</span>) in the limit
(fixpoint). The coproduct of these approximate arity functions is
clearly increasing.
</p>
<h4><a name="Example" id="Example"></a>Example</h4>
<p style="text-align: justify;">
The classic case of an abstract datatype is the <i>stack</i> datatype.
This can be used to guide us in specifying the abstract syntax for FOL
expression languages. An axiomatization for stack goes as follows:
</p>
<ul>
  <li>
    <p>Since this is parametric, there is a name for the parameter type
&#8216;<b><i>P</i></b>&#8217;. There is a name for the stack datatype &#8216;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)&#8217;.
    </p>
  </li>
  <li>
    <p>There is a collection of <i>synthetic</i>/<i>constructor</i>
operators on stacks: </p>
    <p style="margin-left: 40px;"> <i style="font-weight: bold;"><span
 style="font-family: Arial;">empty</span></i>(<b><i>P</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)
    </p>
    <p style="margin-left: 40px;"> <i style="font-weight: bold;"><span
 style="font-family: Arial;">push</span></i>(<b><i>P</i></b>)<span
 style="font-family: Symbol;"><span style="">:</span></span>&nbsp;<b><i>P</i></b>&#8201;&times;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)
    </p>
    <p style="text-align: justify;">where &#8216;<i style="font-weight: bold;"><span
 style="font-family: Arial;">empty</span></i>(<b><i>P</i></b>)&#8217;
denotes the empty stack and &#8216;<i style="font-weight: bold;"><span
 style="font-family: Arial;">push</span></i>(<b><i>P</i></b>)(<i>p</i>,&nbsp;<i>s</i>)&#8217;
places the item <i>p</i>&nbsp;<small>&#8712;</small>&nbsp;<b><i>P</i></b> of
type <b><i>P</i></b> onto the top of stack <i>s</i>&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>).
The stack data type is a recursive data type compactly axiomatized as
the fixpoint solution</p>
    <p style="margin-left: 40px;">&#945;&nbsp;:&nbsp;(<b>1</b>&nbsp;+&nbsp;<b><i>P</i></b>&#8201;&times;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>))&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)
    </p>
    <p>(bijection) of the simple linear fixpoint set equation </p>
    <div style="margin-left: 40px;"> <b><span
 style="font-family: Symbol;"><span style="">1</span></span></b>&nbsp;<span
 style="font-family: Symbol;"><span style="">+</span></span>&nbsp;(<b><i>P</i></b>&#8201;&times;<i>X</i>)&nbsp;&#8773;&nbsp;<i>X</i></div>
    <p>where the synthetic/constructor operators are unpacked from the
fixpoint solution bijection &#945;. </p>
  </li>
  <li>
    <div style="text-align: justify;">There is a collection of <i>analytic</i>/<i>selector</i>
operators on stacks with the two subgroup clusters in one-one
correspondence with the two synthetic/constructor operators (their
inverse): </div>
    <p style="margin-left: 40px;"> <i style="font-weight: bold;"><span
 style="font-family: Arial;">is-empty</span></i>(<b><i>P</i></b>)&nbsp;&#8838;&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)</p>
    <div style="margin-left: 40px;"><i style="font-weight: bold;"><span
 style="font-family: Arial;">is-nonempty</span></i>(<b><i>P</i></b>)&nbsp;&#8838;&nbsp;<span
 style="font-family: Arial; font-weight: bold; font-style: italic;">stk</span>(<b><i>P</i></b>)
    <br>
    <i style="font-weight: bold;"><span style="font-family: Arial;">top</span></i>(<b><i>P</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)&nbsp;&#8594;&nbsp;<b><i>P</i></b>
    <br>
    <i style="font-weight: bold;"><span style="font-family: Arial;">pop</span></i>(<b><i>P</i></b>)&nbsp;<span
 style="font-family: Symbol;"> <span style="">:</span></span>&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)
    </div>
    <p style="text-align: justify;">where &#8216;<i style="font-weight: bold;"><span
 style="font-family: Arial;">is-empty</span></i>(<b><i>P</i></b>)(<i>s</i>)&#8217;
is the Boolean test that returns true when the stack <i>s</i>&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>)
is empty and false otherwise, &#8216;<i style="font-weight: bold;"><span
 style="font-family: Arial;">is-nonempty</span></i>(<b><i>P</i></b>)(<i>s</i>)&#8217;
is the complementary Boolean test, &#8216;<i style="font-weight: bold;"><span
 style="font-family: Arial;">top</span></i>(<b><i>P</i></b>)(<i>s</i>)&#8217;
returns the &#8220;top&#8221; of stack <i>s</i>&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>),
and
&#8216;<i style="font-weight: bold;"><span style="font-family: Arial;">pop</span></i>(<b><i>P</i></b>)(<i>s</i>)&#8217;
returns the &#8220;rest&#8221; of stack <i>s</i>&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>).
Since both top and pop are partial functions whose domain is the set of
nonempty stacks, the correct analytic programming style is to test
for nonempty stack before applying either of these functions. </p>
  </li>
  <li>
    <p>These operators satisfy the defining stack abstract data
type
semantics:</p>
    <p style="margin-left: 40px;"> <i style="font-weight: bold;"><span
 style="font-family: Arial;">is-nonempty</span></i>(<b><i>P</i></b>)(<i
 style="font-weight: bold;"><span style="font-family: Arial;">empty</span></i>(<b><i>P</i></b>))
    </p>
    <p>which states that the empty stack is empty. </p>
    <p style="margin-left: 40px;">&#8704;(<i>p</i>&nbsp;<span
 style="font-family: Symbol;"><span style="">:</span></span>&nbsp;<b><i>P</i></b>,&nbsp;<i>s</i>&nbsp;:&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>))&nbsp;(<i
 style="font-weight: bold;"><span style="font-family: Arial;">is-nonempty</span></i>(<b><i>P</i></b>)(<i
 style="font-weight: bold;"><span style="font-family: Arial;">push</span></i>(<b><i>P</i></b>)(<i>p</i>,&nbsp;<i>s</i>))&nbsp;&amp;&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">top</span></i>(<b><i>P</i></b>)(<i
 style="font-weight: bold;"><span style="font-family: Arial;">push</span></i>(<b><i>P</i></b>)(<i>p</i>,&nbsp;<i>s</i>))
= <i>p</i>&nbsp;&amp;&nbsp;<i style="font-weight: bold;"><span
 style="font-family: Arial;">pop</span></i>(<b><i>P</i></b>)(<i
 style="font-weight: bold;"><span style="font-family: Arial;">push</span></i>(<b><i>P</i></b>)(<i>p</i>,&nbsp;<i>s</i>))
= <i>s</i>) </p>
    <p>which states that the result of a push is a nonempty stack,
whose top
is the thing pushed and whose pop is the original stack. </p>
    <p style="margin-left: 40px;">&#8704;(<i>s</i>&nbsp;<span
 style="font-family: Symbol;"><span style="">:</span></span>&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">stk</span></i>(<b><i>P</i></b>))&nbsp;(<i
 style="font-weight: bold;"><span style="font-family: Arial;">is-nonempty</span></i>(<b><i>P</i></b>)(<i>s</i>)&nbsp;&#8658;&nbsp;(<i
 style="font-weight: bold;"><span style="font-family: Arial;">push</span></i>(<b><i>P</i></b>)(<i
 style="font-weight: bold;"><span style="font-family: Arial;">top</span></i>(<b><i>P</i></b>)(<i>s</i>),&nbsp;<i
 style="font-weight: bold;"><span style="font-family: Arial;">pop</span></i>(<b><i>P</i></b>)(<i>s</i>))
= <i>s</i>)) </p>
    <p>which states that every nonempty stack is constructible
using the push
operator from its top and pop. </p>
  </li>
</ul>
<h4><a name="Expressions_" id="Expressions_"></a>Expressions</h4>
<img src="expression-abstract-syntax.gif"
 title="Expression Abstract Syntax" alt="Expression Abstract Syntax"
 style="width: 333px; height: 196px;" hspace="40">
<p style="margin-left: 40px;"><big><b>Figure 3: The Expression Fixpoint
Solution</b></big></p>
<p style="text-align: justify;">
Turning now towards the IFF first order logic languages, we need to
axiomatize the abstract syntax for terms and expressions. For
simplicity in the IFF expression languages, we will just express the
traditional FOL part, but we do not express the FOL term operators or
FOL term abstract data typesemantics and we do not include equations,
but we do express all of the core IFF FOL expression abstract syntax.
An axiomatization for stack goes as follows.
</p>
<hr
 style="height: 2px; width: 50%; margin-left: 0px; margin-right: auto;"
 noshade="noshade">
<p style="text-align: justify;">The abstract syntax of expression
languages is illustrated in Figure 3. The abstract syntax of FOL
expressions is parametric: there is a name for the parameter language
or lexicon &#8216;<span style="font-style: italic; font-weight: bold;">L</span>&#8217;
and also a name for FOL expressions &#8216;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&#8217;. There
is a collection of synthetic/constructor operators, a collection of
analytic/selector partial operators and axioms that relate the two
collections.
</p>
<hr
 style="height: 2px; width: 50%; margin-left: 0px; margin-right: auto;"
 noshade="noshade">
<p>There is a collection of four
<i>synthetic</i>/<i>constructor</i> operators on expressions:</p>
<div style="margin-left: 40px;">
<p><big style="font-weight: bold; color: rgb(0, 0, 255);">&#9674;</big><b><i><sub>
L</sub></i></b> = <i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">holds</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">atm</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)</p>
</div>
<div style="margin-left: 40px;">
<p><big style="font-weight: bold; color: rgb(0, 0, 255);">&not;</big><b><i><sub>L</sub></i></b>
= <i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">neg</span></i>(<b><i>L</i></b>)&nbsp;:
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)</p>
</div>
<div style="margin-left: 40px;">
<p><small><span style="font-family: arial; color: rgb(0, 0, 255);">&#923;</span></small><b>
<i><sub>L</sub></i></b> = <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">conj</span></i>(<b><i>L</i></b>)&nbsp;:
<span style="font-family: arial; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)</p>
</div>
<div style="margin-left: 40px;">
<p><span style="color: rgb(0, 0, 255);">&#8707;</span><b><i><sub>L</sub></i></b>
=
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">quant</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">case</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)</p>
</div>
<p style="text-align: justify;">where '<big
 style="font-weight: bold; color: rgb(0, 0, 255);">&#9674;</big><b><i><sub>
L</sub></i></b>((<i>R</i>,&nbsp;&#945;))&#8217; constructs the
atomic expression of an arbitrary atom
(<i>R</i>,&nbsp;&#945;)&nbsp;<small>&#8712;</small> <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">atm</span></i>(<b><i>L</i></b>) =
<big><big>&#8746;</big></big><sub><i>X</i><small>&#8712;</small><i
 style="font-family: arial; font-weight: bold; color: rgb(0, 0, 255);">
var</i>(<b><i>L</i></b>)</sub> <i
 style="font-weight: bold; color: rgb(0, 0, 255); font-family: arial;">rel</i>(<b>
<i>L</i></b>)(<i>X</i>)&#8201;&times;<i
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">vrtn</i>(<b>
<i>L</i></b>)<small><i><sup>X</sup></i></small> consisting of an
<i>X</i>-ary relation symbol <i>R</i> <small>&#8712;</small>
<i style="font-weight: bold; color: rgb(0, 0, 255); font-family: arial;">rel</i>(<b>
<i>L</i></b>)(<i>X</i>) and a variation &#945;
<small>&#8712;</small> <i
 style="font-family: arial; font-weight: bold; color: rgb(255, 0, 0);">vrtn</i>(<b>
<i>L</i></b>)<small><i><sup>X</sup></i></small> with index
<i>X</i>, &#8216;<big style="font-weight: bold; color: rgb(0, 0, 255);">&not;</big><b><i><sub>L</sub></i></b>(&#966;)&#8217;
constructs the negation of an arbitrary <b><i>L</i></b>-expression
&#966; <small>&#8712;</small> <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>),
&#8216;<small><span style="font-family: arial; color: rgb(0, 0, 255);">&#923;</span></small><b>
<i><sub>L</sub></i></b>({&#966;<sub>1</sub>,&nbsp;&#966;<sub>2</sub>,&nbsp;&#8230;,&nbsp;&#966;<i>
<sub>n</sub></i>})&#8217; constructs the conjunction of an
arbitrary subset of <b><i>L</i></b>-expressions
{&#966;<sub>1</sub>,&nbsp;&#966;<sub>2</sub>,&nbsp;&#8230;,&nbsp;&#966;<i>
<sub>n</sub></i>}&nbsp;<small>&#8712;</small>&nbsp;<span
 style="font-family: arial; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>),
and &#8216;<span style="color: rgb(0, 0, 255);">&#8707;</span><b><i><sub>L</sub></i></b>((&#966;,&nbsp;<i>
x</i>))&#8217; constructs the existential quantification of an
arbitrary expression case
(&#966;,&nbsp;<i>x</i>)&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">case</span></i>(<b><i>L</i></b>)&nbsp;&#8838;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&times;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">var</span></i>(<b><i>L</i></b>)
consisting of an arbitrary <b><i>L</i></b>-expression
&#966;&nbsp;&#8712;&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>) and a
variable <i>x</i>&nbsp;&#8712;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">var</span></i>(<b><i>L</i></b>) with
<i>x</i>&nbsp;&#8712;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">arity</span></i>(<b><i>L</i></b>)(&#966;).
The four synthetic/constructor operators are individually injective
and jointly surjective.</p>
<hr
 style="height: 2px; width: 50%; margin-left: 0px; margin-right: auto;"
 noshade="noshade">
<p style="text-align: justify;">There is a collection of <i>analytic</i>/<i>selector</i>
operators on expressions, with the four subgroup clusters in
one-one correspondence with the four synthetic/constructor
operators (their inverses):</p>
<div style="margin-left: 40px;">
<p><i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-atm</span></i>(<b><i>L</i></b>)&nbsp;&#8838;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)<br>
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">atm</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">atm</span></i>(<b><i>L</i></b>)<br>
[<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">rel</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">rel</span></i>(<b><i>L</i></b>)(<i>X</i>)
for
<i>X</i>&nbsp;&#8712; <span
 style="font-family: arial; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">var</span></i>(<b><i>L</i></b>),
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">vrtn</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(255, 0, 0);">
<span style="font-family: Arial;">vrtn</span></i>(<b><i>L</i></b>)<small><i><sup>
X</sup></i></small> for <i>X</i>&nbsp;&#8712; <span
 style="font-family: arial; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">var</span></i>(<b><i>L</i></b>)]</p>
</div>
<div style="margin-left: 40px;">
<p><i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-neg</span></i>(<b><i>L</i></b>)&nbsp;&#8838;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)<br>
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)</p>
</div>
<div style="margin-left: 40px;">
<p><i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-conj</span></i>(<b><i>L</i></b>)&nbsp;&#8838;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)<br>
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">subset</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;
<span style="font-family: arial; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)</p>
</div>
<div style="margin-left: 40px;">
<p><i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-quant</span></i>(<b><i>L</i></b>)&nbsp;&#8838;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)<br>
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">case</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">case</span></i>(<b><i>L</i></b>)<br>
[<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>),
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">var</span></i>(<b><i>L</i></b>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)&nbsp;&#8594;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">var</span></i>(<b><i>L</i></b>)]</p>
</div>
<hr
 style="height: 2px; width: 50%; margin-left: 0px; margin-right: auto;"
 noshade="noshade">
<p>These operators satisfy the defining FOL expression abstract
syntax (abstract datatype semantics).</p>
<h5>Atomic</h5>
<div style="margin-left: 40px;">&#8704;(<span style="font-style: italic;">X</span>:&nbsp;<span
 style="font-weight: bold; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">var</span></i>(<b><i>L</i></b>),
<i>R</i>&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">rel</span></i>(<b><i>L</i></b>)(<i>X</i>),&nbsp;&#945;&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">vrtn</span></i>(<b><i>L</i></b>)<i><sup>X</sup></i>)</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-atm</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">holds</span></i>(<b><i>L</i></b>)(<i>R</i>,&nbsp;&#945;))</div>
<div style="margin-left: 80px;">&amp;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">rel</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">holds</span></i>(<b><i>L</i></b>)(<i>R</i>,&nbsp;&#945;))
= <span style="font-style: italic;">R</span></div>
<div style="margin-left: 80px;">&amp;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">vrtn</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">holds</span></i>(<b><i>L</i></b>)(<i>R</i>,&nbsp;&#945;))
= &#945;)</div>
<p style="text-align: justify;">which states that any FOL expression
constructed by the holds
operator is atomic and is decomposable into the original relation
symbol and variation.</p>
<div style="margin-left: 40px;">&#8704;(&#966;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-atm</span></i>(<b><i>L</i></b>)(&#966;)
&#8658; (<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">holds</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">rel</span></i>(<b><i>L</i></b>)(&#966;),
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">vrtn</span></i>(<b><i>L</i></b>)(&#966;)) =
&#966;))</div>
<p>which states that every atomic FOL expression is constructible
using the holds operator on its component relation and
variation.</p>
<h5>Negative</h5>
<div style="margin-left: 40px;">
&#8704;(&#968;&nbsp;:&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-neg</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">neg</span></i>(<b><i>L</i></b>)(&#968;))</div>
<div style="margin-left: 80px;">&amp;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">neg</span></i>(<b><i>L</i></b>)(&#968;) =
&#968;)</div>
<p>which states that any FOL expression constructed by the negation
operator is negative and is decomposable into the original
<b><i>L</i></b>-expression
&#968;&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>).</p>
<div style="margin-left: 40px;">
&#8704;(&#966;&nbsp;:&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-neg</span></i>(<b><i>L</i></b>)(&#966;)
&#8658; (<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">neg</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)(&#966;)) =
&#966;))</div>
<p>which states that every negative expression is constructible
using the negation operator on the underlying expression.</p>
<h5>Conjunctive</h5>
<div style="margin-left: 40px;">
&#8704;(&#934;&nbsp;:&nbsp;<span style="font-family: arial; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-conj</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">conj</span></i>(<b><i>L</i></b>)(&#934;))</div>
<div style="margin-left: 80px;">&amp;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">subset</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">conj</span></i>(<b><i>L</i></b>)(&#934;) =
&#934;)</div>
<p style="text-align: justify;">which states that any FOL expression
constructed by the
conjunction operator is conjunctive and is decomposable into the
original <b><i>L</i></b>-expression subset &#934;
<small>&#8712;</small> <span
 style="font-family: arial; color: rgb(0, 0, 255);">&#8472;</span><i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>).</p>
<div style="margin-left: 40px;">
&#8704;(&#966;&nbsp;:&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-conj</span></i>(<b><i>L</i></b>)(&#966;)
&#8658; (<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">conj</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">subset</span></i>(<b><i>L</i></b>)(&#966;)) =
&#966;))</div>
<p>which states that every conjunctive expression is constructible
using the conjunction operator on the underlying expression
subset.</p>
<h5>Existential Quantification</h5>
<div style="margin-left: 40px;">
&#8704;((&#966;,&nbsp;<i>x</i>)&nbsp;:&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">case</span></i>(<b><i>L</i></b>))</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-quant</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">quant</span></i>(<b><i>L</i></b>)((&#966;,&nbsp;<i>
x</i>))</div>
<div style="margin-left: 80px;">&amp;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">quant</span></i>(<b><i>L</i></b>)((&#966;,&nbsp;<i>
x</i>)))&nbsp;=&nbsp;&#966;)</div>
<div style="margin-left: 80px;">&amp;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">var</span></i>(<b><i>L</i></b>)(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">quant</span></i>(<b><i>L</i></b>)((&#966;,&nbsp;<i>
x</i>)) = <i>x</i>)</div>
<p style="text-align: justify;">
which states that any expression constructed by the existential
uantification operator is existentially quantified and is decomposable
into the original <b><i>L</i></b>-case (&#966;,&nbsp;<i>x</i>)&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">case</span></i>(<b><i>L</i></b>)
consisting of an arbitrary <b><i>L</i></b>-expression &#966;&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>) and a
variable <i>x</i>&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">var</span></i>(<b><i>L</i></b>) with <i>x</i>&nbsp;<small>&#8712;</small>&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">arity</span></i>(<b><i>L</i></b>)(&#966;).
</p>
<div style="margin-left: 40px;">
&#8704;(&#966;&nbsp;:&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))<br>
<div style="margin-left: 40px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-quant</span></i>(<b><i>L</i></b>)(&#966;) &#8658; (<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">quant</span></i>(<b><i>L</i></b>)((<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>)(&#966;), <i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">var</span></i>(<b><i>L</i></b>)(&#966;))) = &#966;))
</div>
</div>
<p>
which states that every existential expression is constructible
using the existential quantification operator on its component
expression and bound variable.
</p>
<h5>Partition</h5>
<p style="text-align: justify;">
Finally, following John McCarthy we require that each expression
satisfy exactly one of these Boolean predicates. That is, that an
expression is either (1) an atom, (2) a negation, (3) a conjunction
or (4) an existential quantification,
</p>
<div style="margin-left: 40px;">
&#8704;(&#966;&nbsp;:&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))<br>
</div>
<div style="margin-left: 80px;">(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-atm</span></i>(<b><i>L</i></b>)(&#966;) |
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-neg</span></i>(<b><i>L</i></b>)(&#966;) |
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-conj</span></i>(<b><i>L</i></b>)(&#966;) |
<i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-quant</span></i>(<b><i>L</i></b>)(&#966;))
</div>
<p>
but not any two such things (there are 6 possibilities).
</p>
<div style="margin-left: 40px;">
&#8704;(&#966;&nbsp;:&nbsp;<i style="font-weight: bold; color: rgb(0, 0, 255);">
<span style="font-family: Arial;">expr</span></i>(<b><i>L</i></b>))<br>
<div style="margin-left: 40px;">(&#8764;(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-atm</span></i>(<b><i>L</i></b>)(&#966;)
&amp; <i style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-neg</span></i>(<b><i>L</i></b>)(&#966;))<br>
</div>
<div style="margin-left: 40px;">&#8230;&nbsp;&amp; &#8764;(<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-conj</span></i>(<b><i>L</i></b>)(&#966;)&nbsp;&amp;&nbsp;<i
 style="font-weight: bold; color: rgb(0, 0, 255);"><span
 style="font-family: Arial;">is-quant</span></i>(<b><i>L</i></b>)(&#966;)))
</div>
</div>
<p style="text-align: justify;">That is, that those four domains
partition the set of expressions.
Actually, these two axioms are embedded within the fixpoint solution
and we are just making them explicit here.
</p>
<br>
<hr
 style="height: 2px; width: 100%; margin-left: 0px; margin-right: auto;"
 noshade="noshade">
<p style="text-align: justify;">The SUO-IFF documents contain
many unicode characters, and so require a recent browser. But even some
recent browsers fail to render SUO-IFF properly. You can test your
browser <a href="http://plato.stanford.edu/symbols/entities.html">here</a>.
</p>
<p><a href="http://validator.w3.org/check/referer"><img border="0"
 src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01!"
 height="31" width="88"></a>
</p>
</body>
</html>
