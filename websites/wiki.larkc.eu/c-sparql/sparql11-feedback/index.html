<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta name="robots" content="index,nofollow">

<title>c-sparql/sparql11-feedback - LarKC Wiki</title>
<script type="text/javascript" src="/moin_static160/common/js/common.js"></script>

<script type="text/javascript">
<!--
var search_hint = "Search";
//-->
</script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/moin_static160/modern/css/common.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="screen" href="/moin_static160/modern/css/screen.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="print" href="/moin_static160/modern/css/print.css">
<link rel="stylesheet" type="text/css" charset="utf-8" media="projection" href="/moin_static160/modern/css/projection.css">

<!-- css only for MSIE browsers -->
<!--[if IE]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/moin_static160/modern/css/msie.css">
<![endif]-->





<link rel="Start" href="/FrontPage">
<link rel="Alternate" title="Wiki Markup" href="/c-sparql/sparql11-feedback?action=raw">
<link rel="Alternate" media="print" title="Print View" href="/c-sparql/sparql11-feedback?action=print">
<link rel="Up" href="/c-sparql">
<link rel="Search" href="/FindPage">
<link rel="Index" href="/TitleIndex">
<link rel="Glossary" href="/WordIndex">
<link rel="Help" href="/HelpOnFormatting">
</head>

<body  lang="en" dir="ltr">

<div id="header">
<div id="logo"><a href="/FrontPage"><img src="http://wiki.larkc.eu/static/larkc-logo.jpg" alt="LarKC logo"></a></div>

<form id="searchform" method="get" action="/c-sparql/sparql11-feedback">
<div>
<input type="hidden" name="action" value="fullsearch">
<input type="hidden" name="context" value="180">
<label for="searchinput">Search:</label>
<input id="searchinput" type="text" name="value" value="" size="20"
    onfocus="searchFocus(this)" onblur="searchBlur(this)"
    onkeyup="searchChange(this)" onchange="searchChange(this)" alt="Search">
<input id="titlesearch" name="titlesearch" type="submit"
    value="Titles" alt="Search Titles">
<input id="fullsearch" name="fullsearch" type="submit"
    value="Text" alt="Search Full Text">
</div>
</form>
<script type="text/javascript">
<!--// Initialize search form
var f = document.getElementById('searchform');
f.getElementsByTagName('label')[0].style.display = 'none';
var e = document.getElementById('searchinput');
searchChange(e);
searchBlur(e);
//-->
</script>

<ul id="username"><li><a href="/c-sparql/sparql11-feedback?action=login" id="login" rel="nofollow">Login</a></li></ul>
<div id="locationline">


<ul id="pagelocation">
<li><a href="/c-sparql">c-sparql</a></li><li><a class="backlink" href="/c-sparql/sparql11-feedback?action=fullsearch&amp;context=180&amp;value=linkto%3A%22c-sparql/sparql11-feedback%22" rel="nofollow" title="Click to do a full-text search for this title">sparql11-feedback</a></li>
</ul>

</div>


<ul id="navibar">
<li class="wikilink"><a href="/RecentChanges">RecentChanges</a></li><li class="wikilink"><a href="/FindPage">FindPage</a></li><li class="wikilink"><a href="/HelpContents">HelpContents</a></li><li class="wikilink"><a href="/LarkcProject">LarkcProject</a></li><li class="current"><a href="/c-sparql/sparql11-feedback">sparql11-feedback</a></li>
</ul>

<div id="pageline"><hr style="display:none;"></div>

<ul class="editbar"><li><span class="disabled">Immutable Page</span></li><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbinfo" href="/c-sparql/sparql11-feedback?action=info" rel="nofollow">Info</a></li><li><a class="nbattachments" href="/c-sparql/sparql11-feedback?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="/c-sparql/sparql11-feedback">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="raw">Raw Text</option>
<option value="print">Print View</option>
<option value="RenderAsDocbook">Render as Docbook</option>
<option value="refresh">Delete Cache</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="SpellCheck">Check Spelling</option>
<option value="LikePages">Like Pages</option>
<option value="LocalSiteMap">Local Site Map</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
<option value="show" disabled class="disabled">Package Pages</option>
<option value="SyncPages">Sync Pages</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="Load">Load</option>
<option value="Save">Save</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

</div>

<div id="page" lang="en" dir="ltr">
<div dir="ltr" id="content" lang="en"><span class="anchor" id="top"></span>
<span class="anchor" id="line-1"></span><p class="line867">
<h1 id="FeedbacksonSPARQL1.1SupportForAggregates">Feedbacks on SPARQL 1.1 Support For Aggregates</h1>
<span class="anchor" id="line-2"></span><span class="anchor" id="line-3"></span><p class="line867"><strong>Authors</strong>: Davide Francesco Barbieri, Daniele Braga, Stefano Ceri, Emanuele Della Valle, Michael Grossniklaus <span class="anchor" id="line-4"></span><span class="anchor" id="line-5"></span><p class="line867"><strong>Date</strong>: 5.2.2010 <span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span><p class="line867">
<h2 id="Introduction">Introduction</h2>
<span class="anchor" id="line-8"></span><span class="anchor" id="line-9"></span><p class="line874">In this wiki page, we [1] would like to comment on the support for aggregates in SPARQL 1.1. In the last two years we have been working on an extension to SPARQL for continuous querying over streams of RDF (namely C-SPARQL [2]). Central to stream processing is support for aggregates. For this reason we have defined and implemented  [3] our own support for aggregates in SPARQL which is orthogonal to the other stream processing  features of C-SPARQL. We believe such extension can be of general interest for SPARQL 1.1 WG. <span class="anchor" id="line-10"></span><span class="anchor" id="line-11"></span><p class="line874">In the rest of the mail we first introduce support for aggregates in C-SPARQL, then we compare C-SPARQL and SPARQL 1.1 support for aggregates. We show that: <span class="anchor" id="line-12"></span><ol type="1"><li>C-SPARQL syntax for aggregates appears more compact and handy than the SPARQL 1.1 one, <span class="anchor" id="line-13"></span></li><li>all SPARQL 1.1 queries with aggregates can be expressed in C-SPARQL, and <span class="anchor" id="line-14"></span></li><li>there are queries that can be expressed in C-SPARQL but it is unclear whether they can be expressed in SPARQL 1.1. <span class="anchor" id="line-15"></span><span class="anchor" id="line-16"></span></li></ol><p class="line867">
<h2 id="SupportForAggregatesInC-SPARQL">Support For Aggregates In C-SPARQL</h2>
<span class="anchor" id="line-17"></span><span class="anchor" id="line-18"></span><p class="line874">Aggregation clauses in C-SPARQL are added at the end of the query, and have the following syntax: <span class="anchor" id="line-19"></span><span class="anchor" id="line-20"></span><p class="line867"><span class="anchor" id="line-21"></span><span class="anchor" id="line-22"></span><span class="anchor" id="line-23"></span><span class="anchor" id="line-24"></span><pre> AggregateClause --&gt; ( "AGGREGATE {(" var "," Function "," Group ")" [Filter] "}" )*
 Function --&gt; "COUNT" | "SUM" | "AVG" | "MIN" | "MAX"
 Group --&gt; var | "{" var ( "," var )* "}"</pre><span class="anchor" id="line-25"></span><span class="anchor" id="line-26"></span><p class="line874">Every aggregation clause has the following three parts: <span class="anchor" id="line-27"></span><ul><li>The first part is a new variable (i.e., a variable not in the WHERE clause or in other aggregation clauses). <span class="anchor" id="line-28"></span></li><li>The second part is an aggregation function (one of: COUNT, MAX, MIN, SUM, AVG); COUNT may have no argument, while the other functions take one of the variables occurring in the WHERE clause as argument. <span class="anchor" id="line-29"></span></li><li>The third part is a set of one or more variables, which are chosen among those occurring in the WHERE clause.These variables express the grouping criteria. <span class="anchor" id="line-30"></span><span class="anchor" id="line-31"></span></li></ul><p class="line874">Every clause may also have an optional fourth part, a FILTER clause. <span class="anchor" id="line-32"></span><span class="anchor" id="line-33"></span><p class="line867">
<h2 id="ExampleOfSimpleSupportForAggregatesInC-SPARQLAndSPARQL1.1">Example Of Simple Support For Aggregates In C-SPARQL And SPARQL 1.1</h2>
<span class="anchor" id="line-34"></span><span class="anchor" id="line-35"></span><p class="line874">Data: <span class="anchor" id="line-36"></span><span class="anchor" id="line-37"></span><p class="line867"><span class="anchor" id="line-38"></span><span class="anchor" id="line-39"></span><span class="anchor" id="line-40"></span><span class="anchor" id="line-41"></span><span class="anchor" id="line-42"></span><pre>@prefix : &lt;http://books.example/&gt; .

:auth1  :name "Alice Foo", :writesBook :book1; :book2 .
:auth2  :name "Bob Bar", :writesBook :book2 .</pre><span class="anchor" id="line-43"></span><span class="anchor" id="line-44"></span><p class="line874">The following query counts the number of books written by an author and returns the name and the number of books. <span class="anchor" id="line-45"></span><span class="anchor" id="line-46"></span><p class="line867"><span class="anchor" id="line-47"></span><span class="anchor" id="line-48"></span><span class="anchor" id="line-49"></span><span class="anchor" id="line-50"></span><span class="anchor" id="line-51"></span><span class="anchor" id="line-52"></span><span class="anchor" id="line-53"></span><pre>SELECT ?name ?book ?numberOfBooks
WHERE {
    ?auth :name ?name .
    ?auth :writesBook ?book .
}
AGGREGATE { (?numberOfBooks, COUNT, {?auth} ) }</pre><span class="anchor" id="line-54"></span><span class="anchor" id="line-55"></span><p class="line874">The semantics of a query containing aggregates consists in adding new variable bindings computed by the WHERE clause to the existing regular variable bindings. For each of the new variables introduced by the AGGREGATE clauses, one new variable binding is added. The query result constructed in this way may be further filtered by a standard FILTER clause, which may refer to all the variables introduced in the WHERE and AGGREGATE clauses. <span class="anchor" id="line-56"></span><span class="anchor" id="line-57"></span><p class="line874">Our C-SPARQL extension is based on the conviction that in the context of RDF, knowledge should be extended rather than shrunk. Therefore, we propose to generate additional variable bindings and use them to annotate any existing variable binding that contributed to the aggregate value. <span class="anchor" id="line-58"></span><span class="anchor" id="line-59"></span><p class="line874">Results: <span class="anchor" id="line-60"></span><span class="anchor" id="line-61"></span><p class="line867"><span class="anchor" id="line-62"></span><span class="anchor" id="line-63"></span><span class="anchor" id="line-64"></span><span class="anchor" id="line-65"></span><span class="anchor" id="line-66"></span><pre>?name       | ?numberOfBooks
------------------------------
"Alice Foo" |            "2"
"Bob Bar"   |            "1"</pre><span class="anchor" id="line-67"></span><span class="anchor" id="line-68"></span><p class="line874">This is in contrast to the conventional SQL grouping semantics that replaces all aggregated tuples with a single tuple representing the aggregate value. In this respect, we believe that our approach to aggregation is more aligned with the baseline of the SPARQL semantics. <span class="anchor" id="line-69"></span><span class="anchor" id="line-70"></span><p class="line874">Judging fro the example in Section 10 of the SPARQL 1.1 draft, the query above can be expressed in SPARQL 1.1 in the following way: <span class="anchor" id="line-71"></span><span class="anchor" id="line-72"></span><p class="line867"><span class="anchor" id="line-73"></span><span class="anchor" id="line-74"></span><span class="anchor" id="line-75"></span><span class="anchor" id="line-76"></span><span class="anchor" id="line-77"></span><span class="anchor" id="line-78"></span><span class="anchor" id="line-79"></span><span class="anchor" id="line-80"></span><span class="anchor" id="line-81"></span><span class="anchor" id="line-82"></span><span class="anchor" id="line-83"></span><span class="anchor" id="line-84"></span><pre>SELECT ?name ?numberOfBooks
WHERE {
     ?auth :name ?name .     
     {
             SELECT ?auth (COUNT(?book) AS ?numberOfBooks)
             WHERE {
                     ?auth :writesBook ?book .
             }
             GROUP BY ?auth
     }
}</pre><span class="anchor" id="line-85"></span><p class="line874">In the C-SPARQL language all the variables used in AGGREGATE clauses must appear also in the SELECT clause, since aggregation happens after standard SPARQL query evaluation. In SPARQL 1.1 the constraint is not specified. <span class="anchor" id="line-86"></span><span class="anchor" id="line-87"></span><p class="line874">Wrapping up, queries of this kind can be expressed both in SPARQL 1.1 and C-SPARQL, but C-SPARQL syntax appears more compact and handy. <span class="anchor" id="line-88"></span><span class="anchor" id="line-89"></span><p class="line867">
<h2 id="AggregatesSupportedInSPARQL1.1AreAlsoSupportedInC-SPARQL">Aggregates Supported In SPARQL 1.1 Are Also Supported In C-SPARQL</h2>
<span class="anchor" id="line-90"></span><span class="anchor" id="line-91"></span><p class="line874">Given the current SPARQL 1.1 support for aggregates, it appears that all SPARQL 1.1 queries with aggregates can be expressed in C-SPARQL. <span class="anchor" id="line-92"></span><span class="anchor" id="line-93"></span><p class="line874">For instance, the following query is the example of SPARQL 1.1 support for aggregates appearing in Section 9 of the current draft. <span class="anchor" id="line-94"></span><span class="anchor" id="line-95"></span><p class="line867"><span class="anchor" id="line-96"></span><span class="anchor" id="line-97"></span><span class="anchor" id="line-98"></span><span class="anchor" id="line-99"></span><span class="anchor" id="line-100"></span><span class="anchor" id="line-101"></span><span class="anchor" id="line-102"></span><span class="anchor" id="line-103"></span><span class="anchor" id="line-104"></span><span class="anchor" id="line-105"></span><pre>PREFIX  &lt;http://books.example/&gt;
SELECT (SUM(?lprice) AS ?totalPrice)
WHERE {
  ?org :affiliates ?auth .
  ?auth :writesBook ?book .
  ?book :price ?lprice .
}
GROUP BY ?org
HAVING (SUM(?lprice) &gt; 10)</pre><span class="anchor" id="line-106"></span><span class="anchor" id="line-107"></span><p class="line874">Such a query in C-SPARQL will be written as follows. <span class="anchor" id="line-108"></span><span class="anchor" id="line-109"></span><p class="line867"><span class="anchor" id="line-110"></span><span class="anchor" id="line-111"></span><span class="anchor" id="line-112"></span><span class="anchor" id="line-113"></span><span class="anchor" id="line-114"></span><span class="anchor" id="line-115"></span><span class="anchor" id="line-116"></span><span class="anchor" id="line-117"></span><span class="anchor" id="line-118"></span><pre>PREFIX  &lt;http://books.example/&gt;
SELECT ?totalPrice
WHERE {
  ?org :affiliates ?auth .
  ?auth :writesBook ?book .
  ?book :price ?lprice .
}
AGGREGATE { (?totalPrice, SUM(?lprice), {?org}) FILTER ( ?totalPrice &gt; 10) }</pre><span class="anchor" id="line-119"></span><span class="anchor" id="line-120"></span><p class="line867">
<h2 id="QueriesThatCanBeExpressedInC-SPARQLButItIsUnclearWhetherTheyCanBeExpressedInSPARQL1.1">Queries That Can Be Expressed In C-SPARQL But It Is Unclear Whether They Can Be Expressed In SPARQL 1.1</h2>
<span class="anchor" id="line-121"></span><span class="anchor" id="line-122"></span><p class="line874">Given  the current SPARQL 1.1 support for aggregates, it is unclear whether the following C-SPARQL queries can be expressed in SPARQL 1.1 <span class="anchor" id="line-123"></span><span class="anchor" id="line-124"></span><p class="line874">Query: the average number of books written by authors that wrote at least 5 books. <span class="anchor" id="line-125"></span><span class="anchor" id="line-126"></span><p class="line867"><span class="anchor" id="line-127"></span><span class="anchor" id="line-128"></span><span class="anchor" id="line-129"></span><span class="anchor" id="line-130"></span><span class="anchor" id="line-131"></span><span class="anchor" id="line-132"></span><span class="anchor" id="line-133"></span><span class="anchor" id="line-134"></span><pre>SELECT ?name ?book ?numberOfBooks ?averageNumberOfBooks
WHERE {
    ?auth :name ?name .
    ?auth :wrote ?book .
}
AGGREGATE { (?numberOfBooks, COUNT, {?auth} ) FILTER (?numberOfBooks &gt; 5) }
AGGREGATE { (?averageNumberOfBooks, AVG, {?numberOfBooks} ) }</pre><span class="anchor" id="line-135"></span><span class="anchor" id="line-136"></span><p class="line874">A possible way to express it in SPARQL 1.1 is illustrated hereafter, but no examples in the current draft show that this is possible. <span class="anchor" id="line-137"></span><span class="anchor" id="line-138"></span><p class="line867"><span class="anchor" id="line-139"></span><span class="anchor" id="line-140"></span><span class="anchor" id="line-141"></span><span class="anchor" id="line-142"></span><span class="anchor" id="line-143"></span><span class="anchor" id="line-144"></span><span class="anchor" id="line-145"></span><span class="anchor" id="line-146"></span><span class="anchor" id="line-147"></span><span class="anchor" id="line-148"></span><span class="anchor" id="line-149"></span><span class="anchor" id="line-150"></span><span class="anchor" id="line-151"></span><pre>SELECT ?name ?surname ?book ?numberOfBooks (AVG(?numberOfBooks) AS ?averageNumberOfBooks)
WHERE {
     ?auth :hasSurname ?surname .
     ?auth :hasName ?name .
     {
             SELECT ?auth (COUNT(?book) AS ?numberOfBooks)
             WHERE {
                     ?auth :wrote ?book .
    }
             GROUP BY ?auth
            HAVING (?numberOfBooks &gt; 5)
}</pre><span class="anchor" id="line-152"></span><span class="anchor" id="line-153"></span><p class="line874">More complex sequences of aggregation are supported in C-SPARQL, such as <span class="anchor" id="line-154"></span><ul><li>computing the number of books per author <span class="anchor" id="line-155"></span></li><li>keeping only the authors who have published at least 5 books <span class="anchor" id="line-156"></span></li><li>computing the total number of books grouping by affiliation <span class="anchor" id="line-157"></span></li><li>filtering the affiliation with less than 50 books published <span class="anchor" id="line-158"></span><span class="anchor" id="line-159"></span></li></ul><p class="line867"><span class="anchor" id="line-160"></span><span class="anchor" id="line-161"></span><span class="anchor" id="line-162"></span><span class="anchor" id="line-163"></span><span class="anchor" id="line-164"></span><span class="anchor" id="line-165"></span><span class="anchor" id="line-166"></span><span class="anchor" id="line-167"></span><span class="anchor" id="line-168"></span><span class="anchor" id="line-169"></span><pre>SELECT ?name ?surname ?book ?numberOfBooks ?averageNumberOfBooks
WHERE {
    ?auth :name ?name .
    ?auth :surname ?surname .
    ?auth :wrote ?book .
    ?auth :affiliated ?organization .
}
AGGREGATE { (?numberOfBooks, COUNT, {?auth} ) FILTER (?numberOfBooks &gt; 5) }
AGGREGATE { (?affiliationBooks, SUM(?numberOfBooks), {?organization} ) FILTER (?affiliationBooks &gt; 50)}</pre><span class="anchor" id="line-170"></span><span class="anchor" id="line-171"></span><p class="line874">A possible way to express it in SPARQL 1.1 is illustrated hereafter, but as above no examples in the current draft show that this is possible. <span class="anchor" id="line-172"></span><span class="anchor" id="line-173"></span><p class="line867"><span class="anchor" id="line-174"></span><span class="anchor" id="line-175"></span><span class="anchor" id="line-176"></span><span class="anchor" id="line-177"></span><span class="anchor" id="line-178"></span><span class="anchor" id="line-179"></span><span class="anchor" id="line-180"></span><span class="anchor" id="line-181"></span><span class="anchor" id="line-182"></span><span class="anchor" id="line-183"></span><span class="anchor" id="line-184"></span><span class="anchor" id="line-185"></span><span class="anchor" id="line-186"></span><span class="anchor" id="line-187"></span><span class="anchor" id="line-188"></span><span class="anchor" id="line-189"></span><span class="anchor" id="line-190"></span><span class="anchor" id="line-191"></span><span class="anchor" id="line-192"></span><span class="anchor" id="line-193"></span><pre>SELECT ?name ?surname ?book ?numberOfBooks
WHERE {
   ?auth :hasSurname ?surname .
   ?auth :hasName ?name .
   {
    SELECT ?affiliation (SUM(?numberOfBooks) as ?affiliationBooks)
    WHERE {
     ?auth :affiliated ?organization .
     {
      SELECT ?auth (COUNT(?book) AS ?numberOfBooks)
      WHERE {
       ?auth :wrote ?book .
      }
      GROUP BY ?auth
     HAVING (?numberOfBooks &gt; 5)
    }
    GROUP BY ?organization
   HAVING (?affiliationBooks &gt; 50)
   }</pre><span class="anchor" id="line-194"></span><span class="anchor" id="line-195"></span><p class="line874">In C-SPARQL, evaluation of multiple aggregation with filtering clauses is possible. For instance, one can ask for the research topics for which the Italian authors are more than the Swiss ones. <span class="anchor" id="line-196"></span><span class="anchor" id="line-197"></span><p class="line867"><span class="anchor" id="line-198"></span><span class="anchor" id="line-199"></span><span class="anchor" id="line-200"></span><span class="anchor" id="line-201"></span><span class="anchor" id="line-202"></span><span class="anchor" id="line-203"></span><span class="anchor" id="line-204"></span><span class="anchor" id="line-205"></span><span class="anchor" id="line-206"></span><span class="anchor" id="line-207"></span><pre>SELECT ?topic ?numberOfSwissAuthors ?numberOfItalianAuthors
WHERE {
    ?auth :name ?name .
    ?auth :wrote ?book .
    ?book :topic ?topic .
    ?auth :hasNationality ?nat .
}
AGGREGATE { FILTER(?nat = 'IT') (?numberOfItalianAuthors, COUNT, {?topic} ) }
AGGREGATE { FILTER(?nat = 'CH') (?numberOfSwissAuthors, COUNT, {?topic} ) FILTER(?numberOfItalianAuthors&gt;?numberOfSwissAuthors)}</pre><span class="anchor" id="line-208"></span><span class="anchor" id="line-209"></span><p class="line874">Given the current draft of SPARQL 1.1, two alternative formulations appear possible, one using a FILTER and one using an HAVING. However, both require the SPARQL 1.1 engine to decide the order of execution, whereas in C-SPARQL the order is given explicitly. <span class="anchor" id="line-210"></span><span class="anchor" id="line-211"></span><p class="line874">SPARQL 1.1 version that uses the FILTER clause (see line 24): <span class="anchor" id="line-212"></span><span class="anchor" id="line-213"></span><p class="line867"><span class="anchor" id="line-214"></span><span class="anchor" id="line-215"></span><span class="anchor" id="line-216"></span><span class="anchor" id="line-217"></span><span class="anchor" id="line-218"></span><span class="anchor" id="line-219"></span><span class="anchor" id="line-220"></span><span class="anchor" id="line-221"></span><span class="anchor" id="line-222"></span><span class="anchor" id="line-223"></span><span class="anchor" id="line-224"></span><span class="anchor" id="line-225"></span><span class="anchor" id="line-226"></span><span class="anchor" id="line-227"></span><span class="anchor" id="line-228"></span><span class="anchor" id="line-229"></span><span class="anchor" id="line-230"></span><span class="anchor" id="line-231"></span><span class="anchor" id="line-232"></span><span class="anchor" id="line-233"></span><span class="anchor" id="line-234"></span><span class="anchor" id="line-235"></span><span class="anchor" id="line-236"></span><span class="anchor" id="line-237"></span><span class="anchor" id="line-238"></span><span class="anchor" id="line-239"></span><pre> 1. SELECT ?topic ?numberOfSwissAuthors ?numberOfItalianAuthors
 2. WHERE {
 3.     ?auth :hasName ?name .
 4.     {
 5.             SELECT ?auth (COUNT(?book) AS ?numberOfSwissAuthors)
 6.             WHERE {
 7.                     ?auth :wrote ?book .
 8.                     ?book :topic ?topic .
 9.                     ?auth :hasNationality ?nat .
10.                     FILTER(?nat = 'CH') .
11.             }
12.             GROUP BY ?topic
13.     }
14.     {
15.             SELECT ?auth (COUNT(?book) AS ?numberOfItalianAuthors)
16.             WHERE {
17.                     ?auth :wrote ?book .
18.                     ?book :topic ?topic .
19.                     ?auth :hasNationality ?nat .
20.                     FILTER(?nat = 'IT') .
21.             }
22.             GROUP BY ?topic     
23.     }
24.     FILTER(?numberOfItalianAuthors&gt;?numberOfSwissAuthors)     
25. }</pre><span class="anchor" id="line-240"></span><span class="anchor" id="line-241"></span><p class="line874">SPARQL 1.1 version that uses the HAVING clause (see line 23): <span class="anchor" id="line-242"></span><span class="anchor" id="line-243"></span><p class="line867"><span class="anchor" id="line-244"></span><span class="anchor" id="line-245"></span><span class="anchor" id="line-246"></span><span class="anchor" id="line-247"></span><span class="anchor" id="line-248"></span><span class="anchor" id="line-249"></span><span class="anchor" id="line-250"></span><span class="anchor" id="line-251"></span><span class="anchor" id="line-252"></span><span class="anchor" id="line-253"></span><span class="anchor" id="line-254"></span><span class="anchor" id="line-255"></span><span class="anchor" id="line-256"></span><span class="anchor" id="line-257"></span><span class="anchor" id="line-258"></span><span class="anchor" id="line-259"></span><span class="anchor" id="line-260"></span><span class="anchor" id="line-261"></span><span class="anchor" id="line-262"></span><span class="anchor" id="line-263"></span><span class="anchor" id="line-264"></span><span class="anchor" id="line-265"></span><span class="anchor" id="line-266"></span><span class="anchor" id="line-267"></span><span class="anchor" id="line-268"></span><span class="anchor" id="line-269"></span><pre> 1. SELECT ?topic ?numberOfSwissAuthors ?numberOfItalianAuthors
 2. WHERE {
 3.     ?auth :hasName ?name .
 4.     {
 5.             SELECT ?auth (COUNT(?book) AS ?numberOfSwissAuthors)
 6.             WHERE {
 7.                     ?auth :wrote ?book .
 8.                     ?book :topic ?topic .
 9.                     ?auth :hasNationality ?nat .
10.                     FILTER(?nat = 'CH') .
11.             }
12.             GROUP BY ?topic
13.     }
14.     {
15.             SELECT ?auth (COUNT(?book) AS ?numberOfItalianAuthors)
16.             WHERE {
17.                     ?auth :wrote ?book .
18.                     ?book :topic ?topic .
19.                     ?auth :hasNationality ?nat .
20.                     FILTER(?nat = 'IT') .
21.             }
22.             GROUP BY ?topic   
23.             HAVING(?numberOfItalianAuthors&gt;?numberOfSwissAuthors)
24.     }    
25. }</pre><span class="anchor" id="line-270"></span><span class="anchor" id="line-271"></span><p class="line874">Therefore, we believe that there are queries that can be expressed in C-SPARQL but not in SPARQL 1.1. <span class="anchor" id="line-272"></span><span class="anchor" id="line-273"></span><p class="line867">
<h2 id="ComputingMultipleIndependentAggregatesAtTheSameTime">Computing Multiple Independent Aggregates At The Same Time</h2>
<span class="anchor" id="line-274"></span><span class="anchor" id="line-275"></span><p class="line874">As we explained in the introduction, C-SPARQL was explicitly designed for processing RDF streams. The transient nature of streams poses the requirement to compute multiple (possibly independent) aggregates at the same time in the same query, because assuring that two independent queries process exactly the same data is very difficult. Therefore, multiple independent aggregations are also allowed within the same C-SPARQL query, with different grouping criteria and different partitions over the same set of bindings, thus pushing the aggregation capabilities beyond those of SQL. <span class="anchor" id="line-276"></span><span class="anchor" id="line-277"></span><p class="line874">The following query counts the number of books written by an author, counts the number of authors per book and returns the name, the book, the number of books and the number of authors. <span class="anchor" id="line-278"></span><span class="anchor" id="line-279"></span><p class="line867"><span class="anchor" id="line-280"></span><span class="anchor" id="line-281"></span><span class="anchor" id="line-282"></span><span class="anchor" id="line-283"></span><span class="anchor" id="line-284"></span><span class="anchor" id="line-285"></span><span class="anchor" id="line-286"></span><span class="anchor" id="line-287"></span><pre>SELECT ?name ?book ?numberOfBooks ?numberOfAuthors
WHERE {
    ?auth :name ?name .
    ?auth :wrote ?book .
}
AGGREGATE { (?numberOfBooks, COUNT, {?auth} ) }
AGGREGATE { (?numberOfAuthors, COUNT, {?book} ) }</pre><span class="anchor" id="line-288"></span><span class="anchor" id="line-289"></span><p class="line874">Results: <span class="anchor" id="line-290"></span><span class="anchor" id="line-291"></span><span class="anchor" id="line-292"></span><span class="anchor" id="line-293"></span><span class="anchor" id="line-294"></span><span class="anchor" id="line-295"></span><span class="anchor" id="line-296"></span><pre>?name       | ?book | ?numberOfBooks | ?numberOfAuthors
---------------------------------------------------------
"Alice Foo" |    b1 |            "2" |              "1"
"Alice Foo" |    b2 |            "2" |              "2"
"Bob   Bar" |    b2 |            "1" |              "2"</pre><span class="anchor" id="line-297"></span><span class="anchor" id="line-298"></span><p class="line874">Judging from SPARQL 1.1 draft, the query above can be expressed in SPARQL 1.1 in the following way: <span class="anchor" id="line-299"></span><span class="anchor" id="line-300"></span><p class="line867"><span class="anchor" id="line-301"></span><span class="anchor" id="line-302"></span><span class="anchor" id="line-303"></span><span class="anchor" id="line-304"></span><span class="anchor" id="line-305"></span><span class="anchor" id="line-306"></span><span class="anchor" id="line-307"></span><span class="anchor" id="line-308"></span><span class="anchor" id="line-309"></span><span class="anchor" id="line-310"></span><span class="anchor" id="line-311"></span><span class="anchor" id="line-312"></span><span class="anchor" id="line-313"></span><span class="anchor" id="line-314"></span><span class="anchor" id="line-315"></span><span class="anchor" id="line-316"></span><span class="anchor" id="line-317"></span><span class="anchor" id="line-318"></span><span class="anchor" id="line-319"></span><span class="anchor" id="line-320"></span><pre>SELECT ?name ?surname ?book ?numberOfBooks ?numberOfAuthors
WHERE {
     ?auth :hasSurname ?surname .
     ?auth :hasName ?name .
     {
             SELECT ?auth (COUNT(?book) AS ?numberOfBooks)
             WHERE {
                     ?auth :wrote ?book .
             }
             GROUP BY ?auth
     }
     {
             SELECT  ?auth (COUNT(?auth) AS ?numberOfAuthors)
             WHERE {
                    ?auth :wrote ?book .
             }
             GROUP BY ?book
     }
}</pre><span class="anchor" id="line-321"></span><span class="anchor" id="line-322"></span><p class="line867">
<h2 id="Conclusion">Conclusion</h2>
<span class="anchor" id="line-323"></span><span class="anchor" id="line-324"></span><p class="line874">Clearly, the C-SPARQL notation is less cumbersome and more concise than the SPARQL 1.1 one. It is therefore, easier to express and understand aggregates in C-SPARQL than in the current draft of SPARQL 1.1, which we believe is an important factor in language design and adoption.  <span class="anchor" id="line-325"></span><span class="anchor" id="line-326"></span><span class="anchor" id="line-327"></span><p class="line867">
<h2 id="References">References</h2>
<span class="anchor" id="line-328"></span><span class="anchor" id="line-329"></span><p class="line862">[1] <a class="http" href="http://dbgroup.elet.polimi.it/">http://dbgroup.elet.polimi.it/</a> <span class="anchor" id="line-330"></span><span class="anchor" id="line-331"></span><p class="line862">[2] <a class="http" href="http://wiki.larkc.eu/c-sparql">http://wiki.larkc.eu/c-sparql</a> <span class="anchor" id="line-332"></span><span class="anchor" id="line-333"></span><p class="line862">[3] <a class="http" href="http://www.larkc.eu/wp-content/uploads/2008/01/larkc_d33-description-of-strategy-and-design-for-data-stream-management-approaches_final.pdf">http://www.larkc.eu/wp-content/uploads/2008/01/larkc_d33-description-of-strategy-and-design-for-data-stream-management-approaches_final.pdf</a> <span class="anchor" id="line-334"></span><span class="anchor" id="bottom"></span></div><p id="pageinfo" class="info" lang="en" dir="ltr">c-sparql/sparql11-feedback  (last edited 2010-02-05 11:13:55 by <span title="EmanueledellaValle @ 93-34-154-131.ip50.fastwebnet.it[93.34.154.131]"><a class="nonexistent" href="/EmanueledellaValle" title="EmanueledellaValle @ 93-34-154-131.ip50.fastwebnet.it[93.34.154.131]">?</a>EmanueledellaValle</span>)</p>

<div id="pagebottom"></div>
</div>


<div id="footer">
<ul class="editbar"><li><span class="disabled">Immutable Page</span></li><li class="toggleCommentsButton" style="display:none;"><a href="#" class="nbcomment" onClick="toggleComments();return false;">Comments</a></li><li><a class="nbinfo" href="/c-sparql/sparql11-feedback?action=info" rel="nofollow">Info</a></li><li><a class="nbattachments" href="/c-sparql/sparql11-feedback?action=AttachFile" rel="nofollow">Attachments</a></li><li>
<form class="actionsmenu" method="GET" action="/c-sparql/sparql11-feedback">
<div>
    <label>More Actions:</label>
    <select name="action"
        onchange="if ((this.selectedIndex != 0) &&
                      (this.options[this.selectedIndex].disabled == false)) {
                this.form.submit();
            }
            this.selectedIndex = 0;">
        <option value="raw">Raw Text</option>
<option value="print">Print View</option>
<option value="RenderAsDocbook">Render as Docbook</option>
<option value="refresh">Delete Cache</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="SpellCheck">Check Spelling</option>
<option value="LikePages">Like Pages</option>
<option value="LocalSiteMap">Local Site Map</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="RenamePage" disabled class="disabled">Rename Page</option>
<option value="DeletePage" disabled class="disabled">Delete Page</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Subscribe User</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="show" disabled class="disabled">Remove Spam</option>
<option value="show" disabled class="disabled">Revert to this revision</option>
<option value="show" disabled class="disabled">Package Pages</option>
<option value="SyncPages">Sync Pages</option>
<option value="show" disabled class="disabled">------------------------</option>
<option value="Load">Load</option>
<option value="Save">Save</option>
    </select>
    <input type="submit" value="Do">
    
</div>
<script type="text/javascript">
<!--// Init menu
actionsMenuInit('More Actions:');
//-->
</script>
</form>
</li></ul>

<ul id="credits">
<li><a href="http://moinmo.in/" title="This site uses the MoinMoin Wiki software.">MoinMoin Powered</a></li><li><a href="http://moinmo.in/Python" title="MoinMoin is written in Python.">Python Powered</a></li><li><a href="http://moinmo.in/GPL" title="MoinMoin is GPL licensed.">GPL licensed</a></li><li><a href="http://validator.w3.org/check?uri=referer" title="Click here to validate this page.">Valid HTML 4.01</a></li>
</ul>


</div>
</body>
</html>

