<html>

<title>Glossary of Common CYC&reg; Terminology</title>
<body bgcolor="#FFFFFF">
<a name="top"></a>
<h2><a href=http://www.cyc.com><img src=/cycdoc/img/opencyc-logo.gif border=0></a>Glossary of Common CYC&reg; Terminology</h2>


E-Mail Comments to: <a href=mailto:opencyc-doc@cyc.com>opencyc-doc@cyc.com</a><br>


Last Update: 3/28/2002<br>

<i>Copyright&copy 1996-2002 <a href="http://www.cyc.com">Cycorp</a>. All rights reserved.</i><br>

<hr>
<a href=/cycdoc/toc.html><img src="/cycdoc/img/cyc-ball-sm.gif" border=0>Return to Table of Contents</a><br>


<hr> 

This document is a glossary of jargon you are likely to encounter in
the CYC documentation and in conversation with Cyclists.  Important
CYC Constants have their own documents, which you can find in the
vocabulary section on the <a href="../toc.html">Table of Contents</a> page. 
For a more complete list of abbreviations, see <a href="abbrev.html">Abbreviations in CYC</a>.

<hr>

<h2>Contents:</h2>

<ul>
  <li><a href="#access level">access level (AL)</A>
  <li><a href="#antecedent">antecedent</A>
  <li><a href="#argument">argument</A>
  <li><a href="#argumentation">argumentation</A>
  <li><a href="#arity">arity</A>
  <li><a href="#ASK">ASK</A>
  <li><a href="#ASSERT">ASSERT</A>
  <li><a href="#asserted">asserted</A>
  <li><a href="#assertion">assertion</A>
  <li><a href="#atomic formula">atomic formula</A>
  <li><a href="#axiom">axiom</A>
  <li><a href="#backward">backward</A>
  <li><a href="#circumscription">circumscription</A>
  <li><a href="#closed world assumption">closed world assumption</A>
  <li><a href="#code">code</A>
  <li><a href="#collection">collection</A>
  <li><a href="#communication mode">communication mode</A>
  <li><a href="#conditional">conditional</A>
  <li><a href="#CNF">conjunctive normal form (CNF)</A>
  <li><a href="#consequent">consequent</A>
  <li><a href="#constant">constant</A>
  <li><a href="#constant-docs">constant documentation</A>
  <li><a href="#context">context</A>
  <li><a href="#CLPE">constraint language proposition expression (CLPE)</A>
  <li><a href="#API">Cyc API</A>
  <li><a href="#Cyc-9">Cyc-9</A>
  <li><a href="#Cyc-10">Cyc-10</A>
  <li><a href="#CycL">CycL</A>
  <li><a href="#CycLForm">CycL Formula</A>
  <li><a href="#Cyclist">Cyclist</A>
  <li><a href="#deduction">deduction</A>
  <li><a href="#default">default</A>
  <li><a href="#default reasoning">default reasoning</A>
  <li><a href="#default true">default true</A>
  <li><a href="#dependents">dependents</A>
  <li><a href="#direction">direction</A>
  <li><a href="#disjunction">disjunction</A>
  <li><a href="#EL">epistemological level (EL)</A>
  <li><a href="#equality">equality</A>
  <li><a href="#existential quantification">existential quantification</A>
  <li><a href="#expression">expression</A>
  <li><a href="#FOPC">first-order predicate calculus (FOPC)</A>
  <li><a href="#formula">formula</A>
  <li><a href="#FORT">first order reified terms (FORT)</A>
  <li><a href="#forward">forward</A>
  <li><a href="#frame-based">frame-based</A>
  <li><a href="#frame-based display">frame-based display</A>
  <li><a href="#function">function</A>
  <li><a href="#FI">functional interface (FI)</A>
  <li><a href="#genlMt">#$genlMt</A>
  <li><a href="#GAF">ground atomic formula (GAF)</A>
  <li><a href="#groundexp">ground expression</a>
  <li><a href="#HL">heuristic level (HL)</A>
  <li><a href="#individual">individual</A>
  <li><a href="#inference">inference</A>
  <li><a href="#inferred">inferred</A>
  <li><a href="#IBQE">interval-based quantity expression (IBQE)</A>
  <li><a href="#justification">justification</A>
  <li><a href="#KB">knowledge base (KB)</A>
  <li><a href="#KEer">KEer</A>
  <li><a href="#literal">literal</A>
  <li><a href="#local">local</A>
  <li><a href="#logical connective">logical connective</A>
  <li><a href="#mt">microtheory</A>
  <li><a href="#modus-ponens">modus ponens</A>
  <li><a href="#modus-tollens">modus tollens</A>
  <li><a href="#monotonic">monotonic</A>
  <li><a href="#monotonically true">monotonically true</A>
  <li><a href="#NL">natural language (NL)</A>
  <li><a href="#NAT">non-atomic term (NAT)</A>
  <li><a href="#NUE">NUE</A>
  <li><a href="#ontology">ontology</A>
  <li><a href="#predicate">predicate</A>
  <li><a href="#quantification">quantification</A>
  <li><a href="#quantifier">quantifier</A>
  <li><a href="#reification">reification</A>
  <li><a href="#relation">relation</A>
  <li><a href="#remote">remote</A>
  <li><a href="#rule">rule</A>
  <li><a href="#scope">scope</A>
  <li><a href="#second-order">second-order</A>
  <li><a href="#Skolem function">Skolem function</A>
  <li><a href="#skolemization">skolemization</A>
  <li><a href="#slot">slot</A>
  <li><a href="#source">source</A>
  <li><a href="#spec">spec</A>
  <li><a href="#strength">strength</A>
  <li><a href="#SubL">SubL</A>
  <li><a href="#Sublisp">Sublisp</A>
  <li><a href="#support">support</A>
  <li><a href="#term">term</A>
  <li><a href="#transcript">transcript</A>
  <li><a href="#transcript server">transcript server</A>
  <li><a href="#TMS">truth maintenance system (TMS)</A>
  <li><a href="#tv">truth value</A>
  <li><a href="#unification">unification</A>
  <li><a href="#unique names assumption">unique names assumption</A>
  <li><a href="#unit">unit</A>
  <li><a href="#uom">unit of measure</A>
  <li><a href="#universal-quantification">universal quantification</A>
  <li><a href="#variable">variable</A>
  <li><a href="#well-formed">well-formed</A>

</ul>
<hr>

<DL><p>

<DT><H3><A NAME="access level">access level (AL)</a></h3>
<DD>

(obs.)  In <A HREF="#Cyc-9">Cyc-9</A>, the access level of an <A
HREF="#assertion">assertion</A> determines whether inferencing involving
that assertion occurs at <A HREF="#ASSERT">assert</A> time or at <A
HREF="#ASK">ask</A> time.  Access level is replaced in <A
HREF="#Cyc-10">Cyc-10</A> by <A HREF="#direction">direction</A>.<p>

Only two access level values were commonly used in Cyc-9: 0, which
corresponds to the Cyc-10 direction <A HREF="#forward">forward</A>, and 4,
which corresponds to the Cyc-10 direction <A HREF="#backward">backward</A>.<p>

For more information on direction, click <A
HREF="cycl-syntax.html#directions">here</A>.<p>

<DT><H3><A NAME="antecedent">antecedent</a></h3>
<DD>

The antecedent of a <A HREF="#rule">rule</A> is its left-hand side, that
is, the first argument to the <a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a> connective with
which the rule begins.  Intuitively, every rule states that if the
antecedent is true, then the <A HREF="#consequent">consequent</A> must
be true.<p>

<DT><H3><A NAME="argument">argument</a></h3>
<DD>

The term "argument" is used in two different ways by Cyclists:<p>

<ul>

<li>Most commonly, the term "argument" is used to refer to any <A
HREF="#CycL">CycL</A> term which follows a <A
HREF="#predicate">predicate</A>, a <A HREF="#function">function</A>, a
<A HREF="#logical connective">logical connective</A>, or a 
<A HREF="#quantifier">quantifier</A> in a Cycl expression.  Thus, in the
CycL formula (<a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> #$BillM #$Goolsbey), <a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> is a
predicate, and #$BillM and #$Goolsbey are the first and
second arguments to that predicate.<p>

<li>The term "argument" is also used to refer to a reason why an
<A HREF="#assertion">assertion</A> is present in the <A HREF="#KB">KB</A>
with its truth value.  Arguments are of two main types:  the first type
of argument is essentially a statement that the formula was explicitly 
"asserted" (or "local").  The second type of argument is the group of
assertions through which the assertion was "inferred" (in which case the
assertion is called "remote").  In this case there is a chain of
inference which supports the truth value of the supported assertion.  Such
arguments are also called deductions.<p>
</ul>

<DT><H3><A NAME="argumentation">argumentation</a></h3>
<DD>

Argumentation is the process of weighing various arguments, pro and con, 
for the truth of an assertion, and arriving at a <a href="#tv">truth value</A>
for the assertion.  CYC&reg; employs a 
number of heuristics during argumentation.  One simple example is "prefer 
monotonic rules," i.e., if two rules conclude P but with different negation status
(one concludes P with a monotonic rule but the other concludes Not-P with a 
default rule), all else being equal, CYC&reg; sets the truth value of P to the one 
suggested by the monotonic rule.<p>

<DT><H3><A NAME="arity">arity</a></h3>
<DD>

The arity of a <A HREF="#CycL">CycL</A> <A HREF="#predicate">predicate</A> or <A HREF="#function">function</A> is
the number of <A HREF="#argument">arguments</A> it takes.<p>

<ul>
<li>Unary predicates and functions take just 1 argument.
<li>Binary predicates and functions take 2 arguments. 
<li>Ternary predicates and functions take 3 arguments. 
<li>Quaternary predicates and functions take 4 arguments. 
<li>Quintary predicates and functions take 5 arguments. 
</ul><p>

No CycL predicate or function currently takes more than 5 arguments.<p>

<DT><H3><A NAME="ASK">ASK</a></h3>
<DD>

The purpose of an ASK operation is to query a CYC&reg; Server about the truth
of a formula.<p>

The details of an ASK operation vary from interface to interface.
However, in most interfaces you will be asked to supply:<p>

<ul>

<li>A <A HREF="#CycLForm">CycL formula</A>, which may or may not contain
free <A HREF="#variable">variables</A>.  If the formula contains
variables, then you are asking CYC&reg; to supply bindings to those variables
which make the formula true; otherwise, you are simply asking whether
the formula is true.<p>

<li>A <A HREF="#mt">microtheory</A> within which to look.  In other
words, each binding returned must come from a formula which is known to
be true in, or can be inferred from assertions in, the specified
microtheory and its baseMts.<p>

<li>Optionally, a <A HREF="#direction">direction</A> (or <A
HREF="#access level">access level</A>).  If the direction is <A
HREF="#forward">forward</A>, no expensive inferencing is performed,
and the only bindings returned are ones which can be found through a
simple KB lookup.  If the direction is <A
HREF="#backward">backward</A>, inferencing is performed.<p>

<li>Optionally, a number of bindings
requested.  Once this number of bindings has been found, the ASK
operation will terminate, even if more bindings exist.  The default
value varies among interfaces; if no value is passed by the interface 
on to the underlying code, the operation will continue until one of 
the other resource limits has been reached or until the KB has been 
exhaustively searched, which could take a long time. <p> 

<li>Optionally, a time limit.  No more than this many seconds will be
spent on the ASK operation.  Again, a particular interface may provide a 
default time limit, but if none is passed to the underlying code, the 
ASK operation will continue until one of the other resource limits has 
been reached or until the KB has been exhaustively searched. <p>

<li>Optionally, a inference depth cutoff.  The search for bindings will go no
deeper than this number of levels.  In the search for bindings, each time 
the inference engine tries to satisfy a <A HREF="#literal">literal</A>, the 
search is extended by one depth level.  Currently, this is true whether 
literals are satisified by firing <A HREF="#rule">rules</A> 
or by simple KB lookup.  If no inference-depth
cutoff is passed by your interface on to the underlying code, the ASK operation 
will continue until one of the other resource limits has 
been reached or until the KB has been exhaustively searched. <p> 

<li>Optionally, an axiom depth cutoff.  No more than this many 
<A HREF="#rule">rules</A> will be used in the search for bindings. If no axiom-depth
cutoff is passed by your interface on to the underlying code, the ASK operation 
will continue until one of the other resource limits has 
been reached or until the KB has been exhaustively searched. <p> 

</ul>

For example, if you wanted to find some people who have served as head
of state of a European country, you might execute an ASK with the
following parameters:

<pre>
   Formula:         (<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a>
                       (<a href=/cycdoc/vocab/spatial-vocab.html#geographicalSubRegions>#$geographicalSubRegions</a> <a href=/cycdoc/vocab/geography-vocab.html#ContinentOfEurope>#$ContinentOfEurope</a> ?X)
                       (#$headOfStateOf ?X ?Y))
   Microtheory:     <a href=/cycdoc/vocab/mt-vocab.html#BaseKB>#$BaseKB</a>
   Direction:       backward
   Number:          5
   Time:            10
   Inference Depth: 10
   Axiom Depth:     3
</pre>

This asks CYC&reg; to find no more than 5 bindings for ?X and ?Y, satisfiable 
in the <a href=/cycdoc/vocab/mt-vocab.html#BaseKB>#$BaseKB</a>, that can be found in 10 seconds of processor time or less.  CYC&reg; can use 
rules in the search, since the direction is backward, and can stop pursuing any search 
path as soon as it requires using a 4th rule or satisfying an 11th literal.

<DT><H3><A NAME="ASSERT">ASSERT</a></h3>
<DD>

The purpose of the ASSERT operation is to add a new assertion--a
"fact" or a "rule"--to  the KB. If an ASSERT operation is
successful, afterwards the KB will contain one or more new <A
HREF="#assertion">assertions</a>.<p>

The details of an ASSERT operation vary from interface to interface.
However, in most interfaces you will be asked to supply:<p>

<ul>

<li>A <A HREF="#CycLForm">CycL formula</A>, which is either a 
<A HREF="#rule">rule</A> or a <A HREF="#GAF">GAF</A>.  If the ASSERT is 
successful, and the formula can be internally represented as a single assertion, 
the new assertion will have a formula logically equivalent to 
this one.  If the formula requires several assertions to represent it, the 
conjunction of the formulas of the new assertions will be logically equivalent 
to the formula asserted.<p>

<li>A <A HREF="#mt">microtheory</A> within which to put the new assertion(s).<p>

<li>Optionally, a <A HREF="#direction">direction</A>.  If the direction is 
<A HREF="#backward">:backward</A>, the new assertion(s) can participate 
in backward inference only.  If the direction is 
<A HREF="#forward">:forward</A>, they can participate in 
both forward and backward inference.  Because of this, asserting a forward 
formula may cause other formulas to be added to the KB at that time as forward inference 
kicks in.<p>  If the direction is :CODE, the new assertion(s) will not be
used during normal inference at all.

Default values for direction vary among interfaces, but if none is passed on 
to the underlying code, the new assertion will have :forward if it is a 
<A HREF="#GAF">GAF</A>, and :backward if it is a <A HREF="#rule">rule</A>. <p>

<li>Optionally, a <A HREF="#strength">strength</A>.  Possible strengths are 
<A HREF="#default">:default</A> and <A HREF="#monotonic">:monotonic</A>.  This value, 
together with whether the formula is negated (begins with <a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a>) or not, determines the
<A HREF="#tv">truth value</A> of the resulting assertions when an ASSERT 
operation succeeds.<p>

The default value for strength is nearly always :default.<p>

</ul>

<DT><H3><A NAME="asserted">asserted</a></h3>
<DD>

An asserted assertion is one that was explicitly added to the KB via an
<A HREF="#ASSERT">ASSERT</A> operation.  An "asserted argument" is an argument
claiming an assertion was asserted.  Contrast with <A HREF="#inferred">inferred</A>.


<DT><H3><A NAME="assertion">assertion</a></h3>
<DD>

The assertion is the fundamental unit of knowledge in the CYC&reg; system.
Every assertion consists of:  
<p>

<ul>
<li>a <A HREF="#CycLForm">CycL formula</A> which states the content of the assertion
<li>a <A HREF="#tv">truth value</A>
<li>a <A HREF="#mt">microtheory</A> of which the assertion is part
<li>a <A HREF="#direction">direction</A> (in Cyc-9 this was an <A HREF="#access level">access level</A>)
<li>a <A HREF="#justification">justification</A>
</ul>
<p> 

The set of assertions includes both <A HREF="#rule">rules</A> and <A HREF="#GAF">GAFs</A>.<p>

<DT><H3><A NAME="atomic formula">atomic formula</a></h3>
<DD>

An atomic formula is an expression in CycL of the following form:  a list with opening
and closing parentheses such that the first element of the list is a CycL <A HREF="#predicate">predicate</A>,
and the remaining elements are the arguments to the predicate. Atomic
formulas use no <A HREF="#logical connective">logical connectives</A>.  
See also <A HREF="#GAF">ground atomic formula</A>.  In CycL atomic formulas
may have variables, constants, or other terms as arguments to the CycL predicate.<p>

<DT><H3><A NAME="axiom">axiom</a></h3>
<DD>

Strictly speaking, an axiom is one of a set of fundamental formulas that one starts with
to prove theorems by deduction.
In CYC&reg;, the axioms are those formulas that have been <A HREF="#local">locally</A>
asserted into the CYC&reg; KB.  CYC&reg; axioms
are well-formed CYC&reg; formulas, since the system won't let you add
formulas to CYC&reg; that are not well-formed.  However, not all well-formed
CYC&reg; formulas are axioms, since not all of them are actually in the KB.  And some of the 
formulas in the KB are not, strictly speaking, axioms, since they were added to the 
KB via <A HREF="#inference">inference</A>, instead of being locally asserted.<p>

In informal usage, though, Cyclists don't always adhere to the strict
meaning of axiom, and may refer to a formula they are considering adding
to the KB or have recently removed from the KB as an axiom.<p>
<I>Axiom  </I> is also the name of one of the internal KB data structure
types.<p>

<DT><H3><A NAME="backward">backward</a></h3>
<DD>

"Backward" is one of the possible values for <A HREF="#direction">direction</A>
that an <A HREF="#assertion">assertion</A> may have.  If an assertion is 
:backward, it may participate in backward inference only.<p>

"Backward" also refers to a mode of inference where rules do not fire until 
the user <A HREF="#ASK">ASK</A>s some formula that triggers a rule.<p>  

See also <A HREF="#forward">forward</A> and <a href="#code">code</a>.<p>

Backward inference example:  If the user asks "What things are green?":

<pre>
   (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?X #$GreenColor)
</pre>

this would trigger a rule in the KB that says "All leaves are green": 

<pre>
RULE 1: 
   (<a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a> 
     (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?LEAF #$Leaf)
     (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?LEAF #$GreenColor))
</pre>

Then if CYC&reg; can find something that is a leaf (like #$Leaf0037), thus satisfying the 
<A HREF="#antecedent">antecedent</A> of the rule, it fires the rule, adding 

<pre>
   (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> #$Leaf0037 #$GreenColor)
</pre>

to the KB and returning #$Leaf0037 as a binding for ?X.  In backward inference, CYC&reg; 
doesn't bother finding something to satisfy the antecendent of RULE 1
until a user or application program does an <A HREF="#ASK">ASK</A> of some formula
that in part matches the consequent of RULE 1.<p>



<DT><H3><A NAME="code">code</a></h3>
<DD>

"Code" is one of the possible values for <A HREF="#direction">direction</A>
that an <A HREF="#assertion">assertion</A> may have.  If an assertion is 
:code, then special HL modules have been written to supplant the need for inference using the
assertion itself.  Code assertions cannot be edited via the HTML interface.<p>

"Code" can also refer to the <a href="#SubL">SubL</a> source code. <p>

See also <A HREF="#backward">backward</A> and <a href="#forward">forward</a>.<p> 

<DT><H3><A NAME="collection">collection</a></h3>
<DD>

In CycL, collections are denoted by certain constants which are called 
"collection-denoting" constants.  These are often referred to as "CycL collections" 
or just "collections" in casual usage.  CycL collections are constants
that denote collections of objects, rather than <A HREF="#individual">individual</A> 
objects.  For example, the constant <a href=/cycdoc/vocab/biology-vocab.html#Dog>#$Dog</a> denotes the collection of all dogs, 
while the individual-denoting constant #$Snoopy denotes a specific dog.  For 
more on this topic, see the constants <a href=/cycdoc/vocab/fundamental-vocab.html#Collection>#$Collection</a> and <a href=/cycdoc/vocab/fundamental-vocab.html#Individual>#$Individual</a>.<p>

<DT><H3><A NAME="communication mode">communication mode</a></h3>
<DD>

The communication mode controls how a CYC&reg; Server communicates with
other CYC&reg; servers about operations performed on the CYC&reg; <A
HREF="#KB">KB</A>.  All communication between CYC&reg; servers occurs via
<A HREF="#transcript">transcripts</A>.  For more information about
transcripts and communication modes, click <A
HREF="system.html">here</A>.<p>

<DT><H3><A NAME="conditional">conditional</a></h3>
<DD>

A conditional is the same thing as a <A HREF="#rule">rule</A>.<p>

<DT><H3><A NAME="conjunction">conjunction</a></h3>
<DD>

Conjunction is represented in CYC&reg; by the CycL logical connective <a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a>.
A CycL formula is sometimes called a conjunction if it begins with <a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a>.<p>

<DT><H3><A NAME="CNF">conjunctive normal form (CNF)</a></h3>
<DD>

A formula in CycL or <a href="#FOPC">first-order predicate calculus</a> is in conjunctive normal form if 
it is a <A HREF="#conjunction">conjunction</A> of 
<A HREF="#disjunction">disjunctions</A> of <A HREF="#literal">literals</A>.  
For example,

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?C #$Cloud))
	        (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?C #$WhiteColor)
                (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?C #$GreyColor))
          (<a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?C #$Cloud))
	        (<a href=/cycdoc/vocab/material-vocab.html#physicalStructuralAttributes>#$physicalStructuralAttributes</a> ?C #$Puffy)))
</pre>

is in conjunctive normal form.  For every CycL or FOPC formula, there is a 
logically equivalent formula that adheres to CNF.<p>

When a formula is asserted to CYC&reg;, it is first converted into conjunctive 
normal form.  For each disjunction in the resulting CNF expression, a new 
<A HREF="#assertion">assertion</A> is created.  Some formulas convert to a 
CNF expression with only one conjunct (and therefore only one disjunction); for example, 

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> #$Kermit <a href=/cycdoc/vocab/biology-vocab.html#Frog>#$Frog</a>)
</pre>

converts to 

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> #$Kermit <a href=/cycdoc/vocab/biology-vocab.html#Frog>#$Frog</a>)))
</pre>

and 

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a> 
      (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?FROG <a href=/cycdoc/vocab/biology-vocab.html#Frog>#$Frog</a>)
      (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?FROG #$GreenColor))
</pre>

converts to 

<pre> 
   (<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?FROG <a href=/cycdoc/vocab/biology-vocab.html#Frog>#$Frog</a>))
	        (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?FROG #$GreenColor)))
</pre>

These formulas, if asserted, would result in a single new 
assertion being added to the 
KB.  Other formulas convert to CNF expressions 
with multiple conjuncts.  For example, 

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a>
      (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?C #$Cloud)
      (<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a> (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?C #$WhiteColor)
		   (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?C #$GreyColor))
             (<a href=/cycdoc/vocab/material-vocab.html#physicalStructuralAttributes>#$physicalStructuralAttributes</a> ?C #$Puffy)))
</pre>

converts to 

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?C #$Cloud))
	        (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?C #$WhiteColor)
                (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?C #$GreyColor))
          (<a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a> (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?C #$Cloud))
	        (<a href=/cycdoc/vocab/material-vocab.html#physicalStructuralAttributes>#$physicalStructuralAttributes</a> ?C #$Puffy)))
</pre>

This last formula, if asserted, would result in two separate assertions 
being added to the KB, one for each conjunct. 

<DT><H3><A NAME="consequent">consequent</a></h3>
<DD>

The consequent of a <A HREF="#rule">rule</A> is its right-hand side,
that is, the second argument to the <a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a> connective
with which the rule begins.  Intuitively, every rule states that if the
<A HREF="#antecedent">antecedent</A> is true, then the consequent is true.<p>

<DT><H3><A NAME="constant">constant</a></h3>
<DD>

Constants are terms introduced into CycL by explicit creation.  Constants
such as #$BillM or <a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> begin with "#$&quot;. Constants are one type 
of <A HREF="#FORT">FORT</A>; the other type are
non-atomic terms (NAT's).  For more on the syntax and usage of constants, click <A
HREF="cycl-syntax.html#constants">here</A>.<p>


<DT><H3><A NAME="constant-docs">constant documentation</a></h3>
<DD>

Documentation strings for constants, in, or accessible from, the KB.<p>

<DT><H3><A NAME="CLPE">constraint language proposition expression (CLPE)</a></h3>
<DD>
This is an old name for a Cyc <A HREF="#formula">formula</A>.<p>

<DT><H3><A NAME="context">context</a></h3>
<DD>

Often used interchangeably with <A HREF="#mt">microtheory</A>.<p>

<DT><H3><A NAME="API">Cyc API</a></h3>
<DD>

The CYC&reg; API is an applications programming interface that allows
programmers to build applications based on the CYC&reg; technology.
Click here for more information about the Cyc API.<p>

<DT><H3><A NAME="Cyc-9">Cyc-9</a></h3>
<DD>

The last version of CYC&reg; developed at MCC. 

<DT><H3><A NAME="Cyc-10">Cyc-10</a></h3>
<DD>

The current version of CYC&reg; developed at Cycorp under the direction of Keith 
Goolsbey, and first deployed there in March, 1995.  All current CYC&reg; development
effort is with Cyc-10. 

<DT><H3><A NAME="CycL">CycL</a></h3>
<DD>

CycL is the formal language in which CYC&reg; assertions are written.  CycL
derives from <A HREF="#FOPC">first-order predicate calculus</A>, but
includes many extensions to FOPC which enhance the expressiveness of the
language.  For a more complete description of CycL syntax, click <A
HREF="cycl-syntax.html">here</A>.<p>

<DT><H3><A NAME="Cyclist">Cyclist</a></h3>
<DD>

A Cyclist is a registered modifier of the CYC&reg; KB.  Everyone who works on the 
CYC&reg; project is a Cyclist, as are individuals working with CYC&reg; at participating 
organizations.<p>

<DT><H3><A NAME="CycLForm">CycL Formula</a></h3>
<DD>

A formula is an <A HREF="#expression">expression</A> in a formal language that 
makes some declarative statement about the world.  Formulas are analogous to 
declarative sentences in English.  In CycL, formulas that are <A HREF="#well-formed">well-formed</A> 
are called CycFormulas. For more information about the syntax of CycFormulas, 
click <A HREF="cycl-syntax.html#formulas">here</A>.<p>


<DT><H3><A NAME="deduction">deduction</a></h3>
<DD>
A deduction is an <A HREF="#argument">argument</a> supporting a remote
or inferred assertion.  It is composed of a set of
assertions which together entail the inferred assertion.<p>
 

<DT><H3><A NAME="default">default</a></h3>
<DD>

One of the possible values for <A HREF="#strength">strength</A>.  If a 
formula is asserted with a strength of :default, the resulting 
assertion(s) will have a <A HREF="#tv">truth value</A> of either 
default true or default false, 
depending on whether or not the asserted formula was negated.  Default rules can 
have exceptions, and default <A HREF="#GAF">GAFs</A> can have their truth 
values changed by <A HREF="#argumentation">argumentation</A>.
See also <A HREF="#monotonic">monotonic</A>.<p>

<DT><H3><A NAME="default true">default true</a></h3>
<DD>

An <A HREF="#assertion">assertion</A> which is default true is assumed
to be true in all cases, unless there is evidence to the contrary.
Thus, unlike an assertion which is <A HREF="#monotonically true">monotonically true</A>, 
it admits exceptions.  Default true is one
of CycL's five possible <A HREF="#tv">truth values</A>.  It is
represented in the CYC&reg; Web Interface by a yellow ball 
<img src=/cycdoc/img/cb/yellow.gif>
.<p>

<DT><H3><A NAME="dependents">dependents</a></h3>
<DD>

An assertion's dependents are assertions which have some
<A HREF="#deduction">deduction></A> (inferred argument) mentioning it.
When an assertion is deleted, its dependents must be examined to see if they
should also be removed.<p>

<DT><H3><A NAME="direction">direction</a></h3>
<DD>

Direction is a value attached to every <A
HREF="#assertion">assertion</A> which determines whether inferencing
involving the assertion is done at assert time or at ask time.  There are 
three possible values for direction: :<A HREF="#forward">forward</A> 
(inferencing done at assert time), :<A HREF="#backward">backward</A> 
(inferencing done at ask time), and :<a href="#code">code</a> (HL module performs reasoning, assertion not used in regular inference).  Most interfaces enforce the 
following default:  <A HREF="#GAF">GAFs</A>
have direction :forward and <A HREF="#rule">rules</A> have
direction :backward.  Direction is new in Cyc-10; it replaces
<A HREF="#access level">access level</A>.<p>

<DT><H3><A NAME="disjunction">disjunction</a></h3>
<DD>

Disjunction is represented in CYC&reg; by the logical connective <a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a>.
A formula is sometimes called a disjunction if it begins with <a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a>.<p>

<DT><H3><A NAME="EL">epistemological level (EL)</A></H3>
<DD>

Epistemological level refers to the way 
knowledge is expressed when CYC&reg; communicates with users or external programs.
This stands in contrast with <A HREF="#HL">heuristic level</A>, which refers to the 
way knowledge is actually stored, and inference implemented, in CYC&reg;.<p>


<DT><H3><A NAME="existential quantification">existential quantification</a></h3>
<DD>

Quantifying with <a href=/cycdoc/vocab/fundamental-vocab.html#thereExists>#$thereExists</a>.  For example, the following existentially quantified
assertion
<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#thereExists>#$thereExists</a> ?SING 
      (<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a> 
         (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?SING <a href=/cycdoc/vocab/social-vocab.html#HumanAdult>#$HumanAdult</a>)
         (<a href=/cycdoc/vocab/social-vocab.html#maritalStatus>#$maritalStatus</a> ?SING #$Single))),
</pre>
states that there is some unmarried human adult.
<p>

<DT><H3><A NAME="expression">expression</a></h3>
<DD>

In the most general sense, an expression is a sequence of symbols.  The
phrase <I>CycL expression </I> refers to expressions that follow the
syntax rules of CycL.  Some CycL expressions are propositions or
statements about the world; these are called <A HREF="#CycLForm">CycL formulas</A>.  
Other CycL expressions form terms that stand for concepts; these are called <A HREF="#NAT">non-atomic terms (NATs)</A>. <p>

<DT><H3><A NAME="FOPC">first-order predicate calculus (FOPC)</a></h3>
<DD>
A formal language incorporating predicate symbols, function symbols,
constant symbols, variables, logical connectives and quantifiers, which
can be used to express facts about a world.  Unlike propositional logic,
FOPC can express general statements or statements about existence, by
using quantified variables.  "First-order" means that statements which
quantify over predicate and function symbols are not allowed.<p>


<DT><H3><A NAME="formula">formula</a></h3>
<DD>

A formula is a sentential <A HREF="#expression">expression</A> in a formal
language.  If the expression is closed (that is, if it has no unbound variables) 
it can be used to express something about the world.  Closed formulas are analogous 
to declarative sentences in English.  In CycL, formulas that are 
<A HREF="#well-formed">well-formed</A> are called "CycL formulas".  
For more information about the syntax of CycL
formulas, click <A HREF="cycl-syntax.html#formulas">here</A>.<p>

<DT><H3><A NAME="FORT">FORT (First Order Reified Terms)</a></h3>
<DD>

There are two kinds of FORTs: <A HREF="#constant">constants</A> and
<A HREF="#NAT">non-atomic terms</A> (NATs).<p>


<DT><H3><A NAME="forward">forward</a></h3>
<DD>

"Forward" is one of the possible values for <A HREF="#direction">direction</A>
that an <A HREF="#assertion">assertion</A> may have.  If an assertion is 
:forward, it may participate in both forward and backward inference.<p>

"Forward" also refers to a mode of inference where rules fire as soon as their
<A HREF="#antecedent">antecedents</A> become true.<p>  

See also <A HREF="#backward">backward</A> and <a href="#code">code</a>.<p> 

Forward inference example:  Suppose the KB already knows 

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> #$Leaf0037 #$Leaf)
</pre>

Suppose a user or application program asserts the following as a forward rule: 

<pre>
   (<a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a> 
     (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?LEAF #$Leaf)
     (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?LEAF #$GreenColor))
</pre>

As soon as the axiom is asserted, the system detects that the
antecedent is satisfied by #$Leaf0037, fires the rule, and adds the
conclusion

<pre>
   (<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> #$Leaf0037 #$GreenColor)
</pre>

to the KB.  Unlike backward inference, this happens automatically
without needing to be triggered by an <A HREF="#ASK">ASK</A>
operation.  It also should not depend on the order in which the
assertions are added to the KB: If the forward rule was added first,
and it was later asserted that #$Leaf0037 was an element of #$Leaf,
the rule would fire at that time.<p>

<DT><H3><A NAME="frame-based">frame-based</a></h3>
<DD>

Frame-based representations attempt to collect all the information
relevant to a concept on a "frame" for that concept.  Each frame has a
series of <A HREF="#slot">slot</A>s filled by values.  The slots can be 
viewed as binary relationships between the concept of the frame, and the 
values filling them.<p>

<DT><H3><A NAME="frame-based display">frame-based display</a></h3>
<DD>

A frame-based display can present representations which are frame-based
(a series of slots with values), or which are isomorphic to frames.  For
example, some CYC&reg; interfaces use a frame-based display method for
showing the binary predicates the displayed concept is a first argument
to.<p>

<DT><H3><A NAME="function">function</a></h3>
<DD>

A function (in the mathematical sense) is a relation such that for
each thing in its domain (the universe of things it can be applied
to), there is a single thing in its range (the universe of results it
can have) such that the relation holds between them.

In CycL, functions are denoted by certain constants.  These constants
are referred to as "function-denoting constants, "CycL functions," or sometimes 
just "functions."  CycL functions can be applied to arguments to form <A
HREF="#NAT">non-atomic terms</A>, which can serve as arguments to a predicate 
just as other terms can.

There are more details about CycL functions in the <A HREF="cycl-syntax.html#functions">Functions</A> section of "The Syntax
of Cycl".


<DT><H3><A NAME="FI">functional interface (FI)</a></h3>
<DD>

The FI is an applications programming interface containing several dozen
standard calls to CYC&reg; which can be used by programmers
to build applications based on the CYC&reg; technology.  The FI is a 
subset of a larger programming interface, the CYC&reg; <A HREF="#API">API</A>.
Click <A HREF="fi.html">here</a> for an index to information about the 
Functional Interface.<p>



<DT><H3><A NAME="genlMt">#$genlMt</a></h3>
<DD>

One microtheory is a <a href=/cycdoc/vocab/mt-expansion-vocab.html#genlMt>#$genlMt</a> of another if all its assertions are true in the
other microtheory.  <a href=/cycdoc/vocab/mt-vocab.html#BaseKB>#$BaseKB</a> is a <a href=/cycdoc/vocab/mt-expansion-vocab.html#genlMt>#$genlMt</a> of all microtheories.<p>
 

<DT><H3><A NAME="GAF">ground atomic formula (GAF)</a></h3>
<DD>

A GAF is a CYC&reg; formula of the form (predicate arg1 [arg2 ...argn]), where 
the arguments are all <A HREF="#term">terms</A> of any kind, but 
not variables.  For example,

<pre>
   (<a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> #$Goolsbey #$Brandy)
   (#$eats #$BillM (<a href=/cycdoc/vocab/biology-vocab.html#FruitFn>#$FruitFn</a> #$AppleTree))
   (<a href=/cycdoc/vocab/attitude-vocab.html#beliefs>#$beliefs</a> #$BillM (<a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> #$Goolsbey #$Brandy))
</pre>

GAFs are a subset of <A HREF="#atomic formula">atomic formulas</a>.  They are those
atomic formulas in which no variables appear.<p>

<DT><H3><A NAME="groundexp">ground expression</a></h3>
<DD>

An expression is ground iff it contains no variables.<p>


<DT><H3><A NAME="HL">heuristic level (HL)</a></h3>
<DD>

Another name for this might be "implementation level".  Heuristic level refers to the 
way knowledge is actually stored, and inference implemented, in CYC&reg;.  This stands 
in contrast to the <A HREF="#EL">Epistemological Level (EL)</A>, which refers to the way 
knowledge is expressed when CYC&reg; communicates with users or external programs.<p>

<DT><H3><A NAME="inferred">inferred</a></h3>
<DD>

An adjective used to describe the type of <A HREF="#argument">argument</A> consisting
of a set of assertions which together entail some other assertion.  Inferred
arguments are also called <A HREF="#deduction">deductions</A>.<p>


<DT><H3><A NAME="IBQE">interval-based quantity expression (IBQE)</a></h3>
<DD>

In Cyc-10, quantities like "5 dollars", "10 seconds", and "300
kilometers" are expressed using IBQEs.  
<p>

An IBQE is a special kind of <A HREF="#NAT">non-atomic term</A> in which the 
CycL function is an instance of <a href=/cycdoc/vocab/quantity-vocab.html#UnitOfMeasure>#$UnitOfMeasure</a>.  <A HREF="#uom">Units of measure</A>
are regular (but not <A HREF="#reification">reifiable</A>) functions, 
which take two arguments:  a minimum value and a maximum value. The second argument is
optional, and if it is omitted, it is assumed to be equal to the first.
In other words, an IBQE with just one argument is taken to denote a
single value.

<pre>
   (<a href=/cycdoc/vocab/material-vocab.html#massOfObject>#$massOfObject</a> #$BillM (<a href=/cycdoc/vocab/quantity-vocab.html#Pound-UnitOfMass>#$Pound-UnitOfMass</a> 175 185))
   (<a href=/cycdoc/vocab/material-vocab.html#heightOfObject>#$heightOfObject</a> #$BillM (<a href=/cycdoc/vocab/quantity-vocab.html#Inch>#$Inch</a> 74))
</pre>



The unit of measure may be a <A HREF="#NAT">NAT</A>, rather than a 
<A HREF="#constant">constant</A>:

<pre>
   (<a href=/cycdoc/vocab/material-vocab.html#massOfObject>#$massOfObject</a> #$BillM ((#$Kilo <a href=/cycdoc/vocab/quantity-vocab.html#Gram>#$Gram</a>) 80 84))
</pre>


<DT><H3><A NAME="individual">individual</a></h3>
<DD>

In the CYC&reg; <A HREF="#ontology">ontology</A>, an individual-denoting constant 
is a constant that denotes a single object, rather than a <A REF="#collection">collection</A> 
of objects.  For example, the constant #$Snoopy denotes a specific dog, while 
the collection-denoting constant <a href=/cycdoc/vocab/biology-vocab.html#Dog>#$Dog</a> denotes the collection of all dogs.  Sometimes
individual denoting CycL contants are casually referred to as "individuals."  For 
more on this topic, see the constants <a href=/cycdoc/vocab/fundamental-vocab.html#Individual>#$Individual</a> and <a href=/cycdoc/vocab/fundamental-vocab.html#Collection>#$Collection</a>.<p>

<DT><H3><A NAME="inference">inference</A></h3>
<DD>

Inference is the process of automatically adding new facts to a 
knowledge base by applying rules of inference to the <A HREF="#axiom">axioms</A>
and already-inferred facts of the knowledge base.  CYC&reg; currently uses two rules of 
inference in its general theorem proving, <A HREF="#modus-ponens">modus ponens</A>
and <A HREF="#modus-tollens">modus tollens</A>.<p>

<DT><H3><A NAME="justification">justification</a></h3>
<DD>

A justification is the <A HREF="#argument">argument</A> or set of
arguments supporting an assertion's having a particular truth value.<p>


<DT><H3><A NAME="KEer">KEer</a></h3>
<DD>

Short for Knowledge Enterer.  One who writes <A HREF="#CycL">CycL</A> <A
HREF="#assertion">assertions</A> for inclusion in the CYC&reg; <A
HREF="#KB">KB</A>.<p>

<DT><H3><A NAME="KB">knowledge base (KB)</a></h3>
<DD>

The CYC&reg; KB is the repository of Cyc's knowledge.  It consists of a large
number of <A HREF="#FORT">FORTs</A> and an even larger number of
<A HREF="#assertion">assertions</A> involving those constants.<p>

<DT><H3><A NAME="literal">literal</a></h3>
<DD>

Most generally, a literal is a CYC&reg; expression of the form 
(predicate arg1 [arg2 ... argn]), or its negation, 
where the number of arguments to the predicate can be any positive
integer (but usually not more than 5), and the arguments can be 
any kind of <A HREF="#term">term</A>.  For example,

<pre>
   (<a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> #$Goolsbey #$Brandy)
   (<a href=/cycdoc/vocab/food-vocab.html#eatsWillingly>#$eatsWillingly</a> #$BillM (<a href=/cycdoc/vocab/biology-vocab.html#FruitFn>#$FruitFn</a> ?X))
   (<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?CAR <a href=/cycdoc/vocab/transportation-vocab.html#Automobile>#$Automobile</a>)
   (<a href=/cycdoc/vocab/actor-vocab-complete.html#performedBy>#$performedBy</a> ?ACT ?ORG)
   (<a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a> (<a href=/cycdoc/vocab/actor-vocab-complete.html#performedBy>#$performedBy</a> ?ACT ?ORG))
</pre>

Because it includes negated formulas, the class of literals is a superset of the 
class of <A HREF="#atomic formula">atomic formulas</A>.<p>

Usually, "literal" is used to refer to the atomic formulas that make up the 
internal representation of any assertion's formula.  In Cyc-10, formulas that 
are asserted into the KB are converted into <A HREF="#CNF">conjunctive normal 
form</A>; the 
formula of each single <A HREF="#assertion">assertion</A> is internally represented 
as a disjunction of literals.  Those literals that would be negated in conjunctive 
normal form are called <I>negative </I>
literals; the rest are called <I>positive </I> literals.  

<A HREF="#GAF">GAFs</A> are the subset of positive literals in which there are no
variables.<p>

<DT><H3><A NAME="local">local</a></h3>
<DD>

Old term meaning "<A HREF="#asserted">asserted</A>".

<DT><H3><A NAME="logical connective">logical connective</a></h3>
<DD>

Logical connectives are represented in CycL by special constants that are similar 
to the logical operators of formal logic.  CycL connectives (as these constants are 
sometimes called) are used to build up complex <A HREF="#CycLForm">formulas</A> out 
of <A HREF="#atomic formula">atomic formulas</A>.  
The CycL constants representing the logical connectives are <a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a>,
<a href=/cycdoc/vocab/fundamental-vocab.html#and>#$and</a>, <a href=/cycdoc/vocab/fundamental-vocab.html#or>#$or</a>, and <a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a>.  For more details on the syntax of CycL connectives, click 
<A HREF="cycl-syntax.html#logical connectives">here</A>.  <p>

<DT><H3><A NAME="mt">microtheory</a></h3>
<DD>

A microtheory is a CYC&reg; constant denoting assertions which are grouped together
because they share a set of assumptions.  Microtheories are also called
<A HREF="#context">contexts</A>.  For more information about microtheories, 
see <a href=/cycdoc/vocab/mt-expansion-vocab.html#Microtheory>#$Microtheory</a> or click <A HREF="../course/contexts-basic-module.html">here</A>.<p>

<DT><H3><A NAME="modus-ponens">modus ponens</a></h3>
<DD>

A rule of inference under which, given a knowledge base which contains the 
formulas "A" and "A implies B", one may conclude "B".<p>

<DT><H3><A NAME="modus-tollens">modus tollens</a></h3>
<DD>

A rule of inference which can be derived from modus ponens under which, given a 
knowledge base which contains the formulas "Not B" and "A implies B", one may conclude
"Not A".  

<DT><H3><A NAME="monotonic">monotonic</a></h3>
<DD>

One of the possible values for <A HREF="#strength">strength</A>.  If a 
formula is asserted with a strength of :monotonic, the resulting 
assertion(s) will have a <A HREF="#tv">truth value</A> of either 
monotonically true or monotonically false, 
depending on whether or not the asserted formula was negated.  Monotonic rules 
may never have exceptions, and monotonic <A HREF="#GAF">GAFs</A> will 
never have their truth values changed in the course of 
<A HREF="#argumentation">argumentation</A>.  The only way a monotonic assertion can 
be removed from the inference playing field is by unasserting it. 
See also <A HREF="#default">default</A>.<p>


<DT><H3><A NAME="monotonically true">monotonically true</a></h3>
<DD>

An <A HREF="#assertion">assertion</A> which is monotonically true is
asserted to be absolutely true in all cases.  Thus, unlike an assertion
which is <A HREF="#default true">default true</A>, it does not admit
exceptions.  Monotonically true is one of CycL's five possible <A
HREF="#tv">truth values</A>.  It is represented in the CYC&reg; Web 
interface by a white ball 
<img src=/cycdoc/img/cb/white.gif>
.<p>

<DT><H3><A NAME="NL">natural language (NL)</a></h3>
<DD>

Natural language is just human language, for example English.
When people talk about "NL" aspects of CYC&reg;, they are referring to Cyc's
growing ability to understand natural language.<p>

For a discussion of Cyc's NL capabilities, click <A
HREF="nl.html">here</A>.<p>

<DT><H3><A NAME="NAT">non-atomic term (NAT)</a></h3>
<DD>

A term which is neither a <A HREF="#variable">variable</A>
nor a <A HREF="#constant">constant</A>.  NATs are terms formed 
by applying a <A HREF="#function">function</A> to its arguments.  Like
constants, each NAT denotes some thing in the Cyc KB.  Currently, there are
two kinds of NAT:  Reified NATs, which are a type of <A HREF="#FORT">FORT</A>,
and are implemented with data structures that have indexing allowing all uses of 
the NAT to be retrieved; and non-reified NATs, which have no such indexing and 
remain in the form of a "lispy" expresion in the formulas in which they occur.<p>

For more details on the syntax and usage of NATs, click <A
HREF="cycl-syntax.html#NATs">here</A>.<p>


<DT><H3><A NAME="ontology">ontology</a></h3>
<DD>

In philosophy, <I>ontology</I> is the study of being.  In
knowledge-based systems, an ontology is that part of the system which
specifies what things exist and what is true about them.  Cyc's ontology
is essentially its whole knowledge base.  You may hear people refer to
their "ontology of devices" or their "temporal ontology".  What they are
talking about is those parts of their knowledge base (the constants and
assertions) that concern devices or time.<p>


<DT><H3><A NAME="predicate">predicate</a></h3>
<DD>

Predicates are represented in CycL by constants that are sometimes referred 
to as "CycL predicates" or, more casually, as "predicates."  Like 
CycL <A HREF="#function">functions </A> (the other kind of relation-denoting constants), 
CycL predicates can be used as the leading term (after the initial parenthesis) in CycL 
expressions.  When a CycL predicate is applied to the right number 
and type of <A HREF="#argument">arguments</A>, the expression formed is a 
<A HREF="#CycLForm">CycL formula</A>--a formula expressing a 
proposition about something.  In contrast, expressions formed with functions as 
arg 0 (in the leading position) are terms and so do not express propositions.<p>

By convention, constants that denote predicates begin with 
lowercase letters.<p>

For more information about the syntax and use of predicates in CYC&reg;, click
<A HREF="cycl-syntax.html#predicates">here</a>.<p>

<DT><H3><A NAME="quantification">quantification</a></h3>
<DD>

Quantification is a way to talk about objects without being specific
about the identity of the objects involved.  There are two kinds of
quantification: <A HREF="#existential quantification">existential</A>
and <A HREF="#universal-quantification">universal</A>.  Each
quantification uses one <A HREF="#quantifier">quantifier</A> and one <A
HREF="#variable">variable</A>.  For details on quantification, click <A
HREF="cycl-syntax.html#quantification">here</A>.<p>

<DT><H3><A NAME="quantifier">quantifier</a></h3>
<DD>

A quantifier is a special type of CYC&reg; <A HREF="#constant">constant</A>
used in <A HREF="#quantification">quantification</A>.  CycL contains
five quantifiers: <a href=/cycdoc/vocab/fundamental-vocab.html#forAll>#$forAll</a>, <a href=/cycdoc/vocab/fundamental-vocab.html#thereExists>#$thereExists</a>,
<a href=/cycdoc/vocab/fundamental-vocab.html#thereExistAtLeast>#$thereExistAtLeast</a>, <a href=/cycdoc/vocab/fundamental-vocab.html#thereExistAtMost>#$thereExistAtMost</a>, and
<a href=/cycdoc/vocab/fundamental-vocab.html#thereExistExactly>#$thereExistExactly</a>.  Each quantifier introduces a new <A
HREF="#variable">variable</A>.<p>

<DT><H3><A NAME="reification">reification</a></h3>
<DD>

To reify something is to create a CYC&reg; <A HREF="#FORT">FORT</A>
corresponding to that thing, or in other words, it is to add a thing that 
denotes it to Cyc's <A HREF="#KB">knowledge base</A>.  Cyclists commonly use the 
term "reify" in two slightly different ways:<p>

<ul>

<li>Reifying a concept refers to the manual creation of a CYC&reg; <A
HREF="#constant">constant</A> to denote that concept.<p>

<li>Reifying a <A HREF="#NAT">NAT</A> refers to the automatic preservation in the 
CYC&reg; ontology of FORTs corresponding to non-atomic terms that use elements of 
<a href=/cycdoc/vocab/fundamental-vocab.html#ReifiableFunction>#$ReifiableFunction</a>.  For more on this topic, click 
<A HREF="cycl-syntax.html#reifiable-functions">here</A>.<p>

</ul><p>

<DT><H3><A NAME="relation">relation</a></h3>
<DD>

In Cyc&reg; "relation" is informally used to refer to <A HREF="#predicate">predicates</A> 
and <A HREF="#function">functions</A>.

In the math or database worlds, a relation is a set of ordered n-tuples.
One might talk about the relation "Father", whose elements include 
(Katherine, Lloyd), (Karen, Wes), (John, Bob), and so on, where 
the first item in each element is a person and the second is that person's biological father. 

CycL relations are also ordered n-tuples.  The notation we use is different 
from that above and depends on whether the relation to be represented by a CycL
<A HREF="#function">function</A> or a CycL <A HREF="#predicate">predicate</A>.
In both cases, we <A HREF="#reification">reify</A> a constant to stand 
for the relation.  In our example, we might call the constant #$FatherFn -- 
an uppercase name, because the relation is a function (people have only one biological father).  
We'd write, for example

<pre>
   (#$FatherFn #$Katherine)
</pre>

to refer to Lloyd, since Katherine and Lloyd are in the "Father" relation.<p>

CycL predicates are the other main sort of relation-denoting constant in CYC&reg;.  
The latter are used to represent relations which are not functions (not single-valued).  
The relation denoted by "parents" should be represented with a CycL predicate.  For 
example, we'd write

<pre>
   (#$parents #$Katherine #$Lloyd)
   (#$parents #$Katherine #$Bonnie)
</pre>

to say that (Katherine, Lloyd) and (Katherine, Bonnie) are in the parents relation.  
The arity of CycL predicates is the same as the arity 
of the represented relation, and the arity of CycL functions is 
one less than the arity of the relations they represent.<p>


<DT><H3><A NAME="remote">remote</a></h3>
<DD>

An old term meaning <A HREF="#inferred">inferred</A>.<p>


<DT><H3><A NAME="rule">rule</a></h3>
<DD>

Informally, a rule is any <A HREF="#CycLForm">CycL formula</A> which
begins with <a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a>, that is, any conditional.  A rule
has two parts, called its <A HREF="#antecedent">antecedent</A> and <A
HREF="#consequent">consequent</A>, or left-hand side and right-hand
side.<p>

<DT><H3><A NAME="scope">scope</a></h3>
<DD>

The scope of a <A HREF="#quantifier">quantifier</A> is the range in
which its corresponding <A HREF="#variable">variable</A> is bound.  It
begins with the left parenthesis which precedes the quantifier, and ends
with the matching right parenthesis.<p>

<DT><H3><A NAME="Skolem function">Skolem function</a></h3>
<DD>

Skolem functions are CycL <A HREF="#function">functions</A> which are
used in the implementation of formulas that use 
<A HREF="#existential quantification">existential quantification</A>.  They are 
instances of <a href=/cycdoc/vocab/fundamental-vocab.html#ReifiableFunction>#$ReifiableFunction</a>, and are automatically generated.  For more
information about skolem functions, click <A
HREF="cycl-syntax.html#skolemization">here</A>.<p>

<DT><H3><A NAME="skolemization">skolemization</a></h3>
<DD>

This refers to the practice of implementing formulas that use
<A HREF="#existential quantification">existential quantification</A>
by replacing existentially quantified variables with special terms
that use <A HREF="#Skolem function">skolem functions</A> and are a
function of the other variables in the rule.   It can also refer to 
what happens when one of these rules fires:  a new constant is generated, or 
"skolemized".  For more information about skolemization, click 
<A HREF="cycl-syntax.html#skolemization">here</A>.<p>

<DT><H3><A NAME="slot">slot</a></h3>
<DD>

A slot is simply a CycL binary predicate such as <a href=/cycdoc/vocab/time-vocab.html#startingDate>#$startingDate</a>.
Historically, the name derives from the days when CYC&reg; was a <A
HREF="#frame-based">frame-based</A> system.  People will sometimes speak
of a slot <I>on</I> a certain constant, or of a constant <I>having</I>
slots.  One might say, for example, that the constant #$BillM has
a <a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> slot, or that <a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> is a slot on
#$BillM.  This signifies only that there is some <A
HREF="#GAF">GAF</A> in the KB having <a href=/cycdoc/vocab/social-vocab.html#likesAsFriend>#$likesAsFriend</a> as its predicate and
#$BillM as its first argument.<p>

<DT><H3><A NAME="source">source</a></h3>
<DD>

An old word for <A HREF="#argument">argument</A>.<p>

<DT><H3><A NAME="spec">spec</a></h3>
<DD>

"spec" means "subset".  In Cyc-8, there was a predicate called
#$spec, which was the inverse of <a href=/cycdoc/vocab/fundamental-vocab.html#genls>#$genls</a>.  The predicate
became obsolete in Cyc-9, but Cyclists still use it all the time when
talking about the CYC&reg; <A HREF="#ontology">ontology</A>.  For instance,
one might say, "#$Deity is a spec of <a href=/cycdoc/vocab/agent-vocab.html#Agent>#$Agent</a>."<p>

<DT><H3><A NAME="strength">strength</A></h3>
<DD>

Strength is one of the components of <A HREF="#tv">truth value</A>, which is 
a property of every CYC&reg; <A HREF="#assertion">assertion</a>. Its possible values are
<A HREF="#default">:default</A> and <A HREF="#monotonic">:monotonic</A>.<p>

At the <A HREF="#EL">epistemological level</A>, specifically, when the user is 
<A HREF="#ASSERT">ASSERT</A>ing a formula to CYC&reg;, strength is one of the 
parameters that must be specified.  At the <A HREF="#HL">heuristic level</A>, 
i.e., once assertions are stored in the KB, strength is subsumed by truth value, 
which is a combination of strength and whether or not the original formula was negated.<p>

<DT><H3><A NAME="SubL">SubL</a></h3>
<DD>

SubL stands for SubLanguage, and is a computer language created by the CYC&reg; team.  
It is designed  to be easy to translate into C.  The entire CYC&reg; application is 
written in SubL.<p>

<DT><H3><A NAME="Sublisp">Sublisp</a></h3>
<DD>

An archaic term for SubL.

<DT><H3><A NAME="support">support</a></h3>
<DD>

A support is a <A HREF="#justification">justification</A>.<p>


<DT><H3><A NAME="term">term</a></h3>
<DD>

A term is anything that can be an argument to a predicate or
function.  <A HREF="#variable">Variables</A> are terms.  <A
HREF="#constant">Constants</A>, both <A HREF="#constant-atomic">atomic
constants</A> and <A HREF="#NAT">reified NATs</A>, are terms.
Non-reified NATs are terms.  Numbers, strings, or even entire <A
HREF="#CycLForm">formulas</A> can serve as terms.<p>

<DT><H3><A NAME="transcript">transcript</a></h3>
<DD>

A transcript is a file which records operations performed on the CYC&reg; <A
HREF="#KB">KB</A>.  At a site where several copies of CYC&reg; are in use
simultaneously (such as the Austin office in early 1996), transcripts are
used to keep the various copies of the KB synchronized with each other.
For more on the functioning of the transcript mechanism, click <A
HREF="system.html">here</A>.<p>


<DT><H3><A NAME="transcript-server">transcript server</a></h3>
<DD>

An application separate from the Cyc&reg; program which is used at sites having 
multiple, collaborating Cyc&reg; installations.  The transcript server serializes 
operations from multiple machines and keeps them up-to-date on transmitted (i.e. 
shared) operations.<p>
 

<DT><H3><A NAME="TMS">truth maintenance system (TMS)</a></h3>
<DD>

A truth maintenance system is a mechanism whereby a knowledge based system 
can keep reasonably consistent and truthful as its knowledge changes.  
For example, if facts have been added to the KB through <A HREF="#inference">inference</A>
based on a set of premises, and one of the premises is later removed from the 
KB, any conclusion that depends on that premise should also be removed from the 
KB.  The CYC&reg; TMS relies on the fact that each <A HREF="#assertion">assertion</A>
has all of its <A HREF="#argument">arguments</A> recorded in the datastructure.<p>

<DT><H3><A NAME="tv">truth value</a></h3>
<DD>

In the Cyc&reg; KB, a truth value is a value attached to an <A HREF="#assertion">assertion</A> 
which indicates its degree of truth.  There are five possible truth values:<p>

<DL>
<DT><A HREF="#monotonically true">monotonically true</A> (100)
<DD>

True always and under all conditions.  Normally reserved for things that
are true by definition.

<DT><A HREF="#default true">default true</A> (T)
<DD>

Assumed true, but subject to exceptions.  Most <A HREF="#rule">rules</A>
in the KB are default true.

<DT>unknown (~)
<DD>

Not known to be true, and not known to be false.

<DT>default false (F)
<DD>

Assumed false, but subject to exceptions.

<DT>monotonically false (0)
<DD>

False always and under all conditions.
</DL><p>

Of these, the most commonly used are the first two.<p> 

Each of these truth values is represented by a different colored ball in the KB Browser.  For details on the icons used in the Browser, see the <a href="../help/browser-icon-key.html">Key For Icons In the Browser</a>.<p>

"Truth value" is a <A HREF="#HL">heuristic level</A> property; it is a combination of
what is 2 separate properties at the <A HREF="#EL">epistemological level</A>:
<A HREF="#strength">strength</A> (:default or :monotonic) and negation status 
(whether or not a formula begins with <a href=/cycdoc/vocab/fundamental-vocab.html#not>#$not</a>).<p>

If you are unsure whether to
make an assertion monotonically true or default true, go with the
latter.<p>

For more discussion, click <A HREF="cycl-syntax.html#truth
values">here</A>.<p>

<DT><H3><A NAME="unification">unification</a></h3>
<DD>

Unification is a procedure that compares two expressions to determine
whether some set of legal substitutions exists that can make the two
equal.  This procedure is used in inference, to determine whether to
fire a rule.  For example, in forward inference, if some set of 
assertions in the KB match (can unify with) the antecedent of the rule,
we can fire the rule.
<p>

<DT><H3><A NAME="unit">unit</a></h3>
<DD>

This expression dates from the days when CYC&reg; was a frame-based system.  In
those days, every constant was a named, <A HREF="#constant-atomic">atomic constant</A>, 
and constants were called "<I>units</I>".  Today, Cyclists still occasionally use
"<I>unit</I>" to refer to atomic constants. <p>

<DT><H3><A NAME="uom">unit of measure</a></h3>
<DD>

Any instance of <a href=/cycdoc/vocab/quantity-vocab.html#UnitOfMeasure>#$UnitOfMeasure</a>.  These are functions, like 
<a href=/cycdoc/vocab/quantity-vocab.html#Meter>#$Meter</a> or <a href=/cycdoc/vocab/quantity-vocab.html#Gram>#$Gram</a>, which can be applied to numeric arguments to yield 
quantities, like (<a href=/cycdoc/vocab/quantity-vocab.html#Meter>#$Meter</a> 9) or (<a href=/cycdoc/vocab/quantity-vocab.html#Gram>#$Gram</a> 454).  The resulting expressions are called
<A HREF="#IBQE">interval-based quantity expressions</A>.<p>
<a name="universal quantification">&nbsp;</a>
<DT><H3><A NAME="universal-quantification">universal quantification</a></h3>
<DD>

Quantifying with <a href=/cycdoc/vocab/fundamental-vocab.html#forAll>#$forAll</a>.  In CycL formulas, variables which are not
explicitly bound by a <A HREF="#quantifier">quantifier</A> are assumed to 
be universally quantified.  For example,

<pre>
	(<a href=/cycdoc/vocab/fundamental-vocab.html#forAll>#$forAll</a> ?LEAF (<a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a>
				(<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?LEAF Leaf)
				(<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?LEAF GreenColor)))
</pre>

means that every leaf is green.  But in CycL, this sentence means the same as the 
following sentence:

<pre>
	(<a href=/cycdoc/vocab/fundamental-vocab.html#implies>#$implies</a>
		(<a href=/cycdoc/vocab/fundamental-vocab.html#isa>#$isa</a> ?LEAF Leaf)
		(<a href=/cycdoc/vocab/material-vocab.html#colorOfObject>#$colorOfObject</a> ?LEAF GreenColor))
</pre>


<p>

<DT><H3><A NAME="variable">variable</a></h3>
<DD>

One type of <A HREF="#term">term</A>.  Variables appear in CYC&reg; 
<A HREF="#rule">rules</A> to stand for not-known-in-advance constants
that satisfy the formula of the rule.  Variables also
are used in formulas given to the <A HREF="#ASK">ASK</A> utility, to stand for 
the results the asker wishes to find.  For more information about 
variables, click <A HREF="cycl-syntax.html#variables">here</A>.<p>

<DT><H3><A NAME="well-formed">well-formed</a></h3>
<DD>

A formula in CycL is well-formed if it conforms to the syntax of CycL
and passes all the restrictions on <A HREF="#arity">arity</A>
and argument types of the <A
HREF="#relation">relations</A> that are used in it.  For lots of
information on what makes a formula well-formed, read these sections on 
<A HREF="cycl-syntax.html#predicates">predicates</A>, 
<A HREF="cycl-syntax.html#well-formedness">complex formulas</A>, and 
<A href="cycl-syntax.html#well-formedness-2">quantified formulas</A>.<p>


</DL>


<hr>
<a href=#top><img src="/cycdoc/img/cyc-ball-sm.gif" border=0>Go to Top</a><br>

</body>



</html>
