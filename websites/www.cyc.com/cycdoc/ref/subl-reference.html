<html>

<title>SubL Reference</title>
<body bgcolor="#FFFFFF">
<a name="top"></a>
<h2><a href=http://www.opencyc.org><img src=/cycdoc/img/opencyc-logo-small.gif border=0 alt="OpenCyc.org Homepage"></a>SubL Reference</h2>

E-Mail Comments to: <a href=mailto:opencyc-doc@cyc.com>opencyc-doc@cyc.com</a><br>


Last Update: 03/28/2002<br>

<i>Copyright&copy; 1996-2002 <a href="http://www.cyc.com">Cycorp</a>.  All rights reserved.</i>  <br>

<hr>

<h1>How to Use this Document</h1>

<p>
SubL is a computer language built by members of Cycorp.  SubL was
written to support the Cyc&reg; application, allowing it to run both
under Lisp environments and as a C application generated by a
SubL-to-C translator.  This document describes the primitive functions
of SubL.

<p>
Due to the close similarities between SubL and Common Lisp, the 
<a href=#Table-of-Contents>
Table of Contents
</a>
and structure of this document intentionally mirror that of

<blockquote>
<b>"Common Lisp: The Language"</b>,<br>
2nd Edition,<br> 
Guy L. Steele Jr<br>
</blockquote>

making it easy to compare and contrast the two languages.  For the
most part, this document focuses only on the differences between SubL
and Common Lisp.

<p>
An online version of
<a href=http://www.supelec.fr/docs/cltl/clm/clm.html>
"Common Lisp: The Language"
</a>
can be found at
<blockquote>
<a href=http://www.supelec.fr/docs/cltl/clm/clm.html>
<b><tt>http://www.supelec.fr/docs/cltl/clm/clm.html</tt></b>
</a> 
</blockquote>
and an
<a href=http://www.supelec.fr/docs/cltl/clm/index.html>
index to all Common Lisp functions
</a>
can be found at
<blockquote>
<a href=http://www.supelec.fr/docs/cltl/clm/index.html>
<b><tt>http://www.supelec.fr/docs/cltl/clm/index.html</tt></b>
</a> 
</blockquote>

<p>
Each section of this document contains a link labelled <b>"CLtL2
Reference"</b> to the corresponding sections of the above online Common
Lisp reference.  The reader is strongly encouraged to consult that
reference in parallel with this document.

<!----- Major Section ---------------------------------------->
<a name=Table-of-Contents></a>
<hr>
<h1>0 : Table of Contents</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node1.html>
CLtL2 Reference
</a>

<p>
<ul type=disc>

<li><a href=#Table-of-Contents>0 : Table of Contents</a>

<li><a href=#Introduction>1 : Introduction</a>

<li><a href=#Data-Types>2 : Data Types</a>

<li><a href=#Scope-and-Extent>3 : Scope and Extent</a>

<li><a href=#Type-Specifiers>4 : Type Specifiers</a>

<li><a href=#Program-Structure>5 : Program Structure</a>
<ul type=disc>
<li><a href=#Defining-Named-Functions>
5.3.1 : Defining Named Functions</a>
<li><a href=#Declaring Global-Variables-and-Named-Constants>
5.3.2 : Declaring Global Variables and Named Constants</a>
</ul>

<li><a href=#Predicates>6 : Predicates</a>
<ul type=disc>
<li><a href=#Logical-Values>
6.1 : Logical Values</a>
<li><a href=#Specific-Data-Type-Predicates>
6.2.2 : Specific Data Type Predicates</a>
<li><a href=#Equality-Predicates>
6.3 : Equality Predicates</a>
<li><a href=#Logical-Operators>
6.4 : Logical Operators</a>
</ul>

<li><a href=#Control-Structure>7 : Control Structure</a>
<ul type=disc>
<li><a href=#Reference>
7.1.1 : Reference</a>
<li><a href=#Assignment>
7.1.2 : Assignment</a>
<li><a href=#Generalized-Variables>
7.2 : Generalized Variables</a>
<li><a href=#Function-Invocation>
7.3 : Function Invocation</a>
<li><a href=#Simple-Sequencing>
7.4 : Simple Sequencing</a>
<li><a href=#Establishing-New-Variable-Bindings>
7.5 : Establishing New Variable Bindings</a>
<li><a href=#Conditionals>
7.6 : Conditionals</a>
<li><a href=#Blocks-and-Exits>
7.7 : Blocks and Exits</a>
<li><a href=#General-Iteration>
7.8.2 : General Iteration</a>
<li><a href=#Simple-Iteration-Constructs>
7.8.3 : Simple Iteration Constructs</a>
<li><a href=#Mapping>
7.8.4 : Mapping</a>
<li><a href=#Constructs-for-Handling-Multiple-Values>
7.10.1 : Constructs for Handling Multiple Values</a>
<li><a href=#Rules-Governing-the-Passing-of-Multiple-Values>
7.10.2 : Rules Governing the Passing of Multiple Values</a>
<li><a href=#Dynamic-Non-Local-Exits>
7.11 : Dynamic Non-Local Exits</a>
</ul>

<li><a href=#Macros>8 : Macros</a>
<ul type=disc>
<li><a href=#Macro-Definition>
8.1 : Macro Definition</a>
<li><a href=#Destructuring>
8.3 : Destructuring</a>
<li><a href=#Environments>
8.5 : Environments</a>
</ul>

<li><a href=#Declarations>9 : Declarations</a>
<ul type=disc>
<li><a href=#Declaration-Syntax>
9.1 : Declaration Syntax</a>
<li><a href=#Declaration-Specifiers>
9.2 : Declaration Specifiers</a>
</ul>

<li><a href=#Symbols>10 : Symbols</a>
<ul type=disc>
<li><a href=#The-Property-List>10.1 : The Property List</a>
<li><a href=#The-Print-Name>10.2 : The Print Name</a>
<li><a href=#Creating-Symbols>10.3 : Creating Symbols</a>
</ul>

<li><a href=#Packages>11 : Packages</a>

<li><a href=#Numbers>12 : Numbers</a>
<ul type=disc>
<li><a href=#Predicates-on-Numbers>
12.2 : Predicates on Numbers</a>
<li><a href=#Comparisons-on-Numbers>
12.3 : Comparisons on Numbers</a>
<li><a href=#Arithmetic-Operations>
12.4 : Arithmetic Operations</a>
<li><a href=#Irrational-and-Transcendental-Functions>
12.5 : Irrational and Transcendental Functions</a>
<li><a href=#Type-Conversions-and-Component-Extractions-on-Numbers>
12.6 : Type Conversions and Component Extractions on Numbers</a>
<li><a href=#Logical-Operations-on-Numbers>
12.7 : Logical Operations on Numbers</a>
<li><a href=#Byte-Manipulation-Functions>
12.8 : Byte Manipulation Functions</a>
<li><a href=#Random-Numbers>
12.9 : Random Numbers</a>
<li><a href=#Implementation-Parameters>
12.10 : Implementation Parameters</a>
</ul>

<li><a href=#Characters>13 : Characters</a>
<ul type=disc> 
<li><a href=#Character-Attributes>
13.1 : Character Attributes</a>
<li><a href=#Predicates-on-Characters>
13.2 : Predicates on Characters</a>
<li><a href=#Character-Construction-and-Selection>
13.3 : Character Construction and Selection</a>
<li><a href=#Character-Conversions>
13.4 : Character Conversions</a>
</ul>

<li><a href=#Sequences>14 : Sequences</a>
<ul type=disc> 
<li><a href=#Simple-Sequence-Functions>
14.1 : Simple Sequence Functions</a>
<li><a href=#Concatenating-Mapping-and-Reducing-Sequences>
14.2 : Concatenating, Mapping and Reducing Sequences</a>
<li><a href=#Modifying-Sequences>
14.3 : Modifying Sequences</a>
<li><a href=#Searching-Sequences-for-Terms>
14.4 : Searching Sequences for Terms</a>
<li><a href=#Sorting-and-Merging>
14.5 : Sorting and Merging</a>
</ul>

<li><a href=#Lists-Chapter>15 : Lists</a>
<ul type=disc> 
<li><a href=#Conses>
15.1 : Conses</a>
<li><a href=#Lists>
15.2 : Lists</a>
<li><a href=#Alteration-of-List-Structure>
15.3 : Alteration of List Structure</a>
<li><a href=#Substitution-of-Expressions>
15.4 : Substitution of Expressions</a>
<li><a href=#Using-Lists-as-Sets>
15.5 : Using Lists as Sets</a>
<li><a href=#Association-Lists>
15.6 : Association Lists</a>
</ul>

<li><a href=#Hash-Tables>16 : Hash Tables</a>
<ul type=disc> 
<li><a href=#Hash-Table-Functions>
16.1 : Hash Table Functions</a>
<li><a href=#Primitive-Hash-Function>
16.2 : Primitive Hash Function</a>
</ul>

<li><a href=#Arrays>17 : Arrays</a>
<ul type=disc> 
<li><a href=#Vector-Creation>
17.1 : Vector Creation</a>
<li><a href=#Vector-Access>
17.2 : Vector Access</a>
</ul>

<li><a href=#Strings>18 : Strings</a>
<ul type=disc> 
<li><a href=#String-Access>
18.1 : String Access</a>
<li><a href=#String-Comparison>
18.2 : String Comparison</a>
<li><a href=#String-Construction-and-Manipulation>
18.3 : String Construction and Manipulation</a>
</ul>

<li><a href=#Structures>19 : Structures</a>

<li><a href=#The-Evaluator>20 : The Evaluator</a>
<ul type=disc> 
<li><a href=#Run-Time-Evaluation-of-Forms>
20.1 : Run-Time Evaluation of Forms</a>
<li><a href=#The-Top-Level-Loop>
20.2 : The Top-Level Loop</a>
</ul>

<li><a href=#Streams>21 : Streams</a>
<ul type=disc> 
<li><a href=#Standard-Streams>
21.1 : Standard Streams</a>
<li><a href=#Creating-new-Streams>
21.2 : Creating new Streams</a>
<li><a href=#Operations-on-Streams>
21.3 : Operations on Streams</a>
</ul>

<li><a href=#Input-Output>22 : Input/Output</a>
<ul type=disc> 
<li><a href=#Printed-Representation-of-SubL-Objects>
22.1 : Printed Representation of SubL Objects</a>
<li><a href=#Macro-Characters>
22.1.3 : Macro Characters</a>
<li><a href=#Standard-Dispatching-Macro-Character-Syntax>
22.1.4 : Standard Dispatching Macro Character Syntax</a>
<li><a href=#The-Readtable>
22.1.5 : The Readtable</a>
<li><a href=#What-the-Print-Function-Produces>
22.1.6 : What the Print Function Produces</a>
<li><a href=#Input-from-Character-Streams>
22.2.1 : Input from Character Streams</a>
<li><a href=#Input-from-Binary-Streams>
22.2.2 : Input from Binary Streams</a>
<li><a href=#Output-to-Character-Streams>
22.3.1 : Output to Character Streams</a>
<li><a href=#Output-to-Binary-Streams>
22.3.2 : Output to Binary Streams</a>
<li><a href=#Formatted-Output-to-Character-Streams>
22.3.3 : Formatted Output to Character Streams</a>
</ul>

<li><a href=#File-System-Interface>23 : File System Interface</a>
<ul type=disc> 
<li><a href=#File-Names>
23.1 : File Names</a>
<li><a href=#Opening-and-Closing-Files>
23.2 : Opening and Closing Files</a>
<li><a href=#Renaming-Deleting-and-Other-File-Operations>
23.3 : Renaming, Deleting and Other File Operations</a>
<li><a href=#Loading-Files>
23.4 : Loading Files</a>
<li><a href=#Accessing-Directories>
23.5 : Accessing Directories</a>
</ul>

<li><a href=#Errors>24 : Errors</a>
<ul type=disc> 
<li><a href=#General-Error-Signalling-Functions>
24.1 : General Error-Signalling Functions</a>
<li><a href=#Specialized-Error-Signalling-Forms-and-Macros>
24.2 : Specialized Error-Signalling Forms and Macros</a>
</ul>

<li><a href=#Miscellaneous-Features>25 : Miscellaneous Features</a>
<ul type=disc> 
<li><a href=#The-Compiler>
25.1 : The Compiler</a>
<li><a href=#Debugging-Tools>
25.3 : Debugging Tools</a>
<li><a href=#Time-Functions>
25.4.1 : Time Functions</a>
<li><a href=#Identity-Function>
25.5 : Identity Function</a>
</ul>

<li><a href=#Common-Lisp-Object-System>28 : Common Lisp Object System</a>

<li><a href=#SubL-Specific-Features>SubL-Specific Features</a>
<ul type=disc>
<li><a href=#Signals>
SubL.1 : Signals</a>
<li><a href=#System-Properties>
SubL.2 : System Properties</a>
<li><a href=#Progress-Pacifiers>
SubL.3 : Progress Pacifiers</a>
<li><a href=#Process-Manipulation>
SubL.4 : Process Manipulation</a>
<li><a href=#Memory-Interaction>
SubL.5 : Memory Interaction</a>
</ul>

<li><a href=#Index>Index</a>
</ul>

<!----- Major Section ---------------------------------------->
<a name=Introduction></a>
<hr>
<h1>1 : Introduction</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node5.html>
CLtL2 Reference
</a>

<p>
SubL is a programming language intended to be very similar to a
simplified version of Common Lisp where those features that are either
complex, rarely-used, or difficult to implement in a prodecural
language have been excised.

<p>
Unlike Common Lisp, SubL is not a purely functional language.  Several
SubL constructs can only be used procedurally.  In order to emphasize
this difference, the following naming convention for SubL constructs
is used:

<blockquote>
A SubL function will have the same name as the analogous Common Lisp
function if it is intended to have the exact same basic functionality.
The argument list may be simplified, but the intent and use are likely
to be the same.
</blockquote>

If there is a substantial behavioral difference between a SubL
function and its Common Lisp counterpart, its name will be the Common
Lisp name prepended with a single character -- either "c", "p" or "f".

<blockquote>
"c" indicates a construct that is either only procedural or functional.<br>
"p" indicates the procedural version of a Common Lisp construct.<br>
"f" indicates the functional version of a Common Lisp construct.<br>
</blockquote>


<p>
A procedural construct in SubL is one which is suitable for evaluation
as either one form in an explicit <a href="#FN-DEF-PROGN"><tt>PROGN</tt></a><fn-ref> or as one form in an
implicit progn, which occur in the <tt>&body</tt> sections of many of
the procedural forms such as <a href="#FN-DEF-CLET"><tt>CLET</tt></a><fn-ref>, <a href="#FN-DEF-PWHEN"><tt>PWHEN</tt></a><fn-ref>,
<a href="#FN-DEF-CDOLIST"><tt>CDOLIST</tt></a><fn-ref> etc.

<p>
Here is a table of all the procedural constructs in SubL and the
Common Lisp analog:

<p>
<blockquote>
<table>
<tr>
<td><b>
SubL Procedural Construct
</b></td>
<td><pre>   </pre></td>
<td><b>
Common Lisp Equivalent
</b></td>
</tr>

<tr><td colspan=3><hr></td></tr>

<tr>
<td><tt>
<a href="#FN-DEF-PROGN"><tt>PROGN</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
progn
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-PIF"><tt>PIF</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
if
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-PWHEN"><tt>PWHEN</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
when
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-PUNLESS"><tt>PUNLESS</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
unless
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-PCOND"><tt>PCOND</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
cond
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-PCASE"><tt>PCASE</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
case
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CSETQ"><tt>CSETQ</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
setq
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
setf
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CINC"><tt>CINC</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
incf
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CDEC"><tt>CDEC</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
decf
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CPUSH"><tt>CPUSH</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
push
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CPUSHNEW"><tt>CPUSHNEW</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
pushnew
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CPOP"><tt>CPOP</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
pop
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CLET"><tt>CLET</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
let*
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CMULTIPLE-VALUE-BIND"><tt>CMULTIPLE-VALUE-BIND</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
multiple-value-bind
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CDO"><tt>CDO</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
do*
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CDOLIST"><tt>CDOLIST</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
dolist
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CSOME"><tt>CSOME</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>

</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CDOTIMES"><tt>CDOTIMES</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
dotimes
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CDOHASH"><tt>CDOHASH</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>

</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CCATCH"><tt>CCATCH</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
catch
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CUNWIND-PROTECT"><tt>CUNWIND-PROTECT</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
unwind-protect
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-RET"><tt>RET</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
return-from
</tt></td>
</tr>

</table>
</blockquote>

<p>
A functional construct in SubL is one which returns a value.  Here is
a table of all the functional constructs in SubL and the Common Lisp
analog:

<p>
<blockquote>
<table>
<tr>
<td><b>
SubL Functional Construct
</b></td>
<td><pre>   </pre></td>
<td><b>
Common Lisp Equvalent
</b></td>
</tr>

<tr><td colspan=3><hr></td></tr>

<tr>
<td><tt>
<a href="#FN-DEF-CAND"><tt>CAND</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
and
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-COR"><tt>COR</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
or
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-CNOT"><tt>CNOT</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
not
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-FIF"><tt>FIF</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
if
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-FWHEN"><tt>FWHEN</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
when
</tt></td>
</tr>

<tr>
<td><tt>
<a href="#FN-DEF-FUNLESS"><tt>FUNLESS</tt></a><fn-ref>
</tt></td>
<td></td>
<td><tt>
unless
</tt></td>
</tr>

</table>
</blockquote>

<p>
The body of a function or macro definition is considered an implicit
progn, and so all forms in the body should be procedural.  A function
call can be used as a procedural construct.  In this case, the
returned value is simply ignored.


<!----- Major Section ---------------------------------------->
<a name=Data-Types></a>
<hr>
<h1>2 : Data Types</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node15.html>
CLtL2 Reference
</a>

<p>
SubL has a flat type heirarchy.  Each type is described in more detail
in the sections about the methods for that particular type.  

<p>
SubL supports these built-in Common Lisp datatypes:

<blockquote>
<table>
<tr><td>Numbers:</td>		<td>fixnum</td></tr>
<tr><td></td>			<td>float</td></tr>
<tr><td>Symbols:</td>		<td>symbol</td></tr>
<tr><td>Lists:</td>		<td>cons</td></tr>
<tr><td>Arrays:</td>		<td>vector</td></tr>
<tr><td>Characters:</td>	<td>character</td></tr>
<tr><td>Strings:</td>		<td>string</td></tr>
<tr><td>Hashtables:</td>	<td>eq hashtable</td></tr>
<tr><td></td>			<td>eql hashtable</td></tr>
<tr><td></td>			<td>equal hashtable</td></tr>
<tr><td></td>			<td>equalp hashtable</td></tr>
<tr><td>Streams:</td>		<td>stream</td></tr>
<tr><td>Functions:</td>		<td>function</td></tr>
</table>
</blockquote>

<p>
SubL does <b>not</b> support these Common Lisp datatypes: 

<blockquote>
Multi-dimensional arrays<br>
Packages<br>
Pathnames<br>
Random-states<br>
Lambda-Expressions or Closures<br>
</blockquote>

<p>
SubL has only special-case support for these datatypes: 

<p>
<blockquote>
<table>
<tr><td>Readtables:</td><td>SubL only supports a single internal readtable</td></tr>
</table>
</blockquote>

<p>
New data types can be introduced via <a href="#FN-DEF-DEFSTRUCT"><tt>DEFSTRUCT</tt></a><fn-ref>.

<!----- Major Section ---------------------------------------->
<a name=Scope-and-Extent></a>
<hr>
<h1>3 : Scope and Extent</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node43.html>
CLtL2 Reference
</a>

<p>
Special variables in SubL are all (and only) those variables defined
globally with <a href="#FN-DEF-DEFVAR"><tt>DEFVAR</tt></a><fn-ref> or <a href="#FN-DEF-DEFPARAMETER"><tt>DEFPARAMETER</tt></a><fn-ref>.  In addition,
the name of each special variable must begin and end with an asterisk
character : <tt>'*'</tt>.

<p>
Special variables have indefinite scope and dynamic extent.  All other
variables have lexical scope and dynamic extent

<p>
Variables are introduced via:

<p>
<dl>

<dt>
<b>
Function call
</b>
</dt>
<dd>
A new set of variables for the formal parameters of the function are introduced.
The extent of the function arguments is the duration of the function invocation.
</dd>

<dt>
<b>
<a href="#FN-DEF-CLET"><tt>CLET</tt></a><fn-ref>,
<a href="#FN-DEF-CMULTIPLE-VALUE-BIND"><tt>CMULTIPLE-VALUE-BIND</tt></a><fn-ref>,
<a href="#FN-DEF-CDESTRUCTURING-BIND"><tt>CDESTRUCTURING-BIND</tt></a><fn-ref>
</b>
</dt>
<dd>
These constructs explicitly introduce and initialize new local variables.
The extent of these variables is until exit from the constuct.
</dd>

<dt>
<b>
<a href="#FN-DEF-CDO"><tt>CDO</tt></a><fn-ref>,
<a href="#FN-DEF-CDOLIST"><tt>CDOLIST</tt></a><fn-ref>,
<a href="#FN-DEF-CSOME"><tt>CSOME</tt></a><fn-ref>,
<a href="#FN-DEF-CDOTIMES"><tt>CDOTIMES</tt></a><fn-ref>,
<a href="#FN-DEF-CDOHASH"><tt>CDOHASH</tt></a><fn-ref>
</b>
</dt>
<dd>
These iteration constructs explicitly introduce and update local variables
which represent the state of the iteration.  The extent of these variables
is until exit from the iteration construct.
</dd>
</dl>

<p>
When a local variable is introduced with the same name as a local
variable which is already within the current scope and extent, the new
variable shadows the outer variable.

<p>
The initialization of a local variable is considered to occur within
the scope of the new local variable.  Consequently, a variable which
is shadowing an outer variable cannot be initialized in terms of the
outer value.  For example, this is not allowed :

<blockquote>
<pre>
(define foo (x)
  (clet ((x (+ x 1)))
    (print x))
  (ret nil))
</pre>
</blockquote>

<p>
However, if the variable is a special variable, the <a href="#FN-DEF-CLET"><tt>CLET</tt></a><fn-ref> is
actually introducing a binding for the special variable, not
introducing a new local variable.  In this case, the initialization of
the binding can be a function of its current value for the variable
being bound.  For example, this is allowed:

<blockquote>
<pre>
(defvar *some-var* 1)

(define foo (x)
  (clet ((*some-var* (+ *some-var* x)))
    (print *some-var*))
  (ret nil))
</pre>
</blockquote>

<p>
The construct <a href="#FN-DEF-RET"><tt>RET</tt></a><fn-ref> must be used for a function or macro
definition to return its intended result.  

<!----- Major Section ---------------------------------------->
<a name=Type-Specifiers></a>
<hr>
<h1>4 : Type Specifiers</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node44.html>
CLtL2 Reference
</a>

<p>
SubL does not support type specifiers.

<!----- Major Section ---------------------------------------->
<a name=Program-Structure></a>
<hr>
<h1>5 : Program Structure</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node55.html>
CLtL2 Reference
</a>

<p>
Program structure in SubL mirrors that of Common Lisp almost exactly.
All objects except lists and symbols are self-evaluating.  This
includes numbers, characters, strings, vectors and hashtables.  In
addition :

<ul>
<li>
Keyword symbols are self-evaluating.

<li>
The symbols T and NIL are self-evaluating.
</ul>

<!------------------------------>
<a name=Defining-Named-Functions></a>
<h2>5.3.1 : Defining Named Functions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node66.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-DEFINE"></a>macro <tt><b>DEFINE</b> : (name arglist &amp;body body)</tt><fn-def>

<p>
All functions in SubL must be named and therefore defined via the SubL
construct <a href="#FN-DEF-DEFINE"><tt>DEFINE</tt></a><fn-ref>.

See also the similar construct <a href="#FN-DEF-DEFPOLYMORPHIC"><tt>DEFPOLYMORPHIC</tt></a><fn-ref> which is used
to define generic functions which switch off the type of the first
argument.

<p>
Argument lists for user-defined function can only be of this form:

<blockquote>
<pre>
<b>(</b> {var}* [<b>&optional</b> {var | <b>(</b> var [initform [supplied-var]] <b>)</b> }*] <b>)</b>
</pre>
</blockquote>

<p>
In short, SubL supports <tt>&optional</tt> arguments for user-defined
functions but does <b>not</b> support <tt>&keyword</tt>, <tt>&aux</tt>
or <tt>&rest</tt> arguments for user-defined functions.

<!------------------------------>
<a name=Declaring Global-Variables-and-Named-Constants></a>
<h2>5.3.2 : Declaring Global Variables and Named Constants</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node67.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-DEFVAR"></a>macro <tt><b>DEFVAR</b> : (variable &amp;optional initialization documentation)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DEFPARAMETER"></a>macro <tt><b>DEFPARAMETER</b> : (variable initialization &amp;optional documentation)</tt><fn-def>

<p>
<a href="#FN-DEF-DEFVAR"><tt>DEFVAR</tt></a><fn-ref> and <a href="#FN-DEF-DEFPARAMETER"><tt>DEFPARAMETER</tt></a><fn-ref> are the SubL constructs used
to define global variables.  The name of each variable must begin and
end with an asterisk.

<p>
SubL enforces an important distinction between these two constructs,
which is described in greater detail under <a href="#FN-DEF-WRITE-IMAGE"><tt>WRITE-IMAGE</tt></a><fn-ref>.

<br>
<br>
<a name="FN-DEF-DEFCONSTANT"></a>macro <tt><b>DEFCONSTANT</b> : (variable initialization &amp;optional documentation)</tt><fn-def>

<p>
As with <a href="#FN-DEF-DEFVAR"><tt>DEFVAR</tt></a><fn-ref> and <a href="#FN-DEF-DEFPARAMETER"><tt>DEFPARAMETER</tt></a><fn-ref>, the name of each
named constant defined via <a href="#FN-DEF-DEFCONSTANT"><tt>DEFCONSTANT</tt></a><fn-ref> must begin and end
with an asterisk.

<!----- Major Section ---------------------------------------->
<a name=Predicates></a>
<hr>
<h1>6 : Predicates</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node69.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=Logical-Values></a>
<h2>6.1 : Logical Values</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node70.html>
CLtL2 Reference
</a>

<p> 
The symbols NIL and T are used to represent the logical values "true"
and "false" in SubL and behave exactly as they do in Common Lisp.

<!------------------------------>
<a name=Specific-Data-Type-Predicates></a>
<h2>6.2.2 : Specific Data Type Predicates</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node73.html>
CLtL2 Reference
</a>

<p>
For the most part, the following predicates which check for specific
data types behave exactly as they do in Common Lisp.

<br>
<br>
<a name="FN-DEF-NULL"></a>function <tt><b>NULL</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SYMBOLP"></a>function <tt><b>SYMBOLP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-ATOM"></a>function <tt><b>ATOM</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CONSP"></a>function <tt><b>CONSP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-LISTP"></a>function <tt><b>LISTP</b> : (x)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-NUMBERP"></a>function <tt><b>NUMBERP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-INTEGERP"></a>function <tt><b>INTEGERP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FLOATP"></a>function <tt><b>FLOATP</b> : (x)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CHARACTERP"></a>function <tt><b>CHARACTERP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRINGP"></a>function <tt><b>STRINGP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-VECTORP"></a>function <tt><b>VECTORP</b> : (x)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-FUNCTIONP"></a>function <tt><b>FUNCTIONP</b> : (x)</tt><br>
Follows the CLtL2 implementation<fn-def>
<br>
<br>
<a name="FN-DEF-FUNCTION-SPEC-P"></a>function <tt><b>FUNCTION-SPEC-P</b> : (x)</tt><br>
Returns T IFF x is an object suitable for FUNCALL<fn-def>

<p>
In SubL, <a href="#FN-DEF-FUNCTIONP"><tt>FUNCTIONP</tt></a><fn-ref> only returns T if its argument is a
function object.  The function <a href="#FN-DEF-FUNCTION-SPEC-P"><tt>FUNCTION-SPEC-P</tt></a><fn-ref> returns T if
its argument is suitable for <a href="#FN-DEF-FUNCALL"><tt>FUNCALL</tt></a><fn-ref> or <a href="#FN-DEF-APPLY"><tt>APPLY</tt></a><fn-ref>.

<!------------------------------>
<a name=Equality-Predicates></a>
<h2>6.3 : Equality Predicates</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node74.html>
CLtL2 Reference
</a>

<p>
The SubL equality predicates behave exactly like their Common Lisp
counterparts.

<br>
<br>
<a name="FN-DEF-EQ"></a>function <tt><b>EQ</b> : (x y)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-EQL"></a>function <tt><b>EQL</b> : (x y)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-EQUAL"></a>function <tt><b>EQUAL</b> : (x y)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-EQUALP"></a>function <tt><b>EQUALP</b> : (x y)</tt><fn-def>

<!------------------------------>
<a name=Logical-Operators></a>
<h2>6.4 : Logical Operators</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node75.html>
CLtL2 Reference
</a>

<p>
SubL logical operations <b>only</b> return T or NIL.  Otherwise, they
behave like their Common Lisp counterparts.

<br>
<br>
<a name="FN-DEF-CNOT"></a>macro <tt><b>CNOT</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CAND"></a>macro <tt><b>CAND</b> : (&amp;rest args)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-COR"></a>macro <tt><b>COR</b> : (&amp;rest args)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Control-Structure></a>
<hr>
<h1>7 : Control Structure</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node76.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=Reference></a>
<h2>7.1.1 : Reference</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node78.html>
CLtL2 Reference
</a>

<p>
These SubL constructs behave exactly like their Common Lisp
counterparts.

<br>
<br>
<a name="FN-DEF-QUOTE"></a>function <tt><b>QUOTE</b> : (data)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FUNCTION"></a>macro <tt><b>FUNCTION</b> : (fspec)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SYMBOL-VALUE"></a>function <tt><b>SYMBOL-VALUE</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SYMBOL-FUNCTION"></a>function <tt><b>SYMBOL-FUNCTION</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-BOUNDP"></a>function <tt><b>BOUNDP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FBOUNDP"></a>function <tt><b>FBOUNDP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Assignment></a>
<h2>7.1.2 : Assignment</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node79.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CSETQ"></a>macro <tt><b>CSETQ</b> : (var value &amp;rest var-val-pairs)</tt><fn-def>

<p>
Since <a href="#FN-DEF-CSETQ"><tt>CSETQ</tt></a><fn-ref> is procedural in SubL, it does not return a
value.  Otherwise, it behaves just like <tt>setq</tt> in Common Lisp.

<p> 
These SubL functions for setting and unsetting symbol properties behave
like their Common Lisp counterparts.

<br>
<br>
<a name="FN-DEF-SET"></a>function <tt><b>SET</b> : (symbol value)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MAKUNBOUND"></a>function <tt><b>MAKUNBOUND</b> : (symbol)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FMAKUNBOUND"></a>function <tt><b>FMAKUNBOUND</b> : (symbol)</tt><fn-def>

<!------------------------------>
<a name=Generalized-Variables></a>
<h2>7.2 : Generalized Variables</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node80.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CSETF"></a>macro <tt><b>CSETF</b> : (place val)</tt><fn-def>

<p>
<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> is a more restricted version of <tt>setf</tt> in Common
Lisp.  First, since it is procedural, like <a href="#FN-DEF-CSETQ"><tt>CSETQ</tt></a><fn-ref> it does not
return a value.  Second, there is a much more restricted set of
place-specifiers which are allowable.  Here is a complete table of the
allowable <a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> forms, and their equivalent SubL expansions:

<p>
<center>
<table>
<tr>
<td><b>
CSETF form
</b></td>
<td><pre>   </pre></td>
<td><b>
Equivalent SubL expansion
</b></td>
</tr>

<tr><td colspan=3><hr></td></tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref></b> variable value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-CSETQ"><tt>CSETQ</tt></a><fn-ref></b> variable value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (<a href="#FN-DEF-AREF"><tt>AREF</tt></a><fn-ref></b> vector n<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-SET-AREF"><tt>SET-AREF</tt></a><fn-ref></b> vector n value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (<a href="#FN-DEF-NTH"><tt>NTH</tt></a><fn-ref></b> n list<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-SET-NTH"><tt>SET-NTH</tt></a><fn-ref></b> n list value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (<a href="#FN-DEF-CAR"><tt>CAR</tt></a><fn-ref></b> cons<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-RPLACA"><tt>RPLACA</tt></a><fn-ref></b> cons value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (<a href="#FN-DEF-CDR"><tt>CDR</tt></a><fn-ref></b> cons<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-RPLACD"><tt>RPLACD</tt></a><fn-ref></b> cons value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (<a href="#FN-DEF-GET"><tt>GET</tt></a><fn-ref></b> symbol indicator<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-PUT"><tt>PUT</tt></a><fn-ref></b> symbol indicator value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (<a href="#FN-DEF-GETHASH"><tt>GETHASH</tt></a><fn-ref></b> key hashtable<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-SETHASH"><tt>SETHASH</tt></a><fn-ref></b> key hashtable value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (<a href="#FN-DEF-SYMBOL-VALUE"><tt>SYMBOL-VALUE</tt></a><fn-ref></b> symbol<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(<a href="#FN-DEF-SET"><tt>SET</tt></a><fn-ref></b> symbol value<b>)</b>
</tt></td>
</tr>

<tr>
<td><tt>
<b>(<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a><fn-ref> (</b>defstruct-slot object<b>)</b> value<b>)</b>
</tt></td>
<td></td>
<td><tt>
<b>(</b>set-defstruct-slot object value<b>)</b>
</tt></td>
</tr>

</table>
</center>

<p>
In the above table, <b>defstruct-slot</b> refers to any structure slot
accessor function which got defined via defstruct, and
<b>set-defstruct-slot</b> refers to the corresponding setter function
for the given accessor.

<!------------------------------>
<a name=Function-Invocation></a>
<h2>7.3 : Function Invocation</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node81.html>
CLtL2 Reference
</a>

<p>
These functions behave like their Common Lisp counterparts.

<br>
<br>
<a name="FN-DEF-APPLY"></a>function <tt><b>APPLY</b> : (function argument &amp;rest arguments)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FUNCALL"></a>function <tt><b>FUNCALL</b> : (function &amp;rest args)</tt><fn-def>

<p>
The first argument to both <a href="#FN-DEF-APPLY"><tt>APPLY</tt></a><fn-ref> and <a href="#FN-DEF-FUNCALL"><tt>FUNCALL</tt></a><fn-ref> must
satisfy <a href="#FN-DEF-FUNCTION-SPEC-P"><tt>FUNCTION-SPEC-P</tt></a><fn-ref>.

<!------------------------------>
<a name=Simple-Sequencing></a>
<h2>7.4 : Simple Sequencing</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node82.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-PROGN"></a>macro <tt><b>PROGN</b> : (&amp;body body)</tt><fn-def>

<p>
In SubL, <a href="#FN-DEF-PROGN"><tt>PROGN</tt></a><fn-ref> is procedural and therefore does not return a
value.  Since it is intended to be essentially procedural in Common
Lisp as well, the same name is used even though they have slightly
different semantics.

<!------------------------------>
<a name=Establishing-New-Variable-Bindings></a>
<h2>7.5 : Establishing New Variable Bindings</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node83.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CLET"></a>macro <tt><b>CLET</b> : (bindings &amp;body body)</tt><fn-def>

<p>
The SubL construct <a href="#FN-DEF-CLET"><tt>CLET</tt></a><fn-ref> can be used to introduce new local
variables or bind special variables.  The variables are initialized in
order just like <tt>LET*</tt> in Common Lisp.  Since it is procedural,
it does not return a value.

<p>
SubL has no counterpart to Common Lisp's <tt>LET</tt> construct.

<br>
<br>
<a name="FN-DEF-CPROGV"></a>macro <tt><b>CPROGV</b> : (special-vars bindings &amp;body body)</tt><fn-def>

<p>
<a href="#FN-DEF-CPROGV"><tt>CPROGV</tt></a><fn-ref> is procedural and therefore does not return a value.
Otherwise, it is equivalent to <tt>progv</tt> in Common Lisp.

<!------------------------------>
<a name=Conditionals></a>
<h2>7.6 : Conditionals</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node84.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-PIF"></a>macro <tt><b>PIF</b> : (condition action else-action)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PWHEN"></a>macro <tt><b>PWHEN</b> : (condition &amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PUNLESS"></a>macro <tt><b>PUNLESS</b> : (condition &amp;body body)</tt><fn-def>

<p>
<a href="#FN-DEF-PIF"><tt>PIF</tt></a><fn-ref>, <a href="#FN-DEF-PWHEN"><tt>PWHEN</tt></a><fn-ref> and <a href="#FN-DEF-PUNLESS"><tt>PUNLESS</tt></a><fn-ref> are the SubL
procedural variants of <tt>if</tt>, <tt>when</tt> and <tt>unless</tt>
from Common Lisp.  For each, the condition argument must be a
functional construct.  Also, <a href="#FN-DEF-PIF"><tt>PIF</tt></a><fn-ref> takes exactly three
arguments, making the action and else-actions identical in form.

<br>
<br>
<a name="FN-DEF-FIF"></a>macro <tt><b>FIF</b> : (condition true-value false-value)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FWHEN"></a>macro <tt><b>FWHEN</b> : (condition true-value)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FUNLESS"></a>macro <tt><b>FUNLESS</b> : (condition false-value)</tt><fn-def>

<p>
<a href="#FN-DEF-FIF"><tt>FIF</tt></a><fn-ref>, <a href="#FN-DEF-FWHEN"><tt>FWHEN</tt></a><fn-ref> and <a href="#FN-DEF-FUNLESS"><tt>FUNLESS</tt></a><fn-ref> are the SubL
functional variants of <tt>if</tt>, <tt>when</tt> and <tt>unless</tt>
from Common Lisp.

<br>
<br>
<a name="FN-DEF-PCOND"></a>macro <tt><b>PCOND</b> : (&amp;rest clauses)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PCASE"></a>macro <tt><b>PCASE</b> : (test-object &amp;body clauses)</tt><fn-def>

<p>
<a href="#FN-DEF-PCOND"><tt>PCOND</tt></a><fn-ref> and <a href="#FN-DEF-PCASE"><tt>PCASE</tt></a><fn-ref> are the SubL procedural equivalents
of <tt>cond</tt> and <tt>case</tt> from Common Lisp.

<!------------------------------>
<a name=Blocks-and-Exits></a>
<h2>7.7 : Blocks and Exits</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node85.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-RET"></a>macro <tt><b>RET</b> : (expression)</tt><br>
SubL functions must always return a value, since C functions must return values and all SubL functions must translate into C.<fn-def>

<p> 
<a href="#FN-DEF-RET"><tt>RET</tt></a><fn-ref> is used to return a value from a function or macro
definition.  All functions and macro definitions behave as if an
implicit

<blockquote>
<pre>(ret nil)</pre>
</blockquote>

appears at the very end of each function.

<!------------------------------>
<a name=General-Iteration></a>
<h2>7.8.2 : General Iteration</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node88.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CDO"></a>macro <tt><b>CDO</b> : (vars endtest &amp;body body)</tt><br>
cdo is procedural.  It binds its variables in sequence, as with CommonLisp do*<fn-def>

<!------------------------------>
<a name=Simple-Iteration-Constructs></a>
<h2>7.8.3 : Simple Iteration Constructs</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node89.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CDOLIST"></a>macro <tt><b>CDOLIST</b> : ((var listform) &amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CSOME"></a>macro <tt><b>CSOME</b> : ((var list endvar) &amp;body body)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CDOTIMES"></a>macro <tt><b>CDOTIMES</b> : ((var integer) &amp;body body)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CDOHASH"></a>macro <tt><b>CDOHASH</b> : ((key val table) &amp;body body)</tt><fn-def>

<!------------------------------>
<a name=Mapping></a>
<h2>7.8.4 : Mapping</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node90.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-MAPCAR"></a>function <tt><b>MAPCAR</b> : (function list &amp;rest more-lists)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MAPLIST"></a>function <tt><b>MAPLIST</b> : (function list &amp;rest more-lists)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-MAPC"></a>function <tt><b>MAPC</b> : (function list &amp;rest more-lists)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MAPL"></a>function <tt><b>MAPL</b> : (function list &amp;rest more-lists)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-MAPCAN"></a>function <tt><b>MAPCAN</b> : (function list &amp;rest more-lists)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MAPCON"></a>function <tt><b>MAPCON</b> : (function list &amp;rest more-lists)</tt><fn-def>

<!------------------------------>
<a name=Constructs-for-Handling-Multiple-Values></a>
<h2>7.10.1 : Constructs for Handling Multiple Values</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node94.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-VALUES"></a>function <tt><b>VALUES</b> : (value &amp;rest more-values)</tt><br>
values returns its args such that they can be bound in a dynamically enclosing multiple-value-bind. The first value is returned as well, since all SubL functions must return a value.<fn-def>
<br>
<br>
<a name="SYM-DEF-1624760991"></a>variable <tt><b>*MULTIPLE-VALUES-LIMIT*</b></tt><sym-def>
<br>
<br>
<a name="FN-DEF-MULTIPLE-VALUE-LIST"></a>macro <tt><b>MULTIPLE-VALUE-LIST</b> : (form)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CMULTIPLE-VALUE-BIND"></a>macro <tt><b>CMULTIPLE-VALUE-BIND</b> : (vars value &amp;body body)</tt><fn-def>

<!------------------------------>
<a name=Rules-Governing-the-Passing-of-Multiple-Values></a>
<h2>7.10.2 : Rules Governing the Passing of Multiple Values</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node95.html>
CLtL2 Reference
</a>

<p>
In SubL, multiple values are governed the same way that they are in Common Lisp,
except that if ANY of the return statements in your
function are (values ...) then all of them must be.

<!------------------------------>
<a name=Dynamic-Non-Local-Exits></a>
<h2>7.11 : Dynamic Non-Local Exits</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node96.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CCATCH"></a>macro <tt><b>CCATCH</b> : (tag ans-var &amp;body body)</tt><br>
ccatch is procedural, and so does not return values.<fn-def>
<br>
<br>
<a name="FN-DEF-CUNWIND-PROTECT"></a>macro <tt><b>CUNWIND-PROTECT</b> : (protected-form &amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-THROW"></a>function <tt><b>THROW</b> : (tag result)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Macros></a>
<hr>
<h1>8 : Macros</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node97.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=Macro-Definition></a>
<h2>8.1 : Macro Definition</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node98.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-DEFMACRO"></a>macro <tt><b>DEFMACRO</b> : (name pattern &amp;body body)</tt><fn-def>

<p>
SubL Macros are expanded at translation-time.  Full Common Lisp macro
support is available.  However, the macro-expander must use 
<a href="#FN-DEF-RET"><tt>RET</tt></a><fn-ref> to return the expansion.


<!------------------------------>
<a name=Destructuring></a>
<h2>8.3 : Destructuring</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node100.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CDESTRUCTURING-BIND"></a>macro <tt><b>CDESTRUCTURING-BIND</b> : (pattern datum &amp;body body)</tt><fn-def>

<!------------------------------>
<a name=Environments></a>
<h2>8.5 : Environments</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node102.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-VARIABLE-INFORMATION"></a>function <tt><b>VARIABLE-INFORMATION</b> : (variable)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FUNCTION-INFORMATION"></a>function <tt><b>FUNCTION-INFORMATION</b> : (function)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Declarations></a>
<hr>
<h1>9 : Declarations</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node103.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=Declaration-Syntax></a>
<h2>9.1 : Declaration Syntax</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node104.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-DECLARE"></a>function <tt><b>DECLARE</b> : (&amp;rest ignore)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PROCLAIM"></a>function <tt><b>PROCLAIM</b> : (declaration-specifier)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DECLAIM"></a>macro <tt><b>DECLAIM</b> : (&amp;rest declaration-specifiers)</tt><fn-def>

<!------------------------------>
<a name=Declaration-Specifiers></a>
<h2>9.2 : Declaration Specifiers</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node105.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-IGNORE"></a>function <tt><b>IGNORE</b> : (&amp;rest values)</tt><fn-def>

<p>
The <a href="#FN-DEF-IGNORE"><tt>IGNORE</tt></a><fn-ref> function can be used to indicate that a particular
variable's value is not used.

<!----- Major Section ---------------------------------------->
<a name=Symbols></a>
<hr>
<h1>10 : Symbols</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node107.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-SYMBOLP"></a>function <tt><b>SYMBOLP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=The-Property-List></a>
<h2>10.1 : The Property List</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node108.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-GET"></a>function <tt><b>GET</b> : (symbol indicator &amp;optional default)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PUT"></a>function <tt><b>PUT</b> : (symbol indicator new-value)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-REMPROP"></a>function <tt><b>REMPROP</b> : (symbol indicator)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SYMBOL-PLIST"></a>function <tt><b>SYMBOL-PLIST</b> : (symbol)</tt><fn-def>

<!------------------------------>
<a name=The-Print-Name></a>
<h2>10.2 : The Print Name</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node109.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-SYMBOL-NAME"></a>function <tt><b>SYMBOL-NAME</b> : (symbol)</tt><br>
Returns the string which is the name of SYMBOL. When called on a keyword, it returns the &quot;:&quot; prefix as part of the name<fn-def>

<!------------------------------>
<a name=Creating-Symbols></a>
<h2>10.3 : Creating Symbols</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node110.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-MAKE-SYMBOL"></a>function <tt><b>MAKE-SYMBOL</b> : (print-name)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-GENSYM"></a>function <tt><b>GENSYM</b> : (&amp;optional x)</tt><br>
GENSYM returns new, interned symbols, which are combinations of a string prefix and a numeric suffix. It guarantees that the new symbol was not previously interned.<br>
If the argument X is a number, the gensym counter (used to generate the suffix) is set to X before the new symbol is generated.<br>
if the argument X is a string, the gensym prefix is set to X before the new symbol is generated.<br>
The initial gensym counter value is 1 and the initial gensym prefix is 'G'.<fn-def>
<br>
<br>
<a name="FN-DEF-GENTEMP"></a>function <tt><b>GENTEMP</b> : (&amp;optional (prefix "T"))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-KEYWORDP"></a>function <tt><b>KEYWORDP</b> : (x)</tt><br>
In SubL, which does not have packages, keywords are any symbol whose name begins with &quot;:&quot;<fn-def>

<!----- Major Section ---------------------------------------->
<a name=Packages></a>
<hr>
<h1>11 : Packages</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node111.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-IN-PACKAGE"></a>macro <tt><b>IN-PACKAGE</b> : (name)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-INTERN"></a>function <tt><b>INTERN</b> : (string)</tt><br>
Finds and returns a symbol whose name is STRING. INTERN will create the symbol if it does not exist. Unlike Common LISP intern, the SubL version does not allow an argument to specify the package, since SubL does not support packages.<fn-def>
<br>
<br>
<a name="FN-DEF-FIND-SYMBOL"></a>function <tt><b>FIND-SYMBOL</b> : (string)</tt><br>
Finds and returns a symbol whose name is STRING. Unlike Common LISP FIND-SYMBOL, the SubL version does not allow an argument to specify the package, since SubL does not support packages.<fn-def>

<!----- Major Section ---------------------------------------->
<a name=Numbers></a>
<hr>
<h1>12 : Numbers</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node121.html>
CLtL2 Reference
</a>

<p>
SubL only supports fixnums and floats.  Fixnums have at least 28 bits
of precision.

<br>
<br>
<a name="FN-DEF-NUMBERP"></a>function <tt><b>NUMBERP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FIXNUMP"></a>function <tt><b>FIXNUMP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-INTEGERP"></a>function <tt><b>INTEGERP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FLOATP"></a>function <tt><b>FLOATP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Predicates-on-Numbers></a>
<h2>12.2 : Predicates on Numbers</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node123.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-ZEROP"></a>function <tt><b>ZEROP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PLUSP"></a>function <tt><b>PLUSP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MINUSP"></a>function <tt><b>MINUSP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-ODDP"></a>function <tt><b>ODDP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-EVENP"></a>function <tt><b>EVENP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Comparisons-on-Numbers></a>
<h2>12.3 : Comparisons on Numbers</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node124.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-="></a>function <tt><b>=</b> : (num1 num2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-/="></a>function <tt><b>/=</b> : (num1 num2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-3584"></a>function <tt><b>&lt;</b> : (num1 num2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-3840"></a>function <tt><b>&gt;</b> : (num1 num2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-462464"></a>function <tt><b>&lt;=</b> : (num1 num2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-495232"></a>function <tt><b>&gt;=</b> : (num1 num2)</tt><fn-def >

<p>
The above numeric comparison functions take exactly 2 arguments,
unlike their Common Lisp counterparts which take variable numbers of
arguments.

<br>
<br>
<a name="FN-DEF-MAX"></a>function <tt><b>MAX</b> : (num &amp;rest numbers)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MIN"></a>function <tt><b>MIN</b> : (num &amp;rest numbers)</tt><fn-def>

<!------------------------------>
<a name=Arithmetic-Operations></a>
<h2>12.4 : Arithmetic Operations</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node125.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-+"></a>function <tt><b>+</b> : (&amp;rest numbers)</tt><fn-def >
<br>
<br>
<a name="FN-DEF--"></a>function <tt><b>-</b> : (num &amp;rest numbers)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-1280"></a>function <tt><b>*</b> : (&amp;rest numbers)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-/"></a>function <tt><b>/</b> : (num &amp;rest numbers)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-INT/"></a>function <tt><b>INT/</b> : (num1 num2)</tt><fn-def >

<br>
<br>
<a name="FN-DEF-CINC"></a>macro <tt><b>CINC</b> : (place &amp;optional (delta 1))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CDEC"></a>macro <tt><b>CDEC</b> : (place &amp;optional (delta 1))</tt><fn-def>

<!------------------------------>
<a name=Irrational-and-Transcendental-Functions></a>
<h2>12.5 : Irrational and Transcendental Functions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node126.html>
CLtL2 Reference
</a>

<p>
SubL does not currently support any irrational, transcendental or
trigonometric functions.

<!------------------------------>
<a name=Type-Conversions-and-Component-Extractions-on-Numbers></a>
<h2>12.6 : Type Conversions and Component Extractions on Numbers</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node130.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-FLOAT"></a>function <tt><b>FLOAT</b> : (x)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-FLOOR"></a>function <tt><b>FLOOR</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CEILING"></a>function <tt><b>CEILING</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-TRUNCATE"></a>function <tt><b>TRUNCATE</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-ROUND"></a>function <tt><b>ROUND</b> : (x)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-MOD"></a>function <tt><b>MOD</b> : (number divisor)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-REM"></a>function <tt><b>REM</b> : (number divisor)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-SCALE-FLOAT"></a>function <tt><b>SCALE-FLOAT</b> : (float integer)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-INTEGER-DECODE-FLOAT"></a>function <tt><b>INTEGER-DECODE-FLOAT</b> : (float)</tt><fn-def>

<!------------------------------>
<a name=Logical-Operations-on-Numbers></a>
<h2>12.7 : Logical Operations on Numbers</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node131.html>
CLtL2 Reference
</a>

<p>
SubL does not currently support any logical operations on numbers.

<!------------------------------>
<a name=Byte-Manipulation-Functions></a>
<h2>12.8 : Byte Manipulation Functions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node132.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-BYTE"></a>macro <tt><b>BYTE</b> : (size position)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-LDB"></a>function <tt><b>LDB</b> : (bytespec integer)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DPB"></a>function <tt><b>DPB</b> : (newbyte bytespec integer)</tt><fn-def>

<!------------------------------>
<a name=Random-Numbers></a>
<h2>12.9 : Random Numbers</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node133.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-430643141"></a>variable <tt><b>*RAND-MAX*</b></tt><br>
*rand-max* is the largest fixnum that the function random can accept.<sym-def>
<br>
<br>
<a name="FN-DEF-SEED-RANDOM"></a>function <tt><b>SEED-RANDOM</b> : (&amp;optional (seed-fixnum (mod (get-internal-real-time) *rand-max*)))</tt><br>
If seed-fixnum is omitted to seed-random, the internal clock is used<br>
in an implementation specific manner.<fn-def>
<br>
<br>
<a name="FN-DEF-RANDOM"></a>function <tt><b>RANDOM</b> : (number)</tt><fn-def>

<!------------------------------>
<a name=Implementation-Parameters></a>
<h2>12.10 : Implementation Parameters</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node134.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-113980253"></a>variable <tt><b>*MOST-POSITIVE-FIXNUM*</b></tt><sym-def>
<br>
<br>
<a name="SYM-DEF-1188374285"></a>variable <tt><b>*MOST-NEGATIVE-FIXNUM*</b></tt><sym-def>

<!----- Major Section ---------------------------------------->
<a name=Characters></a>
<hr>
<h1>13 : Characters</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node135.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CHARACTERP"></a>function <tt><b>CHARACTERP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Character-Attributes></a>
<h2>13.1 : Character Attributes</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node136.html>
CLtL2 Reference
</a>

<p>
SubL does not currently support any attributes for characters.  A
character exists for each ASCII character code between 0 and 255
inclusive.  Thus, the SubL equivalent of Common Lisp's
<tt>CHAR-CODE-LIMIT</tt> is 256.

<!------------------------------>
<a name=Predicates-on-Characters></a>
<h2>13.2 : Predicates on Characters</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node137.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-ALPHA-CHAR-P"></a>function <tt><b>ALPHA-CHAR-P</b> : (char)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-UPPER-CASE-P"></a>function <tt><b>UPPER-CASE-P</b> : (char)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-LOWER-CASE-P"></a>function <tt><b>LOWER-CASE-P</b> : (char)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-BOTH-CASE-P"></a>function <tt><b>BOTH-CASE-P</b> : (char)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-DIGIT-CHAR-P"></a>function <tt><b>DIGIT-CHAR-P</b> : (char)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-ALPHANUMERICP"></a>function <tt><b>ALPHANUMERICP</b> : (char)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CHAR="></a>function <tt><b>CHAR=</b> : (char1 char2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-CHAR/="></a>function <tt><b>CHAR/=</b> : (char1 char2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-137661468"></a>function <tt><b>CHAR&lt;</b> : (char1 char2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-137661724"></a>function <tt><b>CHAR&gt;</b> : (char1 char2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-440795332"></a>function <tt><b>CHAR&lt;=</b> : (char1 char2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-440828100"></a>function <tt><b>CHAR&gt;=</b> : (char1 char2)</tt><fn-def >

<br>
<br>
<a name="FN-DEF-CHAR-EQUAL"></a>function <tt><b>CHAR-EQUAL</b> : (char1 char2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CHAR-NOT-EQUAL"></a>function <tt><b>CHAR-NOT-EQUAL</b> : (char1 char2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CHAR-LESSP"></a>function <tt><b>CHAR-LESSP</b> : (char1 char2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CHAR-GREATERP"></a>function <tt><b>CHAR-GREATERP</b> : (char1 char2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CHAR-NOT-GREATERP"></a>function <tt><b>CHAR-NOT-GREATERP</b> : (char1 char2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CHAR-NOT-LESSP"></a>function <tt><b>CHAR-NOT-LESSP</b> : (char1 char2)</tt><fn-def>

<!------------------------------>
<a name=Character-Construction-and-Selection></a>
<h2>13.3 : Character Construction and Selection</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node138.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CHAR-CODE"></a>function <tt><b>CHAR-CODE</b> : (char)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CODE-CHAR"></a>function <tt><b>CODE-CHAR</b> : (code)</tt><fn-def>

<!------------------------------>
<a name=Character-Conversions></a>
<h2>13.4 : Character Conversions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node139.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CHAR-DOWNCASE"></a>function <tt><b>CHAR-DOWNCASE</b> : (char)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CHAR-UPCASE"></a>function <tt><b>CHAR-UPCASE</b> : (char)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Sequences></a>
<hr>
<h1>14 : Sequences</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node141.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-SEQUENCEP"></a>function <tt><b>SEQUENCEP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Simple-Sequence-Functions></a>
<h2>14.1 : Simple Sequence Functions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node142.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-ELT"></a>function <tt><b>ELT</b> : (sequence index)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SUBSEQ"></a>function <tt><b>SUBSEQ</b> : (sequence start &amp;optional end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-COPY-SEQ"></a>function <tt><b>COPY-SEQ</b> : (sequence)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-LENGTH"></a>function <tt><b>LENGTH</b> : (sequence)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-REVERSE"></a>function <tt><b>REVERSE</b> : (sequence)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NREVERSE"></a>function <tt><b>NREVERSE</b> : (sequence)</tt><fn-def>

<!------------------------------>
<a name=Concatenating-Mapping-and-Reducing-Sequences></a>
<h2>14.2 : Concatenating, Mapping and Reducing Sequences</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node143.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CCONCATENATE"></a>function <tt><b>CCONCATENATE</b> : (seq &amp;rest more-seqs)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CREDUCE"></a>function <tt><b>CREDUCE</b> : (function sequence &amp;optional (start 0) end (init-value :none))</tt><fn-def>

<!------------------------------>
<a name=Modifying-Sequences></a>
<h2>14.3 : Modifying Sequences</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node144.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-FILL"></a>function <tt><b>FILL</b> : (sequence item &amp;optional (start 0) (end (length sequence)))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-REPLACE"></a>function <tt><b>REPLACE</b> : (sequence1 sequence2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-REMOVE"></a>function <tt><b>REMOVE</b> : (item sequence &amp;optional (test #'eql) (key #'identity) (start 0) end count)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-REMOVE-IF"></a>function <tt><b>REMOVE-IF</b> : (test sequence &amp;optional (key #'identity) (start 0) end count)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-DELETE"></a>function <tt><b>DELETE</b> : (item sequence &amp;optional (test #'eql) (key #'identity) (start 0) end count)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DELETE-IF"></a>function <tt><b>DELETE-IF</b> : (test sequence &amp;optional (key #'identity) (start 0) end count)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-REMOVE-DUPLICATES"></a>function <tt><b>REMOVE-DUPLICATES</b> : (sequence &amp;optional (test #'eql) (key #'identity) (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DELETE-DUPLICATES"></a>function <tt><b>DELETE-DUPLICATES</b> : (sequence &amp;optional (test #'eql) (key #'identity) (start 0) end)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-SUBSTITUTE"></a>function <tt><b>SUBSTITUTE</b> : (new old sequence &amp;optional (test #'eql) (key #'identity) (start 0) end count)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SUBSTITUTE-IF"></a>function <tt><b>SUBSTITUTE-IF</b> : (new test sequence &amp;optional (key #'identity) (start 0) end count)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-NSUBSTITUTE"></a>function <tt><b>NSUBSTITUTE</b> : (new old sequence &amp;optional (test #'eql) (key #'identity) (start 0) end count)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NSUBSTITUTE-IF"></a>function <tt><b>NSUBSTITUTE-IF</b> : (new test sequence &amp;optional (key #'identity) (start 0) end count)</tt><fn-def>

<!------------------------------>
<a name=Searching-Sequences-for-Terms></a>
<h2>14.4 : Searching Sequences for Terms</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node145.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-FIND"></a>function <tt><b>FIND</b> : (item seq &amp;optional (test #'eql) (key #'identity) (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FIND-IF"></a>function <tt><b>FIND-IF</b> : (test seq &amp;optional (key #'identity) (start 0) end)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-POSITION"></a>function <tt><b>POSITION</b> : (item seq &amp;optional (test #'eql) (key #'identity) (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-POSITION-IF"></a>function <tt><b>POSITION-IF</b> : (test seq &amp;optional (key #'identity) (start 0) end)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-COUNT"></a>function <tt><b>COUNT</b> : (item seq &amp;optional (test #'eql) (key #'identity) (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-COUNT-IF"></a>function <tt><b>COUNT-IF</b> : (test seq &amp;optional (key #'identity) (start 0) end)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-MISMATCH"></a>function <tt><b>MISMATCH</b> : (seq1 seq2 &amp;optional (test #'eql) (key #'identity) (start1 0) end1 (start2 0) end2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SEARCH"></a>function <tt><b>SEARCH</b> : (seq1 seq2 &amp;optional (test #'eql) (key #'identity) (start1 0) end1 (start2 0) end2)</tt><fn-def>

<!------------------------------>
<a name=Sorting-and-Merging></a>
<h2>14.5 : Sorting and Merging</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node146.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-SORT"></a>function <tt><b>SORT</b> : (seq predicate &amp;optional (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STABLE-SORT"></a>function <tt><b>STABLE-SORT</b> : (seq predicate &amp;optional (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CMERGE"></a>function <tt><b>CMERGE</b> : (seq1 seq2 predicate &amp;optional (key #'identity))</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Lists-Chapter></a>
<hr>
<h1>15 : Lists</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node147.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-LISTP"></a>function <tt><b>LISTP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CONSP"></a>function <tt><b>CONSP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-ATOM"></a>function <tt><b>ATOM</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Conses></a>
<h2>15.1 : Conses</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node148.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CAR"></a>function <tt><b>CAR</b> : (cons)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CDR"></a>function <tt><b>CDR</b> : (cons)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CAAR"></a>function <tt><b>CAAR</b> : (cons)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CADR"></a>function <tt><b>CADR</b> : (cons)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CDAR"></a>function <tt><b>CDAR</b> : (cons)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CDDR"></a>function <tt><b>CDDR</b> : (cons)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CONS"></a>function <tt><b>CONS</b> : (car cdr)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-TREE-EQUAL"></a>function <tt><b>TREE-EQUAL</b> : (tree1 tree2 &amp;optional (test #'eql))</tt><fn-def>

<!------------------------------>
<a name=Lists></a>
<h2>15.2 : Lists</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node149.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-ENDP"></a>function <tt><b>ENDP</b> : (object)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-LIST-LENGTH"></a>function <tt><b>LIST-LENGTH</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NTH"></a>function <tt><b>NTH</b> : (n list)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-FIRST"></a>function <tt><b>FIRST</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SECOND"></a>function <tt><b>SECOND</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-THIRD"></a>function <tt><b>THIRD</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FOURTH"></a>function <tt><b>FOURTH</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FIFTH"></a>function <tt><b>FIFTH</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SIXTH"></a>function <tt><b>SIXTH</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SEVENTH"></a>function <tt><b>SEVENTH</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-EIGHTH"></a>function <tt><b>EIGHTH</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NINTH"></a>function <tt><b>NINTH</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-TENTH"></a>function <tt><b>TENTH</b> : (list)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-REST"></a>function <tt><b>REST</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NTHCDR"></a>function <tt><b>NTHCDR</b> : (n list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-LAST"></a>function <tt><b>LAST</b> : (list &amp;optional (n 1))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-LIST"></a>function <tt><b>LIST</b> : (&amp;rest objects)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-443877220"></a>function <tt><b>LIST*</b> : (arg &amp;rest objects)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MAKE-LIST"></a>function <tt><b>MAKE-LIST</b> : (size &amp;optional initial-element)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-APPEND"></a>function <tt><b>APPEND</b> : (&amp;rest lists)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-COPY-LIST"></a>function <tt><b>COPY-LIST</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-COPY-ALIST"></a>function <tt><b>COPY-ALIST</b> : (list)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-COPY-TREE"></a>function <tt><b>COPY-TREE</b> : (tree)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-REVAPPEND"></a>function <tt><b>REVAPPEND</b> : (list1 list2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NCONC"></a>function <tt><b>NCONC</b> : (&amp;rest lists)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NRECONC"></a>function <tt><b>NRECONC</b> : (list1 list2)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-CPUSH"></a>macro <tt><b>CPUSH</b> : (item place)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CPUSHNEW"></a>macro <tt><b>CPUSHNEW</b> : (item place &amp;optional (test '#'eql) (key '#'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CPOP"></a>macro <tt><b>CPOP</b> : (place)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-BUTLAST"></a>function <tt><b>BUTLAST</b> : (list &amp;optional (n 1))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NBUTLAST"></a>function <tt><b>NBUTLAST</b> : (list &amp;optional (n 1))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-LDIFF"></a>function <tt><b>LDIFF</b> : (list sublist)</tt><fn-def>

<!------------------------------>
<a name=Alteration-of-List-Structure></a>
<h2>15.3 : Alteration of List Structure</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node150.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-RPLACA"></a>function <tt><b>RPLACA</b> : (cons newcar)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-RPLACD"></a>function <tt><b>RPLACD</b> : (cons newcdr)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SET-NTH"></a>function <tt><b>SET-NTH</b> : (n list value)</tt><fn-def>

<!------------------------------>
<a name=Substitution-of-Expressions></a>
<h2>15.4 : Substitution of Expressions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node151.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-SUBST"></a>function <tt><b>SUBST</b> : (new old tree &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SUBST-IF"></a>function <tt><b>SUBST-IF</b> : (new test tree &amp;optional (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-NSUBST"></a>function <tt><b>NSUBST</b> : (new old tree &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NSUBST-IF"></a>function <tt><b>NSUBST-IF</b> : (new test tree &amp;optional (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-SUBLIS"></a>function <tt><b>SUBLIS</b> : (alist tree &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NSUBLIS"></a>function <tt><b>NSUBLIS</b> : (alist tree &amp;optional (test #'eql) (key #'identity))</tt><fn-def>

<!------------------------------>
<a name=Using-Lists-as-Sets></a>
<h2>15.5 : Using Lists as Sets</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node152.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-MEMBER"></a>function <tt><b>MEMBER</b> : (item list &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MEMBER-IF"></a>function <tt><b>MEMBER-IF</b> : (test list &amp;optional (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-TAILP"></a>function <tt><b>TAILP</b> : (sublist list)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-ADJOIN"></a>function <tt><b>ADJOIN</b> : (item list &amp;optional (test #'eql) (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-UNION"></a>function <tt><b>UNION</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NUNION"></a>function <tt><b>NUNION</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-INTERSECTION"></a>function <tt><b>INTERSECTION</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NINTERSECTION"></a>function <tt><b>NINTERSECTION</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-SET-DIFFERENCE"></a>function <tt><b>SET-DIFFERENCE</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NSET-DIFFERENCE"></a>function <tt><b>NSET-DIFFERENCE</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-SET-EXCLUSIVE-OR"></a>function <tt><b>SET-EXCLUSIVE-OR</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NSET-EXCLUSIVE-OR"></a>function <tt><b>NSET-EXCLUSIVE-OR</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-SUBSETP"></a>function <tt><b>SUBSETP</b> : (list1 list2 &amp;optional (test #'eql) (key #'identity))</tt><fn-def>

<!------------------------------>
<a name=Association-Lists></a>
<h2>15.6 : Association Lists</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node153.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-ACONS"></a>function <tt><b>ACONS</b> : (key datum alist)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PAIRLIS"></a>function <tt><b>PAIRLIS</b> : (keys data &amp;optional alist)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-ASSOC"></a>function <tt><b>ASSOC</b> : (item alist &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-ASSOC-IF"></a>function <tt><b>ASSOC-IF</b> : (predicate alist)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-RASSOC"></a>function <tt><b>RASSOC</b> : (item alist &amp;optional (test #'eql) (key #'identity))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-RASSOC-IF"></a>function <tt><b>RASSOC-IF</b> : (predicate alist)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Hash-Tables></a>
<hr>
<h1>16 : Hash Tables</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node154.html>
CLtL2 Reference
</a>

<p>
<!------------------------------>
<a name=Hash-Table-Functions></a>
<h2>16.1 : Hash Table Functions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node155.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-MAKE-HASH-TABLE"></a>function <tt><b>MAKE-HASH-TABLE</b> : (size &amp;optional (test #'eql) (area default-cons-area))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-HASH-TABLE-P"></a>function <tt><b>HASH-TABLE-P</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-GETHASH"></a>function <tt><b>GETHASH</b> : (key table &amp;optional default)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SETHASH"></a>function <tt><b>SETHASH</b> : (key table value)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-REMHASH"></a>function <tt><b>REMHASH</b> : (key table)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-MAPHASH"></a>function <tt><b>MAPHASH</b> : (function table)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CLRHASH"></a>function <tt><b>CLRHASH</b> : (table)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-HASH-TABLE-COUNT"></a>function <tt><b>HASH-TABLE-COUNT</b> : (table)</tt><fn-def>

<!------------------------------>
<a name=Primitive-Hash-Function></a>
<h2>16.2 : Primitive Hash Function</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node156.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-SXHASH"></a>function <tt><b>SXHASH</b> : (object)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Arrays></a>
<hr>
<h1>17 : Arrays</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node157.html>
CLtL2 Reference
</a>

<p>
SubL only supports one-dimensional arrays, which are called vectors.

<br>
<br>
<a name="FN-DEF-VECTORP"></a>function <tt><b>VECTORP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Vector-Creation></a>
<h2>17.1 : Vector Creation</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node158.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-MAKE-VECTOR"></a>function <tt><b>MAKE-VECTOR</b> : (size &amp;optional initial-element)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-VECTOR"></a>function <tt><b>VECTOR</b> : (&amp;rest objects)</tt><fn-def>

<!------------------------------>
<a name=Vector-Access></a>
<h2>17.2 : Vector Access</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node159.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-AREF"></a>function <tt><b>AREF</b> : (vector index)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SET-AREF"></a>function <tt><b>SET-AREF</b> : (vector index value)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Strings></a>
<hr>
<h1>18 : Strings</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node164.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-STRINGP"></a>function <tt><b>STRINGP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=String-Access></a>
<h2>18.1 : String Access</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node165.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CHAR"></a>function <tt><b>CHAR</b> : (string index)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SET-CHAR"></a>function <tt><b>SET-CHAR</b> : (string index value)</tt><fn-def>

<!------------------------------>
<a name=String-Comparison></a>
<h2>18.2 : String Comparison</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node166.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-STRING="></a>function <tt><b>STRING=</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-STRING-EQUAL"></a>function <tt><b>STRING-EQUAL</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-427203732"></a>function <tt><b>STRING&lt;</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-427203988"></a>function <tt><b>STRING&gt;</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-994985164"></a>function <tt><b>STRING&lt;=</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-995017932"></a>function <tt><b>STRING&gt;=</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def >
<br>
<br>
<a name="FN-DEF-STRING/="></a>function <tt><b>STRING/=</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def >

<br>
<br>
<a name="FN-DEF-STRING-LESSP"></a>function <tt><b>STRING-LESSP</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-GREATERP"></a>function <tt><b>STRING-GREATERP</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-NOT-GREATERP"></a>function <tt><b>STRING-NOT-GREATERP</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-NOT-LESSP"></a>function <tt><b>STRING-NOT-LESSP</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-NOT-EQUAL"></a>function <tt><b>STRING-NOT-EQUAL</b> : (string1 string2 &amp;optional (start1 0) end1 (start2 0) end2)</tt><fn-def>

<!------------------------------>
<a name=String-Construction-and-Manipulation></a>
<h2>18.3 : String Construction and Manipulation</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node167.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-MAKE-STRING"></a>function <tt><b>MAKE-STRING</b> : (size &amp;optional (initial-element #\Space))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-STRING-TRIM"></a>function <tt><b>STRING-TRIM</b> : (char-list string)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-LEFT-TRIM"></a>function <tt><b>STRING-LEFT-TRIM</b> : (char-list string)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-RIGHT-TRIM"></a>function <tt><b>STRING-RIGHT-TRIM</b> : (char-list string)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-STRING-UPCASE"></a>function <tt><b>STRING-UPCASE</b> : (string &amp;optional (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-DOWNCASE"></a>function <tt><b>STRING-DOWNCASE</b> : (string &amp;optional (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-STRING-CAPITALIZE"></a>function <tt><b>STRING-CAPITALIZE</b> : (string &amp;optional (start 0) end)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-NSTRING-UPCASE"></a>function <tt><b>NSTRING-UPCASE</b> : (string &amp;optional (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NSTRING-DOWNCASE"></a>function <tt><b>NSTRING-DOWNCASE</b> : (string &amp;optional (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NSTRING-CAPITALIZE"></a>function <tt><b>NSTRING-CAPITALIZE</b> : (string &amp;optional (start 0) end)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-STRING"></a>function <tt><b>STRING</b> : (x)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Structures></a>
<hr>
<h1>19 : Structures</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node168.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-DEFSTRUCT"></a>macro <tt><b>DEFSTRUCT</b> : ((name &amp;rest options) &amp;body slots)</tt><br>
Like Common Lisp defstruct except:<br>
(1) slot initializations are not allowed.<p></p>
(2) the only other options: <br>
(:conc-name whatever)<br>
(:print-function #'whatever) <p></p>
the default structure print function is<br>
default-struct-print-function : object stream depth<p></p>
(3) The make constructor takes no arguments and only makes an empty structure.<p></p>
(4) Reading of structures is not supported by the reader.<fn-def>
<br>
<br>
<a name="FN-DEF-DEFAULT-STRUCT-PRINT-FUNCTION"></a>function <tt><b>DEFAULT-STRUCT-PRINT-FUNCTION</b> : (object stream depth)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PRINTING-OBJECT"></a>macro <tt><b>PRINTING-OBJECT</b> : ((object stream) &amp;body body)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=The-Evaluator></a>
<hr>
<h1>20 : The Evaluator</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node179.html>
CLtL2 Reference
</a>

<p>
<!------------------------------>
<a name=Run-Time-Evaluation-of-Forms></a>
<h2>20.1 : Run-Time Evaluation of Forms</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node180.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-EVAL"></a>function <tt><b>EVAL</b> : (form)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CONSTANTP"></a>function <tt><b>CONSTANTP</b> : (object &amp;optional env)</tt><fn-def>

<p>
The Common Lisp functions <tt>evalhook</tt> and <tt>applyhook</tt> are
not supported in SubL.

<!------------------------------>
<a name=The-Top-Level-Loop></a>
<h2>20.2 : The Top-Level Loop</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node181.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-1280"></a>variable <tt><b>*</b></tt><sym-def>
<br>
<br>
<a name="SYM-DEF-165120"></a>variable <tt><b>**</b></tt><sym-def>
<br>
<br>
<a name="SYM-DEF-21136640"></a>variable <tt><b>***</b></tt><sym-def>

<p>
For convenience, the top-level readloop binds the following variables
after each form is evaluated:

<blockquote>
<pre>
*	the last value returned
**	the previous value of *
***	the previous value of **
</pre>
</blockquote>

<!----- Major Section ---------------------------------------->
<a name=Streams></a>
<hr>
<h1>21 : Streams</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node182.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-STREAMP"></a>function <tt><b>STREAMP</b> : (x)</tt><fn-def>

<!------------------------------>
<a name=Standard-Streams></a>
<h2>21.1 : Standard Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node183.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-1112282190"></a>variable <tt><b>*STANDARD-INPUT*</b></tt><sym-def>
<br>
<br>
<a name="SYM-DEF-1982975489"></a>variable <tt><b>*STANDARD-OUTPUT*</b></tt><sym-def>
<br>
<br>
<a name="SYM-DEF-704643174"></a>variable <tt><b>*ERROR-OUTPUT*</b></tt><sym-def>

<br>
<br>
<a name="SYM-DEF-1405149315"></a>variable <tt><b>*NULL-OUTPUT*</b></tt><br>
A bit-sink output stream.  All output is ignored<sym-def>

<p>
The other standard streams supported by Common Lisp are not supported by SubL.


<!------------------------------>
<a name=Creating-new-Streams></a>
<h2>21.2 : Creating new Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node184.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-OPEN-TCP-STREAM"></a>function <tt><b>OPEN-TCP-STREAM</b> : (host port)</tt><fn-def>

<!------------------------------>
<a name=Operations-on-Streams></a>
<h2>21.3 : Operations on Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node185.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-STREAMP"></a>function <tt><b>STREAMP</b> : (x)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-INPUT-STREAM-P"></a>function <tt><b>INPUT-STREAM-P</b> : (object)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-OUTPUT-STREAM-P"></a>function <tt><b>OUTPUT-STREAM-P</b> : (object)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-CLOSE"></a>function <tt><b>CLOSE</b> : (stream)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Input-Output></a>
<hr>
<h1>22 : Input/Output</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node186.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=Printed-Representation-of-SubL-Objects></a>
<h2>22.1 : Printed Representation of SubL Objects</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node187.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=Macro-Characters></a>
<h2>22.1.3 : Macro Characters</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node190.html>
CLtL2 Reference
</a>

<p>
The SubL reader supports the following macro characters, whose meaning
is identical to their meaning in Common Lisp :

<blockquote>
<table>
<tr>
<td><b>Macro Character</b></td><td>&nbsp;&nbsp;&nbsp; </td><td><b>Reader Action</b></td>
</tr>
<tr><td colspan=3><hr></td></tr>
<tr>
<td><tt><b>
(
</b></tt></td><td></td>
<td>
Begin reading a list.
</td>
</tr>

<tr>
<td><tt><b>
)
</b></tt></td><td></td>
<td>
End reading a list or a vector.
</td>
</tr>

<tr>
<td><tt><b>
'
</b></tt></td><td></td>
<td>
Read in a quoted expression.
</td>
</tr>

<tr>
<td><tt><b>
;
</b></tt></td><td></td>
<td>
Read a comment until end-of-line.
</td>
</tr>

<tr>
<td><tt><b>
"
</b></tt></td><td></td>
<td>
Begin or end reading a string.
</td>
</tr>

<tr>
<td><tt><b>
`
</b></tt></td><td></td>
<td>
Read in a backquoted expression.
</td>
</tr>
</table>
</blockquote>

<p>
In addition, the following comma-readers are supported inside of backquote :
<blockquote>
<pre>
,  
,@  
,.
</pre>
</blockquote>

Their behavior is identical to their Common Lisp counterparts.

<!------------------------------>
<a name=Standard-Dispatching-Macro-Character-Syntax></a>
<h2>22.1.4 : Standard Dispatching Macro Character Syntax</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node191.html>
CLtL2 Reference
</a>

<p>

<b><tt>'#'</tt></b> is the SubL standard dispatching macro character.
The SubL reader supports the following dispatch macro character
sequences, whose meanings are identical to their meanings in Common
Lisp :

<blockquote>
<table>
<tr>
<td><b>Dispatch Sequence</b></td><td>&nbsp;&nbsp;&nbsp; </td><td><b>Reader Action</b></td>
</tr>
<tr><td colspan=3><hr></td></tr>
<tr>
<td><tt><b>
#\(
</b></tt></td><td></td>
<td>
Read a character constant.
</td>
</tr>

<tr>
<td><tt><b>
#'
</b></tt></td><td></td>
<td>
Read a function constant.
</td>
</tr>

<tr>
<td><tt><b>
#(
</b></tt></td><td></td>
<td>
Begin reading a vector.
</td>
</tr>

<tr>
<td><tt><b>
#|
</b></tt></td><td></td>
<td>
Begin reading a comment section.
</td>
</tr>

<tr>
<td><tt><b>
|#
</b></tt></td><td></td>
<td>
End reading a comment section.
</td>
</tr>
</table>
</blockquote>

<p>
Additionally, SubL supports the dispatch sequence <b><tt>#$</tt></b> as follows :
<blockquote>
<tt>#$foo</tt> reads the Cyc constant whose name is <tt>"foo"</tt>
</blockquote>

<!------------------------------>
<a name=The-Readtable></a>
<h2>22.1.5 : The Readtable</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node192.html>
CLtL2 Reference
</a>

<p>
SubL internally uses a readtable, but it is not visible to the
programmer.

<!------------------------------>
<a name=What-the-Print-Function-Produces></a>
<h2>22.1.6 : What the Print Function Produces</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node193.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-313735324"></a>variable <tt><b>*PRINT-ESCAPE*</b></tt><sym-def>

<!------------------------------>
<a name=Input-from-Character-Streams></a>
<h2>22.2.1 : Input from Character Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node195.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-READ"></a>function <tt><b>READ</b> : (&amp;optional (stream *standard-input*) (eof-error-p t) (eof-value :eof))</tt><br>
Returns FORM if read was successful.<br>
Returns the values NIL :ERROR if there was a reader error.<br>
Returns the values EOF-VALUE :ERROR if EOF-ERROR-P is nil and EOF occurs.<br>
Causes an error if EOF-ERROR-P is not nil and EOF occurs.<p></p>
Differences from Common Lisp:<br>
<code>  </code>Numbers are only read in decimal notation with no specified radix.<br>
<code>  </code>No character modifiers: only standard chars plus specials like Space, Return etc.<br>
<code>  </code>The || notation and \ syntax for symbols are not supported.<fn-def>

<br>
<br>
<a name="FN-DEF-READ-LINE"></a>function <tt><b>READ-LINE</b> : (&amp;optional (stream *standard-input*) (eof-error-p t) (eof-value :eof))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-READ-CHAR"></a>function <tt><b>READ-CHAR</b> : (&amp;optional (stream *standard-input*) (eof-error-p t) (eof-value :eof))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-UNREAD-CHAR"></a>function <tt><b>UNREAD-CHAR</b> : (char &amp;optional (stream *standard-input*))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-READ-FROM-STRING"></a>function <tt><b>READ-FROM-STRING</b> : (string &amp;optional (eof-error-p t) (eof-value :eof) (start 0) end)</tt><br>
Returns the values FORM NEW-START if read was successful.<br>
Returns the values NIL :ERROR if there was a reader error.<br>
Returns the values EOF-VALUE :ERROR if EOF-ERROR-P is nil and EOF occurs.<br>
Causes an error if EOF-ERROR-P is not nil and EOF occurs.<br>
Returns a second value which is an integer indicating the position in the string to<br>
start reading from again or :ERROR if there was some kind of reader error.<fn-def>

<!------------------------------>
<a name=Input-from-Binary-Streams></a>
<h2>22.2.2 : Input from Binary Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node196.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-READ-BYTE"></a>function <tt><b>READ-BYTE</b> : (stream &amp;optional (eof-error-p t) (eof-value :eof))</tt><fn-def>

<!------------------------------>
<a name=Output-to-Character-Streams></a>
<h2>22.3.1 : Output to Character Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node198.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-WRITE"></a>function <tt><b>WRITE</b> : (object &amp;optional (stream *standard-output*) (escape *print-escape*))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PRIN1"></a>function <tt><b>PRIN1</b> : (object &amp;optional (stream *standard-output*))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PRINT"></a>function <tt><b>PRINT</b> : (object &amp;optional (stream *standard-output*))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PRINC"></a>function <tt><b>PRINC</b> : (object &amp;optional (stream *standard-output*))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-WRITE-TO-STRING"></a>function <tt><b>WRITE-TO-STRING</b> : (object &amp;optional (escape *print-escape*))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PRIN1-TO-STRING"></a>function <tt><b>PRIN1-TO-STRING</b> : (object)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PRINC-TO-STRING"></a>function <tt><b>PRINC-TO-STRING</b> : (object)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-WRITE-CHAR"></a>function <tt><b>WRITE-CHAR</b> : (char &amp;optional (stream *standard-output*))</tt><fn-def>
<br>
<br>
<a name="FN-DEF-WRITE-STRING"></a>function <tt><b>WRITE-STRING</b> : (string &amp;optional (stream *standard-output*) (start 0) end)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-WRITE-LINE"></a>function <tt><b>WRITE-LINE</b> : (string &amp;optional (stream *standard-output*) (start 0) end)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-TERPRI"></a>function <tt><b>TERPRI</b> : (&amp;optional (stream *standard-output*))</tt><fn-def>

<br>
<br>
<a name="FN-DEF-FORCE-OUTPUT"></a>function <tt><b>FORCE-OUTPUT</b> : (&amp;optional (stream *standard-output*))</tt><fn-def>

<!------------------------------>
<a name=Output-to-Binary-Streams></a>
<h2>22.3.2 : Output to Binary Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node199.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-WRITE-BYTE"></a>function <tt><b>WRITE-BYTE</b> : (integer stream)</tt><fn-def>

<!------------------------------>
<a name=Formatted-Output-to-Character-Streams></a>
<h2>22.3.3 : Formatted Output to Character Streams</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node200.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-FORMAT"></a>function <tt><b>FORMAT</b> : (destination control-string &amp;rest arguments)</tt><br>
Format ARGUMENTS to the text stream DESTINATION according to the specifications in CONTROL-STRING. SubL format is more limited than the Common Lisp version: the only escapes allowed in the control string are: ~A ~a ~S ~s ~D ~d (with width and pad parameters optional) ~C ~c ~G ~g ~% ~~<fn-def>

<!----- Major Section ---------------------------------------->
<a name=File-System-Interface></a>
<hr>
<h1>23 : File System Interface</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node202.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=File-Names></a>
<h2>23.1 : File Names</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node203.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-609384130"></a>variable <tt><b>*DEFAULT-PATHNAME-DEFAULTS*</b></tt><sym-def>
<br>
<br>
<a name="FN-DEF-CONSTRUCT-FILENAME"></a>function <tt><b>CONSTRUCT-FILENAME</b> : (directory-list filename &amp;optional extension relative?)</tt><fn-def>

<p>
Pathnames are just strings in SubL.  Common Lisp pathname objects are
not supported.

<!------------------------------>
<a name=Opening-and-Closing-Files></a>
<h2>23.2 : Opening and Closing Files</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node215.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-OPEN-TEXT"></a>function <tt><b>OPEN-TEXT</b> : (filename direction)</tt><br>
Attempts to open the file FILENAME.  If successful, returns an 8-bit character text stream. If DIRECTION is :input, then input operations can be performed on the stream.  If DIRECTION is output, then output is directed to the file FILENAME, overwriting any existing file.  If DIRECTION is :append, then output is appended to the file.  For either output case, a new file is created if no file named FILENAME already exists.<fn-def>
<br>
<br>
<a name="FN-DEF-OPEN-BINARY"></a>function <tt><b>OPEN-BINARY</b> : (filename direction)</tt><br>
Attempts to open the file FILENAME.  If successful, returns an 8-bit binary byte stream. If DIRECTION is :input, then input operations can be performed on the stream.  If DIRECTION is output, then output is directed to the file FILENAME, overwriting any existing file.  If DIRECTION is :append, then output is appended to the file.  For either output case, a new file is created if no file named FILENAME already exists.<fn-def>

<br>
<br>
<a name="FN-DEF-WITH-TEXT-FILE"></a>macro <tt><b>WITH-TEXT-FILE</b> : ((stream filestring direction) &amp;body body)</tt><br>
In the scope of a WITH-TEXT-FILE expression, the file FILESTRING is opened for character i/o and a stream to this file is created and bound to the variable STREAM.  If DIRECTION is :input, then input operations can be performed on STREAM.  If DIRECTION is :output, then output operations can be performed, overwriting any existing file.  If DIRECTION is :append, then output is appended to an existing file.<fn-def>
<br>
<br>
<a name="FN-DEF-WITH-BINARY-FILE"></a>macro <tt><b>WITH-BINARY-FILE</b> : ((stream filestring direction) &amp;body body)</tt><br>
In the scope of a WITH-BINARY-FILE expression, the file FILESTRING is opened for binary i/o and a stream to this file is created and bound to the variable STREAM.  If DIRECTION is :input, then input operations can be performed on STREAM.  If DIRECTION is :output, then output operations can be performed, overwriting any existing file.  If DIRECTION is :append, then output is appended to an existing file.<fn-def>

<!------------------------------>
<a name=Renaming-Deleting-and-Other-File-Operations></a>
<h2>23.3 : Renaming, Deleting and Other File Operations</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node216.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-RENAME-FILE"></a>function <tt><b>RENAME-FILE</b> : (filename new-name)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DELETE-FILE"></a>function <tt><b>DELETE-FILE</b> : (filename)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-PROBE-FILE"></a>function <tt><b>PROBE-FILE</b> : (filename)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-APPEND-FILES"></a>function <tt><b>APPEND-FILES</b> : (filename-1 filename-2 &amp;optional (mode :text))</tt><br>
Append filename-1 to filename-2<fn-def>

<br>
<br>
<a name="FN-DEF-FILE-WRITE-DATE"></a>function <tt><b>FILE-WRITE-DATE</b> : (filename)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FILE-AUTHOR"></a>function <tt><b>FILE-AUTHOR</b> : (filename)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-GET-FILE-POSITION"></a>function <tt><b>GET-FILE-POSITION</b> : (stream)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-SET-FILE-POSITION"></a>function <tt><b>SET-FILE-POSITION</b> : (stream n)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-FILE-LENGTH"></a>function <tt><b>FILE-LENGTH</b> : (stream)</tt><fn-def>

<!------------------------------>
<a name=Loading-Files></a>
<h2>23.4 : Loading Files</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node217.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-LOAD"></a>function <tt><b>LOAD</b> : (filename)</tt><fn-def>

<!------------------------------>
<a name=Accessing-Directories></a>
<h2>23.5 : Accessing Directories</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node218.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-DIRECTORY"></a>function <tt><b>DIRECTORY</b> : (directory-name &amp;optional include-directory)</tt><fn-def>


<!----- Major Section ---------------------------------------->
<a name=Errors></a>
<hr>
<h1>24 : Errors</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node219.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=General-Error-Signalling-Functions></a>
<h2>24.1 : General Error-Signalling Functions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node220.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-860597104"></a>variable <tt><b>*ERROR-ABORT-HANDLER*</b></tt><br>
If *error-abort-handler* is non-nil, then an ABORT option is available inside ERROR and CERROR.<br>
If chosen, then the handler is funcalled on no arguments.<sym-def>
<br>
<br>
<a name="SYM-DEF-354311860"></a>variable <tt><b>*ERROR-HANDLER*</b></tt><br>
If *ERROR-SIGNAL* is non-nil, then that function is called upon an error.  Otherwise, the debugger is invoked.<sym-def>
<br>
<br>
<a name="SYM-DEF-1079241228"></a>variable <tt><b>*ERROR-MESSAGE*</b></tt><sym-def>

<br>
<br>
<a name="FN-DEF-ERROR"></a>function <tt><b>ERROR</b> : (format-string &amp;rest arguments)</tt><fn-def>

<br>
<br>
<a name="SYM-DEF-1424597890"></a>variable <tt><b>*CONTINUE-CERROR?*</b></tt><sym-def>
<br>
<br>
<a name="FN-DEF-CERROR"></a>function <tt><b>CERROR</b> : (continue-string format-string &amp;rest arguments)</tt><fn-def>

<br>
<br>
<a name="SYM-DEF-1528898064"></a>variable <tt><b>*IGNORE-WARNS?*</b></tt><br>
If T, all warnings forms are ignored<sym-def>
<br>
<br>
<a name="FN-DEF-WARN"></a>function <tt><b>WARN</b> : (format-string &amp;rest arguments)</tt><fn-def>

<br>
<br>
<a name="SYM-DEF-204607828"></a>variable <tt><b>*IGNORE-BREAKS?*</b></tt><br>
If non-NIL, all break forms are ignored<sym-def>
<br>
<br>
<a name="FN-DEF-BREAK"></a>function <tt><b>BREAK</b> : (format-string &amp;rest arguments)</tt><fn-def>

<!------------------------------>
<a name=Specialized-Error-Signalling-Forms-and-Macros></a>
<h2>24.2 : Specialized Error-Signalling Forms and Macros</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node221.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-2065003033"></a>variable <tt><b>*IGNORE-MUSTS?*</b></tt><br>
If non-NIL, all must forms are ignored<sym-def>
<br>
<br>
<a name="FN-DEF-MUST"></a>macro <tt><b>MUST</b> : (form format-string &amp;rest arguments)</tt><fn-def>

<br>
<br>
<a name="SYM-DEF-1570894042"></a>variable <tt><b>*SUSPEND-TYPE-CHECKING?*</b></tt><br>
CHECK-TYPE tests are performed iff this is non-nil<sym-def>
<br>
<br>
<a name="FN-DEF-CHECK-TYPE"></a>macro <tt><b>CHECK-TYPE</b> : (object pred)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Miscellaneous-Features></a>
<hr>
<h1>25 : Miscellaneous Features</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node223.html>
CLtL2 Reference
</a>

<!------------------------------>
<a name=The-Compiler></a>
<h2>25.1 : The Compiler</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node224.html>
CLtL2 Reference
</a>

<p>
SubL currently does not provide any compilation support.

<!------------------------------>
<a name=Debugging-Tools></a>
<h2>25.3 : Debugging Tools</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node230.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-CTIME"></a>macro <tt><b>CTIME</b> : (var &amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DEBUG"></a>function <tt><b>DEBUG</b> : ()</tt><br>
Pauses execution and invokes the debugger.<fn-def>

<!------------------------------>
<a name=Time-Functions></a>
<h2>25.4.1 : Time Functions</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node232.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="SYM-DEF-2020021124"></a>variable <tt><b>*EPOCH*</b></tt><br>
*epoch* is the current epoch in use, which is a universal time.<br>
The system needs to at least be able to handle epochs back to midnight Jan 1 1970.<br>
*epoch* is globally initialized to midnight Jan 1 1970.<br>
All universal times are relative to *epoch*.<sym-def>

<br>
<br>
<a name="FN-DEF-GET-UNIVERSAL-TIME"></a>function <tt><b>GET-UNIVERSAL-TIME</b> : ()</tt><fn-def>
<br>
<br>
<a name="FN-DEF-DECODE-UNIVERSAL-TIME"></a>function <tt><b>DECODE-UNIVERSAL-TIME</b> : (universal-time)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-ENCODE-UNIVERSAL-TIME"></a>function <tt><b>ENCODE-UNIVERSAL-TIME</b> : (second minute hour date month year)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-TIME-FROM-NOW"></a>function <tt><b>TIME-FROM-NOW</b> : (delta)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-TIME-HAS-ARRIVED?"></a>function <tt><b>TIME-HAS-ARRIVED?</b> : (time)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-ENCODE-TIMESTRING"></a>function <tt><b>ENCODE-TIMESTRING</b> : (second minute hour date month year)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-TIMESTRING"></a>function <tt><b>TIMESTRING</b> : (&amp;optional (universal-time (get-universal-time)))</tt><br>
timestring returns a string in the format dd/mm/yy hh:mm:ss from the<br>
universal time given.  If none is given, the current time is used.<fn-def>

<br>
<br>
<a name="SYM-DEF-1161467279"></a>variable <tt><b>*CLOCK-GRANULARITY*</b></tt><br>
*clock-granularity* is the number of internal clock units per second.<br>
time evals form and returns the number of internal clock units it took<br>
to execute.<sym-def>
<br>
<br>
<a name="FN-DEF-GET-INTERNAL-REAL-TIME"></a>function <tt><b>GET-INTERNAL-REAL-TIME</b> : ()</tt><fn-def>

<br>
<br>
<a name="FN-DEF-SLEEP"></a>function <tt><b>SLEEP</b> : (seconds)</tt><fn-def>

<!------------------------------>
<a name=Identity-Function></a>
<h2>25.5 : Identity Function</h2>

<a href=http://www.supelec.fr/docs/cltl/clm/node234.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-IDENTITY"></a>function <tt><b>IDENTITY</b> : (object)</tt><fn-def>

<!----- Major Section ---------------------------------------->
<a name=Common-Lisp-Object-System></a>
<hr>
<h1>28 : Common Lisp Object System</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/node260.html>
CLtL2 Reference
</a>

<br>
<br>
<a name="FN-DEF-DEFPOLYMORPHIC"></a>macro <tt><b>DEFPOLYMORPHIC</b> : (name lambda-list &amp;body body)</tt><br>
Defines a new polymorphic function that dispatches on the type of its first argument.  &lt;body&gt; defines a default method. The function define-method can be used to define additional methods. For example:<p></p>
(defpolymorphic test (a b)<br>
<code>    </code>(list a b))<p></p>
(define-method test ((a cons) b)<br>
<code>    </code>(cons b a))<p></p>
(define-method test ((a fixnum) b)<br>
<code>    </code>(+ a b))<p></p>
The defpolymorphic form defines the function TEST with a default method.<br>
<code>  </code>The two define-method forms specialize the behavior of TEST for lists and fixnums.<p></p>
(test 'foo 'bar) =&gt; (FOO BAR)<br>
<code>  </code>(test '(foo) 'bar) =&gt; (BAR FOO)<br>
<code>  </code>(test 2 3) =&gt; 5<fn-def>
<br>
<br>
<a name="FN-DEF-DEFINE-METHOD"></a>macro <tt><b>DEFINE-METHOD</b> : (name lambda-list &amp;body body)</tt><br>
Defines a method for the polymorphic function &lt;name&gt; that runs if<br>
&lt;dispatch-arg&gt; is of type &lt;type&gt;. The lambda list must have the same<br>
structure as in the DEFPOLYMORPHIC call.<fn-def>

<!----- Major Section ---------------------------------------->
<a name=SubL-Specific-Features></a>
<hr>
<h1>SubL-Specific Features</h1>

<!------------------------------>
<p><a name=Signals></a>
<b><big>SubL.1 : Signals</big></b>

<br>
<br>
<a name="SYM-DEF-371148559"></a>variable <tt><b>*SIGNAL-MAX*</b></tt><br>
There are *signal-max* total signals available.<sym-def>
<br>
<br>
<a name="FN-DEF-DEFAULT-SIGNAL-HANDLER"></a>function <tt><b>DEFAULT-SIGNAL-HANDLER</b> : (signal)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-INSTALL-SIGNAL-HANDLER"></a>function <tt><b>INSTALL-SIGNAL-HANDLER</b> : (signal function)</tt><fn-def>

<br><!------------------------------>
<p><a name=System-Properties></a>
<b><big>SubL.2 : System Properties</big></b>

<br>
<br>
<a name="FN-DEF-GET-PROCESS-ID"></a>function <tt><b>GET-PROCESS-ID</b> : (&amp;optional default)</tt><br>
Return the current heavyweight process id of this current SubL<br>
program.  Return DEFAULT if this cannot be determined.<fn-def>
<br>
<br>
<a name="FN-DEF-GET-MACHINE-NAME"></a>function <tt><b>GET-MACHINE-NAME</b> : (&amp;optional default)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-GET-NETWORK-NAME"></a>function <tt><b>GET-NETWORK-NAME</b> : (&amp;optional default)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-GET-USER-NAME"></a>function <tt><b>GET-USER-NAME</b> : (&amp;optional default)</tt><fn-def>

<br><!------------------------------>
<p><a name=Progress-Pacifiers></a>
<b><big>SubL.3 : Progress Pacifiers</big></b>

<br>
<br>
<a name="SYM-DEF-694198800"></a>variable <tt><b>*SILENT-PROGRESS?*</b></tt><sym-def>
<br>
<br>
<a name="FN-DEF-NOTING-ACTIVITY"></a>macro <tt><b>NOTING-ACTIVITY</b> : (string &amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NOTE-ACTIVITY"></a>function <tt><b>NOTE-ACTIVITY</b> : ()</tt><fn-def>

<br>
<br>
<a name="FN-DEF-NOTING-NUMERIC-PROGRESS"></a>macro <tt><b>NOTING-NUMERIC-PROGRESS</b> : (string &amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NOTE-NUMERIC-PROGRESS"></a>function <tt><b>NOTE-NUMERIC-PROGRESS</b> : (num)</tt><fn-def>

<br>
<br>
<a name="FN-DEF-NOTING-PERCENT-PROGRESS"></a>macro <tt><b>NOTING-PERCENT-PROGRESS</b> : (string &amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-NOTE-PERCENT-PROGRESS"></a>function <tt><b>NOTE-PERCENT-PROGRESS</b> : (index max)</tt><fn-def>

<br><!------------------------------>
<p><a name=Process-Manipulation></a>
<b><big>SubL.4 : Process Manipulation</big></b>

<br>
<br>
<a name="FN-DEF-FORK-PROCESS"></a>function <tt><b>FORK-PROCESS</b> : (function &amp;optional callback output-file)</tt><br>
Spawn a heavyweight child process to call FUNCTION, which takes no arguments.<br>
FUNCTION must return an integer.  <br>
CALLBACK, if provided, must be a function of one argument which is called <br>
on the returned value within the address space of the parent process.<br>
OUTPUT-FILE, if provided, is a file to which standard output and error are piped<br>
while executing FUNCTION.<fn-def>
<br>
<br>
<a name="FN-DEF-RESTART-PROCESS"></a>function <tt><b>RESTART-PROCESS</b> : (&amp;optional world-spec init-file-pathname init-form-spec)</tt><br>
Restart the current heavyweight process.<br>
WORLD-SPEC, if provided, is the filename of a world to use.<br>
INIT-FILE-PATHNAME, if provided, is a file of initializatio forms to eval.<br>
INIT-FORM-SPEC, if provided, is a form to execute.<br>
The values used for these when the current process was started are used if unprovided.<fn-def>

<br><!------------------------------>
<p><a name=Memory-Interaction></a>
<b><big>SubL.5 : Memory Interaction</big></b>

<br>
<br>
<a name="FN-DEF-GC"></a>function <tt><b>GC</b> : (&amp;optional level)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-WITH-STATIC-AREA"></a>macro <tt><b>WITH-STATIC-AREA</b> : (&amp;body body)</tt><fn-def>
<br>
<br>
<a name="FN-DEF-WRITE-IMAGE"></a>function <tt><b>WRITE-IMAGE</b> : (filename &amp;optional do-full-gc)</tt><br>
Save the current state of virtual memory in a file called FILENAME.<br>
If DO-FULL-GC is true, then a full garbage collection is<br>
performed before writing the image.  Otherwise, a dynamic<br>
garbage collection is performed and remaining objects are<br>
promoted to being static ones.<fn-def>

<p>
During the initialization of a SubL system at startup, variables
defined via <a href="#FN-DEF-DEFVAR"><tt>DEFVAR</tt></a><fn-ref> have their initial values set via their
state in the world file used at startup, ignoring the initial value
specified by the code.  <a href="#FN-DEF-DEFPARAMETER"><tt>DEFPARAMETER</tt></a><fn-ref> variables and 
<a href="#FN-DEF-DEFCONSTANT"><tt>DEFCONSTANT</tt></a><fn-ref> global constants have their values initialized
via the code on startup.

<p>
The net result of this distinction is as follows: if a world is saved
out via WRITE-IMAGE, and then used to restart a SubL system, the
values of <a href="#FN-DEF-DEFVAR"><tt>DEFVAR</tt></a><fn-ref> variables will persist, while any changes to
<a href="#FN-DEF-DEFPARAMETER"><tt>DEFPARAMETER</tt></a><fn-ref> variables will be lost when they are reset to their
original code-specified initial values on startup.

<!----- Major Section ---------------------------------------->
<a name=Index></a>
<hr>
<h1>Index</h1>

<a href=http://www.supelec.fr/docs/cltl/clm/index.html>
CLtL2 Reference
</a>

<p>
<b>
<a href=#Index-A>A</a> |
<a href=#Index-B>B</a> |
<a href=#Index-C>C</a> |
<a href=#Index-D>D</a> |
<a href=#Index-E>E</a> |
<a href=#Index-F>F</a> |
<a href=#Index-G>G</a> |
<a href=#Index-H>H</a> |
<a href=#Index-I>I</a> |
<a href=#Index-J>J</a> |
<a href=#Index-K>K</a> |
<a href=#Index-L>L</a> |
<a href=#Index-M>M</a> |
<a href=#Index-N>N</a> |
<a href=#Index-O>O</a> |
<a href=#Index-P>P</a> |
<a href=#Index-Q>Q</a> |
<a href=#Index-R>R</a> |
<a href=#Index-S>S</a> |
<a href=#Index-T>T</a> |
<a href=#Index-U>U</a> |
<a href=#Index-V>V</a> |
<a href=#Index-W>W</a> |
<a href=#Index-X>X</a> |
<a href=#Index-Y>Y</a> |
<a href=#Index-Z>Z</a>
</b>

<p>
<br>
<a href="#FN-DEF-1280"><tt>*</tt></a> function<index-fn-ref >
<br>
<a href="#SYM-DEF-1280"><tt>*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-165120"><tt>**</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-21136640"><tt>***</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1161467279"><tt>*CLOCK-GRANULARITY*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1424597890"><tt>*CONTINUE-CERROR?*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-609384130"><tt>*DEFAULT-PATHNAME-DEFAULTS*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-2020021124"><tt>*EPOCH*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-860597104"><tt>*ERROR-ABORT-HANDLER*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-354311860"><tt>*ERROR-HANDLER*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1079241228"><tt>*ERROR-MESSAGE*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-704643174"><tt>*ERROR-OUTPUT*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-204607828"><tt>*IGNORE-BREAKS?*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-2065003033"><tt>*IGNORE-MUSTS?*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1528898064"><tt>*IGNORE-WARNS?*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1188374285"><tt>*MOST-NEGATIVE-FIXNUM*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-113980253"><tt>*MOST-POSITIVE-FIXNUM*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1624760991"><tt>*MULTIPLE-VALUES-LIMIT*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1405149315"><tt>*NULL-OUTPUT*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-313735324"><tt>*PRINT-ESCAPE*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-430643141"><tt>*RAND-MAX*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-371148559"><tt>*SIGNAL-MAX*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-694198800"><tt>*SILENT-PROGRESS?*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1112282190"><tt>*STANDARD-INPUT*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1982975489"><tt>*STANDARD-OUTPUT*</tt></a> variable<index-sym-ref >
<br>
<a href="#SYM-DEF-1570894042"><tt>*SUSPEND-TYPE-CHECKING?*</tt></a> variable<index-sym-ref >
<br>
<a href="#FN-DEF-+"><tt>+</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF--"><tt>-</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-/"><tt>/</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-/="><tt>/=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-3584"><tt>&lt;</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-462464"><tt>&lt;=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-="><tt>=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-3840"><tt>&gt;</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-495232"><tt>&gt;=</tt></a> function<index-fn-ref >

<a name=Index-A></a><h4> A </h4>

<br>
<a href="#FN-DEF-ACONS"><tt>ACONS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ADJOIN"><tt>ADJOIN</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ALERT-USER"><tt>ALERT-USER</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ALPHA-CHAR-P"><tt>ALPHA-CHAR-P</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ALPHANUMERICP"><tt>ALPHANUMERICP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-APPEND"><tt>APPEND</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-APPEND-FILES"><tt>APPEND-FILES</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-APPLY"><tt>APPLY</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-AREF"><tt>AREF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ASSOC"><tt>ASSOC</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ASSOC-IF"><tt>ASSOC-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ATOM"><tt>ATOM</tt></a> function<index-fn-ref >

<a name=Index-B></a><h4> B </h4>

<br>
<a href="#FN-DEF-BOTH-CASE-P"><tt>BOTH-CASE-P</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-BOUNDP"><tt>BOUNDP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-BREAK"><tt>BREAK</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-BUTLAST"><tt>BUTLAST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-BYTE"><tt>BYTE</tt></a> macro<index-fn-ref >

<a name=Index-C></a><h4> C </h4>

<br>
<a href="#FN-DEF-CAAR"><tt>CAAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CADR"><tt>CADR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CAND"><tt>CAND</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CAR"><tt>CAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CCATCH"><tt>CCATCH</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CCONCATENATE"><tt>CCONCATENATE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CDAR"><tt>CDAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CDDR"><tt>CDDR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CDEC"><tt>CDEC</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CDESTRUCTURING-BIND"><tt>CDESTRUCTURING-BIND</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CDO"><tt>CDO</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CDOHASH"><tt>CDOHASH</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CDOLIST"><tt>CDOLIST</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CDOTIMES"><tt>CDOTIMES</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CDR"><tt>CDR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CEILING"><tt>CEILING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CERROR"><tt>CERROR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR"><tt>CHAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-CODE"><tt>CHAR-CODE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-DOWNCASE"><tt>CHAR-DOWNCASE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-EQUAL"><tt>CHAR-EQUAL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-GREATERP"><tt>CHAR-GREATERP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-LESSP"><tt>CHAR-LESSP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-NOT-EQUAL"><tt>CHAR-NOT-EQUAL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-NOT-GREATERP"><tt>CHAR-NOT-GREATERP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-NOT-LESSP"><tt>CHAR-NOT-LESSP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR-UPCASE"><tt>CHAR-UPCASE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR/="><tt>CHAR/=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-137661468"><tt>CHAR&lt;</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-440795332"><tt>CHAR&lt;=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHAR="><tt>CHAR=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-137661724"><tt>CHAR&gt;</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-440828100"><tt>CHAR&gt;=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHARACTERP"><tt>CHARACTERP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CHECK-TYPE"><tt>CHECK-TYPE</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CINC"><tt>CINC</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CLET"><tt>CLET</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CLOSE"><tt>CLOSE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CLRHASH"><tt>CLRHASH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CMERGE"><tt>CMERGE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CMULTIPLE-VALUE-BIND"><tt>CMULTIPLE-VALUE-BIND</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CNOT"><tt>CNOT</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CODE-CHAR"><tt>CODE-CHAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CONS"><tt>CONS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CONSP"><tt>CONSP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CONSTANTP"><tt>CONSTANTP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CONSTRUCT-FILENAME"><tt>CONSTRUCT-FILENAME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-COPY-ALIST"><tt>COPY-ALIST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-COPY-LIST"><tt>COPY-LIST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-COPY-SEQ"><tt>COPY-SEQ</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-COPY-TREE"><tt>COPY-TREE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-COR"><tt>COR</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-COUNT"><tt>COUNT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-COUNT-IF"><tt>COUNT-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CPOP"><tt>CPOP</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CPROGV"><tt>CPROGV</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CPUSH"><tt>CPUSH</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CPUSHNEW"><tt>CPUSHNEW</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CREDUCE"><tt>CREDUCE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-CSETF"><tt>CSETF</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CSETQ"><tt>CSETQ</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CSOME"><tt>CSOME</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CTIME"><tt>CTIME</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-CUNWIND-PROTECT"><tt>CUNWIND-PROTECT</tt></a> macro<index-fn-ref >

<a name=Index-D></a><h4> D </h4>

<br>
<a href="#FN-DEF-DEBUG"><tt>DEBUG</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DECLAIM"><tt>DECLAIM</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DECLARE"><tt>DECLARE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DECODE-UNIVERSAL-TIME"><tt>DECODE-UNIVERSAL-TIME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DEFAULT-SIGNAL-HANDLER"><tt>DEFAULT-SIGNAL-HANDLER</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DEFAULT-STRUCT-PRINT-FUNCTION"><tt>DEFAULT-STRUCT-PRINT-FUNCTION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DEFCONSTANT"><tt>DEFCONSTANT</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DEFINE"><tt>DEFINE</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DEFINE-METHOD"><tt>DEFINE-METHOD</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DEFMACRO"><tt>DEFMACRO</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DEFPARAMETER"><tt>DEFPARAMETER</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DEFPOLYMORPHIC"><tt>DEFPOLYMORPHIC</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DEFSTRUCT"><tt>DEFSTRUCT</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DEFVAR"><tt>DEFVAR</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-DELETE"><tt>DELETE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DELETE-DUPLICATES"><tt>DELETE-DUPLICATES</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DELETE-FILE"><tt>DELETE-FILE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DELETE-IF"><tt>DELETE-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DIGIT-CHAR-P"><tt>DIGIT-CHAR-P</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DIRECTORY"><tt>DIRECTORY</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-DPB"><tt>DPB</tt></a> function<index-fn-ref >

<a name=Index-E></a><h4> E </h4>

<br>
<a href="#FN-DEF-EIGHTH"><tt>EIGHTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ELT"><tt>ELT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ENCODE-TIMESTRING"><tt>ENCODE-TIMESTRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ENCODE-UNIVERSAL-TIME"><tt>ENCODE-UNIVERSAL-TIME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ENDP"><tt>ENDP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-EQ"><tt>EQ</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-EQL"><tt>EQL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-EQUAL"><tt>EQUAL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-EQUALP"><tt>EQUALP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ERROR"><tt>ERROR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-EVAL"><tt>EVAL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-EVENP"><tt>EVENP</tt></a> function<index-fn-ref >

<a name=Index-F></a><h4> F </h4>

<br>
<a href="#FN-DEF-FBOUNDP"><tt>FBOUNDP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FIF"><tt>FIF</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-FIFTH"><tt>FIFTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FILE-AUTHOR"><tt>FILE-AUTHOR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FILE-LENGTH"><tt>FILE-LENGTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FILE-WRITE-DATE"><tt>FILE-WRITE-DATE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FILL"><tt>FILL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FIND"><tt>FIND</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FIND-IF"><tt>FIND-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FIND-SYMBOL"><tt>FIND-SYMBOL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FIRST"><tt>FIRST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FIXNUMP"><tt>FIXNUMP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FLOAT"><tt>FLOAT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FLOATP"><tt>FLOATP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FLOOR"><tt>FLOOR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FMAKUNBOUND"><tt>FMAKUNBOUND</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FORCE-OUTPUT"><tt>FORCE-OUTPUT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FORK-PROCESS"><tt>FORK-PROCESS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FORMAT"><tt>FORMAT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FOURTH"><tt>FOURTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FUNCALL"><tt>FUNCALL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FUNCTION"><tt>FUNCTION</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-FUNCTION-INFORMATION"><tt>FUNCTION-INFORMATION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FUNCTION-SPEC-P"><tt>FUNCTION-SPEC-P</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FUNCTIONP"><tt>FUNCTIONP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-FUNLESS"><tt>FUNLESS</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-FWHEN"><tt>FWHEN</tt></a> macro<index-fn-ref >

<a name=Index-G></a><h4> G </h4>

<br>
<a href="#FN-DEF-GC"><tt>GC</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GENSYM"><tt>GENSYM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GENTEMP"><tt>GENTEMP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET"><tt>GET</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-CONSING-STATE"><tt>GET-CONSING-STATE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-FILE-POSITION"><tt>GET-FILE-POSITION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-INTERNAL-REAL-TIME"><tt>GET-INTERNAL-REAL-TIME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-MACHINE-NAME"><tt>GET-MACHINE-NAME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-NETWORK-NAME"><tt>GET-NETWORK-NAME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-PROCESS-ID"><tt>GET-PROCESS-ID</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-STRING-FROM-USER"><tt>GET-STRING-FROM-USER</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-UNIVERSAL-TIME"><tt>GET-UNIVERSAL-TIME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GET-USER-NAME"><tt>GET-USER-NAME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-GETHASH"><tt>GETHASH</tt></a> function<index-fn-ref >

<a name=Index-H></a><h4> H </h4>

<br>
<a href="#FN-DEF-HASH-TABLE-COUNT"><tt>HASH-TABLE-COUNT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-HASH-TABLE-P"><tt>HASH-TABLE-P</tt></a> function<index-fn-ref >

<a name=Index-I></a><h4> I </h4>

<br>
<a href="#FN-DEF-IDENTITY"><tt>IDENTITY</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-IGNORE"><tt>IGNORE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-IN-PACKAGE"><tt>IN-PACKAGE</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-INPUT-STREAM-P"><tt>INPUT-STREAM-P</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-INSTALL-SIGNAL-HANDLER"><tt>INSTALL-SIGNAL-HANDLER</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-INT/"><tt>INT/</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-INTEGER-DECODE-FLOAT"><tt>INTEGER-DECODE-FLOAT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-INTEGERP"><tt>INTEGERP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-INTERN"><tt>INTERN</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-INTERSECTION"><tt>INTERSECTION</tt></a> function<index-fn-ref >

<a name=Index-J></a><h4> J </h4>

<a name=Index-K></a><h4> K </h4>

<br>
<a href="#FN-DEF-KEYWORDP"><tt>KEYWORDP</tt></a> function<index-fn-ref >

<a name=Index-L></a><h4> L </h4>

<br>
<a href="#FN-DEF-LAST"><tt>LAST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LDB"><tt>LDB</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LDIFF"><tt>LDIFF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LENGTH"><tt>LENGTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LIST"><tt>LIST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-443877220"><tt>LIST*</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LIST-LENGTH"><tt>LIST-LENGTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LISTP"><tt>LISTP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LOAD"><tt>LOAD</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LOG-MESSAGE"><tt>LOG-MESSAGE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-LOWER-CASE-P"><tt>LOWER-CASE-P</tt></a> function<index-fn-ref >

<a name=Index-M></a><h4> M </h4>

<br>
<a href="#FN-DEF-MAKE-HASH-TABLE"><tt>MAKE-HASH-TABLE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAKE-LIST"><tt>MAKE-LIST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAKE-STRING"><tt>MAKE-STRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAKE-SYMBOL"><tt>MAKE-SYMBOL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAKE-VECTOR"><tt>MAKE-VECTOR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAKUNBOUND"><tt>MAKUNBOUND</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAPC"><tt>MAPC</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAPCAN"><tt>MAPCAN</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAPCAR"><tt>MAPCAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAPCON"><tt>MAPCON</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAPHASH"><tt>MAPHASH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAPL"><tt>MAPL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAPLIST"><tt>MAPLIST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MAX"><tt>MAX</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MEMBER"><tt>MEMBER</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MEMBER-IF"><tt>MEMBER-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MIN"><tt>MIN</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MINUSP"><tt>MINUSP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MISMATCH"><tt>MISMATCH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MOD"><tt>MOD</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-MULTIPLE-VALUE-LIST"><tt>MULTIPLE-VALUE-LIST</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-MUST"><tt>MUST</tt></a> macro<index-fn-ref >

<a name=Index-N></a><h4> N </h4>

<br>
<a href="#FN-DEF-NBUTLAST"><tt>NBUTLAST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NCONC"><tt>NCONC</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NINTERSECTION"><tt>NINTERSECTION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NINTH"><tt>NINTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NOTE-ACTIVITY"><tt>NOTE-ACTIVITY</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NOTE-NUMERIC-PROGRESS"><tt>NOTE-NUMERIC-PROGRESS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NOTE-PERCENT-PROGRESS"><tt>NOTE-PERCENT-PROGRESS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NOTIFY-USER"><tt>NOTIFY-USER</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NOTING-ACTIVITY"><tt>NOTING-ACTIVITY</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-NOTING-NUMERIC-PROGRESS"><tt>NOTING-NUMERIC-PROGRESS</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-NOTING-PERCENT-PROGRESS"><tt>NOTING-PERCENT-PROGRESS</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-NRECONC"><tt>NRECONC</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NREVERSE"><tt>NREVERSE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSET-DIFFERENCE"><tt>NSET-DIFFERENCE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSET-EXCLUSIVE-OR"><tt>NSET-EXCLUSIVE-OR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSTRING-CAPITALIZE"><tt>NSTRING-CAPITALIZE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSTRING-DOWNCASE"><tt>NSTRING-DOWNCASE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSTRING-UPCASE"><tt>NSTRING-UPCASE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSUBLIS"><tt>NSUBLIS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSUBST"><tt>NSUBST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSUBST-IF"><tt>NSUBST-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSUBSTITUTE"><tt>NSUBSTITUTE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NSUBSTITUTE-IF"><tt>NSUBSTITUTE-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NTH"><tt>NTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NTHCDR"><tt>NTHCDR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NULL"><tt>NULL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NUMBERP"><tt>NUMBERP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-NUNION"><tt>NUNION</tt></a> function<index-fn-ref >

<a name=Index-O></a><h4> O </h4>

<br>
<a href="#FN-DEF-ODDP"><tt>ODDP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-OPEN-BINARY"><tt>OPEN-BINARY</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-OPEN-TCP-STREAM"><tt>OPEN-TCP-STREAM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-OPEN-TEXT"><tt>OPEN-TEXT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-OUTPUT-STREAM-P"><tt>OUTPUT-STREAM-P</tt></a> function<index-fn-ref >

<a name=Index-P></a><h4> P </h4>

<br>
<a href="#FN-DEF-PAIRLIS"><tt>PAIRLIS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PCASE"><tt>PCASE</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-PCOND"><tt>PCOND</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-PIF"><tt>PIF</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-PLUSP"><tt>PLUSP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-POSITION"><tt>POSITION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-POSITION-IF"><tt>POSITION-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PRIN1"><tt>PRIN1</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PRIN1-TO-STRING"><tt>PRIN1-TO-STRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PRINC"><tt>PRINC</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PRINC-TO-STRING"><tt>PRINC-TO-STRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PRINT"><tt>PRINT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PRINTING-OBJECT"><tt>PRINTING-OBJECT</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-PROBE-FILE"><tt>PROBE-FILE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PROCLAIM"><tt>PROCLAIM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PROGN"><tt>PROGN</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-PUNLESS"><tt>PUNLESS</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-PUT"><tt>PUT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-PWHEN"><tt>PWHEN</tt></a> macro<index-fn-ref >

<a name=Index-Q></a><h4> Q </h4>

<br>
<a href="#FN-DEF-QUOTE"><tt>QUOTE</tt></a> function<index-fn-ref >

<a name=Index-R></a><h4> R </h4>

<br>
<a href="#FN-DEF-RANDOM"><tt>RANDOM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-RASSOC"><tt>RASSOC</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-RASSOC-IF"><tt>RASSOC-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-READ"><tt>READ</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-READ-BYTE"><tt>READ-BYTE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-READ-CHAR"><tt>READ-CHAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-READ-FROM-STRING"><tt>READ-FROM-STRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-READ-LINE"><tt>READ-LINE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REM"><tt>REM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REMHASH"><tt>REMHASH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REMOVE"><tt>REMOVE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REMOVE-DUPLICATES"><tt>REMOVE-DUPLICATES</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REMOVE-IF"><tt>REMOVE-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REMPROP"><tt>REMPROP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-RENAME-FILE"><tt>RENAME-FILE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REPLACE"><tt>REPLACE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REPORT-ERROR"><tt>REPORT-ERROR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REST"><tt>REST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-RESTART-PROCESS"><tt>RESTART-PROCESS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-RET"><tt>RET</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-REVAPPEND"><tt>REVAPPEND</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-REVERSE"><tt>REVERSE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-ROUND"><tt>ROUND</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-RPLACA"><tt>RPLACA</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-RPLACD"><tt>RPLACD</tt></a> function<index-fn-ref >

<a name=Index-S></a><h4> S </h4>

<br>
<a href="#FN-DEF-SCALE-FLOAT"><tt>SCALE-FLOAT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SEARCH"><tt>SEARCH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SECOND"><tt>SECOND</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SEED-RANDOM"><tt>SEED-RANDOM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SEQUENCEP"><tt>SEQUENCEP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET"><tt>SET</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET-AREF"><tt>SET-AREF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET-CHAR"><tt>SET-CHAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET-CONSING-STATE"><tt>SET-CONSING-STATE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET-DIFFERENCE"><tt>SET-DIFFERENCE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET-EXCLUSIVE-OR"><tt>SET-EXCLUSIVE-OR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET-FILE-POSITION"><tt>SET-FILE-POSITION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SET-NTH"><tt>SET-NTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SETHASH"><tt>SETHASH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SEVENTH"><tt>SEVENTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SIXTH"><tt>SIXTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SLEEP"><tt>SLEEP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SORT"><tt>SORT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STABLE-SORT"><tt>STABLE-SORT</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STREAMP"><tt>STREAMP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING"><tt>STRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-CAPITALIZE"><tt>STRING-CAPITALIZE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-DOWNCASE"><tt>STRING-DOWNCASE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-EQUAL"><tt>STRING-EQUAL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-GREATERP"><tt>STRING-GREATERP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-LEFT-TRIM"><tt>STRING-LEFT-TRIM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-LESSP"><tt>STRING-LESSP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-NOT-EQUAL"><tt>STRING-NOT-EQUAL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-NOT-GREATERP"><tt>STRING-NOT-GREATERP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-NOT-LESSP"><tt>STRING-NOT-LESSP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-RIGHT-TRIM"><tt>STRING-RIGHT-TRIM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-TRIM"><tt>STRING-TRIM</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING-UPCASE"><tt>STRING-UPCASE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING/="><tt>STRING/=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-427203732"><tt>STRING&lt;</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-994985164"><tt>STRING&lt;=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRING="><tt>STRING=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-427203988"><tt>STRING&gt;</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-995017932"><tt>STRING&gt;=</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-STRINGP"><tt>STRINGP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SUBLIS"><tt>SUBLIS</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SUBSEQ"><tt>SUBSEQ</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SUBSETP"><tt>SUBSETP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SUBST"><tt>SUBST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SUBST-IF"><tt>SUBST-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SUBSTITUTE"><tt>SUBSTITUTE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SUBSTITUTE-IF"><tt>SUBSTITUTE-IF</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SXHASH"><tt>SXHASH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SYMBOL-FUNCTION"><tt>SYMBOL-FUNCTION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SYMBOL-NAME"><tt>SYMBOL-NAME</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SYMBOL-PLIST"><tt>SYMBOL-PLIST</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SYMBOL-VALUE"><tt>SYMBOL-VALUE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-SYMBOLP"><tt>SYMBOLP</tt></a> function<index-fn-ref >

<a name=Index-T></a><h4> T </h4>

<br>
<a href="#FN-DEF-TAILP"><tt>TAILP</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-TENTH"><tt>TENTH</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-TERPRI"><tt>TERPRI</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-THIRD"><tt>THIRD</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-THROW"><tt>THROW</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-TIME-FROM-NOW"><tt>TIME-FROM-NOW</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-TIME-HAS-ARRIVED?"><tt>TIME-HAS-ARRIVED?</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-TIMESTRING"><tt>TIMESTRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-TREE-EQUAL"><tt>TREE-EQUAL</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-TRUNCATE"><tt>TRUNCATE</tt></a> function<index-fn-ref >

<a name=Index-U></a><h4> U </h4>

<br>
<a href="#FN-DEF-UNION"><tt>UNION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-UNREAD-CHAR"><tt>UNREAD-CHAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-UPPER-CASE-P"><tt>UPPER-CASE-P</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-USER-CONFIRM"><tt>USER-CONFIRM</tt></a> function<index-fn-ref >

<a name=Index-V></a><h4> V </h4>

<br>
<a href="#FN-DEF-VALUES"><tt>VALUES</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-VARIABLE-INFORMATION"><tt>VARIABLE-INFORMATION</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-VECTOR"><tt>VECTOR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-VECTORP"><tt>VECTORP</tt></a> function<index-fn-ref >

<a name=Index-W></a><h4> W </h4>

<br>
<a href="#FN-DEF-WARN"><tt>WARN</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-WITH-BINARY-FILE"><tt>WITH-BINARY-FILE</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-WITH-STATIC-AREA"><tt>WITH-STATIC-AREA</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-WITH-TEXT-FILE"><tt>WITH-TEXT-FILE</tt></a> macro<index-fn-ref >
<br>
<a href="#FN-DEF-WRITE"><tt>WRITE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-WRITE-BYTE"><tt>WRITE-BYTE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-WRITE-CHAR"><tt>WRITE-CHAR</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-WRITE-IMAGE"><tt>WRITE-IMAGE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-WRITE-LINE"><tt>WRITE-LINE</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-WRITE-STRING"><tt>WRITE-STRING</tt></a> function<index-fn-ref >
<br>
<a href="#FN-DEF-WRITE-TO-STRING"><tt>WRITE-TO-STRING</tt></a> function<index-fn-ref >

<a name=Index-X></a><h4> X </h4>

<a name=Index-Y></a><h4> Y </h4>

<a name=Index-Z></a><h4> Z </h4>

<br>
<a href="#FN-DEF-ZEROP"><tt>ZEROP</tt></a> function<index-fn-ref >









</html>